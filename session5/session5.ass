[Script Info]
; This is an Advanced Sub Station Alpha v4+ script.
Title: session5
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H0300FFFF,&H00000000,&H02000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:49.08,0:00:54.08,Default,,0,0,0,,
Dialogue: 0,0:04:20.92,0:04:25.92,Default,,0,0,0,,
Dialogue: 0,0:08:00.52,0:08:05.52,Default,,0,0,0,,
Dialogue: 0,0:13:01.92,0:13:04.56,Default,,0,0,0,,RICHARD EISENBERG: Hi everyone!
Dialogue: 0,0:13:04.56,0:13:08.16,Default,,0,0,0,,Welcome to Technical\NSession 5 of ICFP 2020.
Dialogue: 0,0:13:08.16,0:13:09.96,Default,,0,0,0,,My name is Richard Eisenberg.
Dialogue: 0,0:13:09.96,0:13:13.00,Default,,0,0,0,,I'm principal researcher\Nat Tweak I/O
Dialogue: 0,0:13:13.00,0:13:17.52,Default,,0,0,0,,and a member of the ICFP\NProgram Committee.
Dialogue: 0,0:13:17.52,0:13:21.52,Default,,0,0,0,,This session will be\Nstreamed via YouTube
Dialogue: 0,0:13:21.52,0:13:24.60,Default,,0,0,0,,but is also available via Clowdr.
Dialogue: 0,0:13:24.60,0:13:25.88,Default,,0,0,0,,So, those of you who registered
Dialogue: 0,0:13:25.88,0:13:28.12,Default,,0,0,0,,if you're on YouTube please\Nswitch over to Clowdr.
Dialogue: 0,0:13:28.12,0:13:30.68,Default,,0,0,0,,You should have gotten\Na notification, an email
Dialogue: 0,0:13:30.68,0:13:32.12,Default,,0,0,0,,how to do so.
Dialogue: 0,0:13:32.12,0:13:35.52,Default,,0,0,0,,And that will give you access\Nto more interactive features
Dialogue: 0,0:13:35.52,0:13:37.44,Default,,0,0,0,,of these presentations.
Dialogue: 0,0:13:37.44,0:13:42.84,Default,,0,0,0,,Including links to the question\Nand answer sessions from the authors.
Dialogue: 0,0:13:42.84,0:13:44.72,Default,,0,0,0,,So, first up in this session,
Dialogue: 0,0:13:44.72,0:13:47.12,Default,,0,0,0,,we have Joe Cutler who will present
Dialogue: 0,0:13:47.12,0:13:50.40,Default,,0,0,0,,how we can extract recurrent\Nrelations from functions
Dialogue: 0,0:13:50.40,0:13:55.40,Default,,0,0,0,,for amortized analysis.
Dialogue: 0,0:13:55.88,0:13:57.52,Default,,0,0,0,,JOE CUTLER: Hi, I'm Joe Cutler.
Dialogue: 0,0:13:57.52,0:13:59.72,Default,,0,0,0,,I'm an undergraduate at Wesleyan\NUniversity in Connecticut.
Dialogue: 0,0:13:59.72,0:14:01.88,Default,,0,0,0,,And this is work with\Nmy advisor Dan Licata
Dialogue: 0,0:14:01.88,0:14:03.92,Default,,0,0,0,,and Norman Danner.
Dialogue: 0,0:14:03.92,0:14:06.20,Default,,0,0,0,,So, if I handed you this\Ncode for mergeSort
Dialogue: 0,0:14:06.20,0:14:07.84,Default,,0,0,0,,and then asked you to\Nwrite down a recurrence
Dialogue: 0,0:14:07.84,0:14:09.88,Default,,0,0,0,,for its worst-case execution cost,
Dialogue: 0,0:14:09.88,0:14:11.40,Default,,0,0,0,,you'll probably end up writing down
Dialogue: 0,0:14:11.40,0:14:14.16,Default,,0,0,0,,pretty much exactly this\Nexpression right here.
Dialogue: 0,0:14:14.16,0:14:15.88,Default,,0,0,0,,But the thing you did in\Nyour head to get there
Dialogue: 0,0:14:15.88,0:14:18.40,Default,,0,0,0,,is actually pretty subtle.
Dialogue: 0,0:14:18.40,0:14:21.76,Default,,0,0,0,,It required knowing things about\Nthe sizes of the results of functions.
Dialogue: 0,0:14:21.76,0:14:24.60,Default,,0,0,0,,Like the fact that\Nsplit splits lists in half
Dialogue: 0,0:14:24.60,0:14:27.48,Default,,0,0,0,,and abstracting list\Ndown to just a length.
Dialogue: 0,0:14:27.48,0:14:30.04,Default,,0,0,0,,And even more importantly\Nas a PL person,
Dialogue: 0,0:14:30.04,0:14:32.64,Default,,0,0,0,,you might even have\Nan operational semantics
Dialogue: 0,0:14:32.64,0:14:34.60,Default,,0,0,0,,for a language that this\Nfunction is written in,
Dialogue: 0,0:14:34.60,0:14:38.00,Default,,0,0,0,,that precisely defines\Nthe cost of program execution
Dialogue: 0,0:14:38.00,0:14:42.28,Default,,0,0,0,,in terms of beta redexes\Nor some other cost metrics.
Dialogue: 0,0:14:42.28,0:14:44.52,Default,,0,0,0,,And how do you know this\Nrecurrence you wrote down
Dialogue: 0,0:14:44.52,0:14:48.20,Default,,0,0,0,,has anything to do whatsoever\Nwith those formal costs?
Dialogue: 0,0:14:48.20,0:14:49.76,Default,,0,0,0,,So, in other words,
Dialogue: 0,0:14:49.76,0:14:54.28,Default,,0,0,0,,how do we make this informal process\Nof recurrence extraction formal
Dialogue: 0,0:14:54.28,0:14:56.28,Default,,0,0,0,,and ensure that it's correct?
Dialogue: 0,0:14:56.28,0:14:59.20,Default,,0,0,0,,Well, at ICFP five years ago,
Dialogue: 0,0:14:59.20,0:15:02.12,Default,,0,0,0,,the other two authors of this\Npaper and their co-author
Dialogue: 0,0:15:02.12,0:15:05.08,Default,,0,0,0,,presented an answer to\Nexactly that question.
Dialogue: 0,0:15:05.08,0:15:07.28,Default,,0,0,0,,And I guess rather than\Nkeep you on suspense,
Dialogue: 0,0:15:07.28,0:15:10.16,Default,,0,0,0,,I just show you what\Nthey came up with.
Dialogue: 0,0:15:10.16,0:15:12.72,Default,,0,0,0,,So, recurrence extraction\Nis formalized as
Dialogue: 0,0:15:12.72,0:15:14.96,Default,,0,0,0,,a language-to-language translation.
Dialogue: 0,0:15:14.96,0:15:17.04,Default,,0,0,0,,So, given the term in\Nsome source language
Dialogue: 0,0:15:17.04,0:15:20.00,Default,,0,0,0,,we can translate it into\Na language that we call lambda C
Dialogue: 0,0:15:20.00,0:15:21.92,Default,,0,0,0,,which is a language whose terms are
Dialogue: 0,0:15:21.92,0:15:24.48,Default,,0,0,0,,syntactic recurrence relations.
Dialogue: 0,0:15:24.48,0:15:26.28,Default,,0,0,0,,Now, the overall idea\Nof this translation
Dialogue: 0,0:15:26.28,0:15:29.16,Default,,0,0,0,,which we often call formal\Nrecurrence extraction
Dialogue: 0,0:15:29.16,0:15:33.20,Default,,0,0,0,,is to translate terms to\Noutput their evaluation cost
Dialogue: 0,0:15:33.20,0:15:35.36,Default,,0,0,0,,along with the size of the result.
Dialogue: 0,0:15:35.36,0:15:39.28,Default,,0,0,0,,So, a term of type A in a source\Ngets translated to a pair.
Dialogue: 0,0:15:39.28,0:15:41.60,Default,,0,0,0,,Consisting of the cost\Nto evaluate that term
Dialogue: 0,0:15:41.60,0:15:43.60,Default,,0,0,0,,along with the resulting value,
Dialogue: 0,0:15:43.60,0:15:46.00,Default,,0,0,0,,the size of the resulting\Nvalue of type A.
Dialogue: 0,0:15:46.00,0:15:48.40,Default,,0,0,0,,Now, this size translation\Nthat I'm talking about
Dialogue: 0,0:15:48.40,0:15:50.96,Default,,0,0,0,,is essentially\Nthe identity on values
Dialogue: 0,0:15:50.96,0:15:53.24,Default,,0,0,0,,but it shifts to a higher type
Dialogue: 0,0:15:53.24,0:15:56.92,Default,,0,0,0,,where the size of a function is\Na recurrence in a traditional sense.
Dialogue: 0,0:15:56.92,0:16:00.44,Default,,0,0,0,,So, it's a function from\Nsizes to cost and sizes.
Dialogue: 0,0:16:00.44,0:16:02.60,Default,,0,0,0,,Now, the real meat of this\Nrecurrence extraction
Dialogue: 0,0:16:02.60,0:16:05.80,Default,,0,0,0,,is the term translation which\Nis defined compositionally
Dialogue: 0,0:16:05.80,0:16:08.12,Default,,0,0,0,,by recursion over raw syntax.
Dialogue: 0,0:16:08.12,0:16:09.64,Default,,0,0,0,,So, given a term in the source,
Dialogue: 0,0:16:09.64,0:16:12.60,Default,,0,0,0,,we can just translate it\Nto a term in lambda C.
Dialogue: 0,0:16:12.60,0:16:15.24,Default,,0,0,0,,Now, if you're\Na monadically minded person,
Dialogue: 0,0:16:15.24,0:16:17.60,Default,,0,0,0,,you might recognize\Nall of this as being
Dialogue: 0,0:16:17.60,0:16:20.04,Default,,0,0,0,,a monadic translation\Ninto the writer monad.
Dialogue: 0,0:16:20.04,0:16:22.04,Default,,0,0,0,,And all of this helps\Nmotivate the definition
Dialogue: 0,0:16:22.04,0:16:23.48,Default,,0,0,0,,of a size translation.
Dialogue: 0,0:16:23.48,0:16:26.00,Default,,0,0,0,,Arrows in the source become\NKleisli arrows in lambda C.
Dialogue: 0,0:16:27.36,0:16:29.04,Default,,0,0,0,,So we've extracted\Nrecurrences
Dialogue: 0,0:16:29.04,0:16:30.80,Default,,0,0,0,,from the source language\Ninto lambda C.
Dialogue: 0,0:16:30.80,0:16:34.28,Default,,0,0,0,,And now we need to prove that\Nthis extraction procedure is correct.
Dialogue: 0,0:16:34.28,0:16:35.76,Default,,0,0,0,,Otherwise all of this is no better
Dialogue: 0,0:16:35.76,0:16:38.84,Default,,0,0,0,,than just extracting recurrences\Nthe old informal way.
Dialogue: 0,0:16:39.64,0:16:42.80,Default,,0,0,0,,So, the first step here is to fix\Nan operational semantics
Dialogue: 0,0:16:42.80,0:16:45.92,Default,,0,0,0,,from the source language which\Nis indexed by execution cost.
Dialogue: 0,0:16:45.92,0:16:49.88,Default,,0,0,0,,You can read this judgment as\NM evaluates in n steps to V.
Dialogue: 0,0:16:50.68,0:16:54.04,Default,,0,0,0,,And then we prove this following\Ntheorem using a logical relation.
Dialogue: 0,0:16:54.04,0:16:59.00,Default,,0,0,0,,So, for any closed term m of type A,\Nif m evaluates in n steps to v,
Dialogue: 0,0:16:59.00,0:17:03.28,Default,,0,0,0,,then the extracted cost of running\NM is an upper bound on n,
Dialogue: 0,0:17:03.28,0:17:06.88,Default,,0,0,0,,and also the usual logical relations\Nvalue relation nonsense.
Dialogue: 0,0:17:06.88,0:17:10.28,Default,,0,0,0,,But anyway, this theorem is the\Ncrucial step, it formally connects
Dialogue: 0,0:17:10.28,0:17:13.64,Default,,0,0,0,,the operational cost model\Nto the extracted recurrences.
Dialogue: 0,0:17:14.88,0:17:17.52,Default,,0,0,0,,One important piece of the\Ninformal analysis
Dialogue: 0,0:17:17.52,0:17:20.80,Default,,0,0,0,,that this translation doesn't take\Ninto account is size abstraction,
Dialogue: 0,0:17:20.80,0:17:24.00,Default,,0,0,0,,like say, analyzing a function\Nwhich takes a list in terms
Dialogue: 0,0:17:24.00,0:17:27.12,Default,,0,0,0,,of its length or a tree function\Nby depth or something like that.
Dialogue: 0,0:17:27.12,0:17:30.44,Default,,0,0,0,,Now, we do this abstraction\Nusing a denotational semantics
Dialogue: 0,0:17:30.44,0:17:32.52,Default,,0,0,0,,from lambda c into\Npartially ordered sets.
Dialogue: 0,0:17:32.52,0:17:35.00,Default,,0,0,0,,And this means that the\Nobjects that we get out
Dialogue: 0,0:17:35.00,0:17:38.04,Default,,0,0,0,,are the standard objects you'd\Nrecognize as recurrences.
Dialogue: 0,0:17:38.04,0:17:41.40,Default,,0,0,0,,You can compute closed forms and\Nasymptotics and stuff like that.
Dialogue: 0,0:17:42.16,0:17:45.12,Default,,0,0,0,,OK, that was a lot of technical\Ndetail, I acknowledge that
Dialogue: 0,0:17:45.12,0:17:48.04,Default,,0,0,0,,but luckily all this has all\Nbeen done before.
Dialogue: 0,0:17:48.04,0:17:50.24,Default,,0,0,0,,And in the year since this\Ntechnique was developed,
Dialogue: 0,0:17:50.24,0:17:53.08,Default,,0,0,0,,it's been employed to formalize\Nrecurrence extraction
Dialogue: 0,0:17:53.08,0:17:55.88,Default,,0,0,0,,for increasingly realistic languages\Nfrom the simply typed
Dialogue: 0,0:17:55.88,0:17:59.60,Default,,0,0,0,,lambda calculus to inductive\Ntypes all the way up to PCF
Dialogue: 0,0:17:59.60,0:18:03.76,Default,,0,0,0,,and ML-style let polymorphism.\NBut all this prior work
Dialogue: 0,0:18:03.76,0:18:06.76,Default,,0,0,0,,is limited in the kinds of analyses\Nthey can handle.
Dialogue: 0,0:18:06.76,0:18:10.28,Default,,0,0,0,,Only ever worst case cost\Nanalysis and in many cases,
Dialogue: 0,0:18:10.28,0:18:12.76,Default,,0,0,0,,worst case cost analysis\Nsimply isn't enough
Dialogue: 0,0:18:12.76,0:18:15.84,Default,,0,0,0,,to get tight bounds, we,\Nand a technique like say,
Dialogue: 0,0:18:15.84,0:18:19.28,Default,,0,0,0,,amortized analysis is required\Nto get better bounds.
Dialogue: 0,0:18:19.28,0:18:22.36,Default,,0,0,0,,And so in this work we extend\Nthe recurrence extraction technique
Dialogue: 0,0:18:22.36,0:18:24.52,Default,,0,0,0,,to handle amortized analysis.
Dialogue: 0,0:18:25.56,0:18:28.88,Default,,0,0,0,,So, in the paper we go over\Ntwo standard examples
Dialogue: 0,0:18:28.88,0:18:32.08,Default,,0,0,0,,of amortized analysis to\Ndemonstrate the effectiveness
Dialogue: 0,0:18:32.08,0:18:34.92,Default,,0,0,0,,of our technique. And the first\Nis a simple binary counter
Dialogue: 0,0:18:34.92,0:18:37.88,Default,,0,0,0,,and the second is splay trees\Nas presented in Okasaki.
Dialogue: 0,0:18:38.64,0:18:41.76,Default,,0,0,0,,The splay trees are notable because\Nthey aren't really well handled
Dialogue: 0,0:18:41.76,0:18:44.04,Default,,0,0,0,,by automated amortized\Nanalysis techniques
Dialogue: 0,0:18:44.04,0:18:45.76,Default,,0,0,0,,such as resource aware ML.
Dialogue: 0,0:18:45.76,0:18:50.04,Default,,0,0,0,,And since the analysis of splay trees\Nis really complicated,
Dialogue: 0,0:18:50.04,0:18:51.64,Default,,0,0,0,,I only have like\N10 more minutes.
Dialogue: 0,0:18:52.28,0:18:55.20,Default,,0,0,0,,I'll use the binary counter as\Na running example to motivate the way
Dialogue: 0,0:18:55.20,0:18:57.68,Default,,0,0,0,,that we made our papers\Nmain contribution.
Dialogue: 0,0:18:57.68,0:19:01.00,Default,,0,0,0,,So, consider a binary number\Nrepresented as a list of bits
Dialogue: 0,0:19:01.00,0:19:03.36,Default,,0,0,0,,with the least significant\Nbit at the head,
Dialogue: 0,0:19:03.36,0:19:05.92,Default,,0,0,0,,we can define an increment function\Nin the standard way.
Dialogue: 0,0:19:05.92,0:19:07.88,Default,,0,0,0,,Note that if the least\Nsignificant bit is zero,
Dialogue: 0,0:19:08.60,0:19:09.76,Default,,0,0,0,,the increment is\Nconstant time
Dialogue: 0,0:19:09.76,0:19:11.20,Default,,0,0,0,,but if the least\Nsignificant bit is one,
Dialogue: 0,0:19:11.20,0:19:13.28,Default,,0,0,0,,we have to make a recursive\Ncall down the tail.
Dialogue: 0,0:19:14.40,0:19:16.48,Default,,0,0,0,,Now we can define a set function\Nwhich just sets the counter
Dialogue: 0,0:19:16.48,0:19:19.72,Default,,0,0,0,,to a natural number value by\Nlooping increments end times.
Dialogue: 0,0:19:20.24,0:19:22.56,Default,,0,0,0,,So, here are the recurrences\Nthat you'd expect to get
Dialogue: 0,0:19:22.56,0:19:24.88,Default,,0,0,0,,from these functions using\Nthe informal method.
Dialogue: 0,0:19:24.88,0:19:27.48,Default,,0,0,0,,By the way, for the rest of the\Ntalk will fix the cost model,
Dialogue: 0,0:19:27.48,0:19:30.36,Default,,0,0,0,,the cons operations are\Nthe only cost the operation,
Dialogue: 0,0:19:30.36,0:19:33.80,Default,,0,0,0,,in each incurring costs.\NSo, these two recurrences here solve
Dialogue: 0,0:19:33.80,0:19:37.24,Default,,0,0,0,,to T inc being linear,\Nand T set being n log n.
Dialogue: 0,0:19:37.76,0:19:41.88,Default,,0,0,0,,But this actually isn't a tight bound\Nfor set,it's actually linear.
Dialogue: 0,0:19:41.88,0:19:44.60,Default,,0,0,0,,Intuitively, this is because\Nthe constant time case
Dialogue: 0,0:19:44.60,0:19:47.68,Default,,0,0,0,,of the increment happens way\Nmore often while you're looping.
Dialogue: 0,0:19:47.68,0:19:50.44,Default,,0,0,0,,But you have to take the max between\Nthe two non empty branches
Dialogue: 0,0:19:50.44,0:19:53.24,Default,,0,0,0,,when you extract the recurrence,\Nwhich makes it look like
Dialogue: 0,0:19:53.24,0:19:56.24,Default,,0,0,0,,increment traverses the\Nwhole list every single time.
Dialogue: 0,0:19:56.24,0:19:59.00,Default,,0,0,0,,And unfortunately, this is exactly\Nwhat the prior work in
Dialogue: 0,0:19:59.00,0:20:01.72,Default,,0,0,0,,formal recurrence extraction\Nwould do to this example.
Dialogue: 0,0:20:01.72,0:20:03.24,Default,,0,0,0,,So, motivate some\Nstuff down the line,
Dialogue: 0,0:20:03.24,0:20:04.92,Default,,0,0,0,,let's take a look at\Nhow that would go.
Dialogue: 0,0:20:05.80,0:20:07.72,Default,,0,0,0,,So, we can take our increment\Nfunction written
Dialogue: 0,0:20:07.72,0:20:09.56,Default,,0,0,0,,in the source language\Nand pass it through
Dialogue: 0,0:20:09.56,0:20:11.80,Default,,0,0,0,,the recurrence extraction\Ntranslation to get a function
Dialogue: 0,0:20:11.80,0:20:14.96,Default,,0,0,0,,into a pair c cross which\Ncomputes the cost of running
Dialogue: 0,0:20:14.96,0:20:16.68,Default,,0,0,0,,an increment along with\Nthe size of the result.
Dialogue: 0,0:20:16.68,0:20:19.68,Default,,0,0,0,,Now, the first component of\Nthis pair is the important one,
Dialogue: 0,0:20:19.68,0:20:23.28,Default,,0,0,0,,it's the execution cost. So I'll\Njust write down the subscripts c.
Dialogue: 0,0:20:23.28,0:20:25.44,Default,,0,0,0,,Now this syntactic\Nrecurrence that you get out
Dialogue: 0,0:20:25.44,0:20:28.60,Default,,0,0,0,,is exactly what I hope\NYou'd expect. The key cases,
Dialogue: 0,0:20:28.60,0:20:31.40,Default,,0,0,0,,when the least significant bit\Nis one,it costs one for the cons
Dialogue: 0,0:20:31.40,0:20:33.24,Default,,0,0,0,,plus the cost of\Nrecursing down the tail.
Dialogue: 0,0:20:33.96,0:20:36.68,Default,,0,0,0,,Now, after this, we use\Nthe denotational semantics
Dialogue: 0,0:20:36.68,0:20:39.84,Default,,0,0,0,,to interpret this recurrence\Nas a map between Posets.
Dialogue: 0,0:20:39.84,0:20:43.08,Default,,0,0,0,,Most importantly, we interpret the\Nbit list type as the natural numbers
Dialogue: 0,0:20:43.08,0:20:46.24,Default,,0,0,0,,which abstracts a list to its\Nlength in the traditional way.
Dialogue: 0,0:20:46.76,0:20:50.12,Default,,0,0,0,,Now the monotone maps of\Nposets we get in the semantics
Dialogue: 0,0:20:50.12,0:20:52.20,Default,,0,0,0,,represent the exact\Nsame loose bounds
Dialogue: 0,0:20:52.20,0:20:53.48,Default,,0,0,0,,that we talked about before .
Dialogue: 0,0:20:54.24,0:20:56.80,Default,,0,0,0,,If you carry it all through\Nfor set you still get O(n log n).
Dialogue: 0,0:20:57.40,0:21:00.40,Default,,0,0,0,,So, we've seen how the\Nprevious work comes up short.
Dialogue: 0,0:21:00.40,0:21:02.52,Default,,0,0,0,,Now let's take a look at how\Nthe amortized analysis
Dialogue: 0,0:21:02.52,0:21:06.16,Default,,0,0,0,,of the binary counter actually\Nshould work to help inform
Dialogue: 0,0:21:06.16,0:21:08.08,Default,,0,0,0,,how to change the\Nrecurrence extraction
Dialogue: 0,0:21:08.08,0:21:10.44,Default,,0,0,0,,to get the tight amortized\Nbounds we are looking for.
Dialogue: 0,0:21:11.40,0:21:13.96,Default,,0,0,0,,So, here's a quick refresher\Non amortized analysis
Dialogue: 0,0:21:13.96,0:21:16.60,Default,,0,0,0,,for those of you who've forgotten\Nabout what the big deal was
Dialogue: 0,0:21:16.60,0:21:17.92,Default,,0,0,0,,since you last\Nlearned about it.
Dialogue: 0,0:21:17.92,0:21:20.56,Default,,0,0,0,,So, amortized analysis comes\Nin a few different forms
Dialogue: 0,0:21:20.56,0:21:24.12,Default,,0,0,0,,but all of them boil down\Nto essentially smoothing out cost
Dialogue: 0,0:21:24.12,0:21:26.08,Default,,0,0,0,,across program execution.
Dialogue: 0,0:21:26.08,0:21:29.32,Default,,0,0,0,,So, that when you analyse repeated\Nexecutions of the same function,
Dialogue: 0,0:21:29.32,0:21:32.20,Default,,0,0,0,,they don't all look like\Nthe most costly one
Dialogue: 0,0:21:32.20,0:21:34.96,Default,,0,0,0,,and instead look like say\Nthe average one.
Dialogue: 0,0:21:34.96,0:21:38.00,Default,,0,0,0,,And the approach to amortized\Nanalysis that we take in the paper,
Dialogue: 0,0:21:38.48,0:21:41.60,Default,,0,0,0,,which is usually called the bankers\Nmethod is to maintain
Dialogue: 0,0:21:41.60,0:21:45.28,Default,,0,0,0,,an invariant, the imaginary credits\Non the nodes of a data structure.
Dialogue: 0,0:21:45.28,0:21:48.24,Default,,0,0,0,,So, these credits\Nincur costs to create,
Dialogue: 0,0:21:48.24,0:21:50.84,Default,,0,0,0,,but then you can spend\Nthem to decrease cost.
Dialogue: 0,0:21:50.84,0:21:53.04,Default,,0,0,0,,And by passing these credits\Naround the program,
Dialogue: 0,0:21:53.04,0:21:54.68,Default,,0,0,0,,you can rearrange costs.
Dialogue: 0,0:21:55.32,0:21:57.72,Default,,0,0,0,,The credit invariant for\Nthe binary counter is that
Dialogue: 0,0:21:57.72,0:22:01.76,Default,,0,0,0,,we keep one credit on each\Ncons cell, which holds a one bit.
Dialogue: 0,0:22:02.24,0:22:04.40,Default,,0,0,0,,So, here's an example to\Nillustrate how this works.
Dialogue: 0,0:22:04.40,0:22:06.48,Default,,0,0,0,,We start with an empty count\Nwith no credits.
Dialogue: 0,0:22:06.48,0:22:08.80,Default,,0,0,0,,And then the first increment\Nflips the first bit
Dialogue: 0,0:22:08.80,0:22:11.88,Default,,0,0,0,,and we spawn a credit to put on the\None, total amortized cost here
Dialogue: 0,0:22:11.88,0:22:15.64,Default,,0,0,0,,is one cons plus one created\Ncredit equals two amortized cost.
Dialogue: 0,0:22:15.64,0:22:18.88,Default,,0,0,0,,And then the next call to\Nincrement flips the first bit
Dialogue: 0,0:22:18.88,0:22:21.12,Default,,0,0,0,,from one to zero and the\Nsecond bit from zero to one.
Dialogue: 0,0:22:21.12,0:22:23.68,Default,,0,0,0,,And then to reestablish the credit\Ninvariant we spawn a credit
Dialogue: 0,0:22:23.68,0:22:26.08,Default,,0,0,0,,to put on the new one bit,\Nwhich incurs a cost of one
Dialogue: 0,0:22:26.08,0:22:29.04,Default,,0,0,0,,but then that's canceled out by\Nspending the credit which used
Dialogue: 0,0:22:29.04,0:22:32.44,Default,,0,0,0,,to be on the least significant bit.\NAgain total two amortized costs.
Dialogue: 0,0:22:33.48,0:22:36.20,Default,,0,0,0,,This is the essence of the analysis\Nand you can convince yourself
Dialogue: 0,0:22:36.20,0:22:40.00,Default,,0,0,0,,that in every case, the amortized\Ncost of increment is two.
Dialogue: 0,0:22:40.00,0:22:43.92,Default,,0,0,0,,So, in order to do this kind of\Nanalysis by recurrence extraction,
Dialogue: 0,0:22:43.92,0:22:46.04,Default,,0,0,0,,we need to make\Nthese credit policies
Dialogue: 0,0:22:46.04,0:22:48.48,Default,,0,0,0,,expressible in the\Nsource language.
Dialogue: 0,0:22:48.48,0:22:50.92,Default,,0,0,0,,So, to that end, we extend\Nour source language
Dialogue: 0,0:22:50.92,0:22:53.64,Default,,0,0,0,,with credits to make a language\Nthat we called lambda A.
Dialogue: 0,0:22:54.28,0:22:57.52,Default,,0,0,0,,So, lambda A internalizes\Neverything you need to
Dialogue: 0,0:22:57.52,0:22:59.84,Default,,0,0,0,,express credit invariants\Nin your code,
Dialogue: 0,0:22:59.84,0:23:01.68,Default,,0,0,0,,and it comes in\Nthree main parts.
Dialogue: 0,0:23:01.68,0:23:03.84,Default,,0,0,0,,So, first we need\Nto be able to track
Dialogue: 0,0:23:03.84,0:23:05.80,Default,,0,0,0,,the credits using\Nthe type system.
Dialogue: 0,0:23:05.80,0:23:09.48,Default,,0,0,0,,So, this new typing judgment\Nsays that m is a term of Type A
Dialogue: 0,0:23:09.48,0:23:12.76,Default,,0,0,0,,and context gamma, which\Ncan use up to C credits.
Dialogue: 0,0:23:12.76,0:23:15.52,Default,,0,0,0,,Now, since we don't want\Ncredits to be duplicated
Dialogue: 0,0:23:15.52,0:23:18.52,Default,,0,0,0,,and then the same credit\Nspent twice, the type system
Dialogue: 0,0:23:18.52,0:23:22.28,Default,,0,0,0,,is Affine which means that variables\Ncan be used at most once.
Dialogue: 0,0:23:22.28,0:23:25.68,Default,,0,0,0,,So, next we need to be able\Nto attach these credits
Dialogue: 0,0:23:25.68,0:23:28.04,Default,,0,0,0,,to terms like say\Nthe elements of a list.
Dialogue: 0,0:23:28.04,0:23:31.20,Default,,0,0,0,,And to do this we add a\Nmodality to the language.
Dialogue: 0,0:23:31.20,0:23:35.48,Default,,0,0,0,,The terms of type bang, cA,\Nare morally terms of Type A
Dialogue: 0,0:23:35.48,0:23:37.76,Default,,0,0,0,,that carry c extra credits.
Dialogue: 0,0:23:37.76,0:23:40.44,Default,,0,0,0,,And the intro/elim rules\Nfor this modality
Dialogue: 0,0:23:40.44,0:23:41.72,Default,,0,0,0,,are actually pretty intuitive.
Dialogue: 0,0:23:41.72,0:23:44.64,Default,,0,0,0,,The intro rule says that\Nwe have a term m of Type A
Dialogue: 0,0:23:44.64,0:23:46.80,Default,,0,0,0,,and we have C Extra\NCredits lying around,
Dialogue: 0,0:23:46.80,0:23:50.44,Default,,0,0,0,,and we don't need to construct,\Nthat we don't need to construct m,
Dialogue: 0,0:23:50.44,0:23:54.32,Default,,0,0,0,,we can just attach them to M\Nand get a term type bang cA.
Dialogue: 0,0:23:54.32,0:23:57.60,Default,,0,0,0,,And the elim rule says that if\Nwe have a term of type bang cA,
Dialogue: 0,0:23:57.60,0:24:00.24,Default,,0,0,0,,we can peel the credits off\Nthe term and allow them
Dialogue: 0,0:24:00.24,0:24:04.32,Default,,0,0,0,,and the value to be used in\Na continuation to make more stuff.
Dialogue: 0,0:24:04.32,0:24:07.24,Default,,0,0,0,,So, finally, we need the ability\Nto create and spend credits,
Dialogue: 0,0:24:07.24,0:24:10.56,Default,,0,0,0,,of course, and the create rule\Nhere says that if we have a term
Dialogue: 0,0:24:10.56,0:24:13.88,Default,,0,0,0,,which uses a plus c credits,\Nwe can simply create C of them
Dialogue: 0,0:24:13.88,0:24:17.60,Default,,0,0,0,,and duly the spend rule says\Nthat if we have A plus c credits,
Dialogue: 0,0:24:17.60,0:24:19.88,Default,,0,0,0,,we can spend c of them\Nand then use a term
Dialogue: 0,0:24:19.88,0:24:21.52,Default,,0,0,0,,which only requires\NA credits.
Dialogue: 0,0:24:21.52,0:24:25.00,Default,,0,0,0,,Now, all of these changes I just\Ndescribed are completely local
Dialogue: 0,0:24:25.00,0:24:27.80,Default,,0,0,0,,to lambda A. We don't change\Nthe recurrence language at all,
Dialogue: 0,0:24:27.80,0:24:30.68,Default,,0,0,0,,it's still fully structural\Nand has no modality.
Dialogue: 0,0:24:30.68,0:24:33.40,Default,,0,0,0,,So, we've extended the source\Nlanguage with the features
Dialogue: 0,0:24:33.40,0:24:36.88,Default,,0,0,0,,that let us formally specify these\Ncredit invariants in our code.
Dialogue: 0,0:24:36.88,0:24:39.12,Default,,0,0,0,,Now let's take a look at how\Nthe binary counter example
Dialogue: 0,0:24:39.12,0:24:41.24,Default,,0,0,0,,would actually get\Nencoded into this language.
Dialogue: 0,0:24:42.00,0:24:46.60,Default,,0,0,0,,So, in lambda a, we redefine the\Nbit type to be unit plus bang one
Dialogue: 0,0:24:46.60,0:24:50.04,Default,,0,0,0,,unit, a bit is either in-left of\Na unit which represents a zero,
Dialogue: 0,0:24:50.04,0:24:52.56,Default,,0,0,0,,or in-right of a unit\Nwith one credit attached,
Dialogue: 0,0:24:52.56,0:24:55.44,Default,,0,0,0,,which represents one. And\Nthen the code for increment
Dialogue: 0,0:24:55.44,0:24:57.20,Default,,0,0,0,,is the exact same\Nbehavior as before,
Dialogue: 0,0:24:57.20,0:25:01.04,Default,,0,0,0,,it just maintains the credit policy.\NIf the list is empty or has zeros,
Dialogue: 0,0:25:01.04,0:25:03.80,Default,,0,0,0,,in the least significant bit,\Nwe create a credit and make
Dialogue: 0,0:25:03.80,0:25:06.44,Default,,0,0,0,,a one bit value by attaching\Nthat credit to a unit value
Dialogue: 0,0:25:06.44,0:25:09.24,Default,,0,0,0,,and then returning that\Nas the least significant bit.
Dialogue: 0,0:25:09.24,0:25:11.48,Default,,0,0,0,,And it's the least significant bit\Nas one, we detach
Dialogue: 0,0:25:11.48,0:25:15.20,Default,,0,0,0,,the credit using transfer, spend it\Nand then make a recursive call
Dialogue: 0,0:25:15.20,0:25:17.44,Default,,0,0,0,,on the tail and cons as zero\None to the result.
Dialogue: 0,0:25:17.44,0:25:21.08,Default,,0,0,0,,So, all good lambda A can\Nexpress the credit policy
Dialogue: 0,0:25:21.08,0:25:22.80,Default,,0,0,0,,that we were looking for,\Nbut now we need
Dialogue: 0,0:25:22.80,0:25:24.88,Default,,0,0,0,,to actually extract\Nrecurrences from it.
Dialogue: 0,0:25:26.04,0:25:28.80,Default,,0,0,0,,But the recurrence extraction for\Nlambda A is actually quite simple.
Dialogue: 0,0:25:28.80,0:25:31.40,Default,,0,0,0,,So, let's briefly recall that\Nthe recurrence extraction
Dialogue: 0,0:25:31.40,0:25:35.00,Default,,0,0,0,,from a term consists of a pair\Nof the cost to compute
Dialogue: 0,0:25:35.00,0:25:36.64,Default,,0,0,0,,the term along with its size.
Dialogue: 0,0:25:36.64,0:25:40.16,Default,,0,0,0,,So, since creating A credits\Nincurs a cost of A
Dialogue: 0,0:25:40.16,0:25:44.00,Default,,0,0,0,,just add A to the extracted cost\Nand dually we subtract A
Dialogue: 0,0:25:44.00,0:25:45.72,Default,,0,0,0,,from the cost\Ncomponent when we spent.
Dialogue: 0,0:25:46.24,0:25:49.96,Default,,0,0,0,,Now, since the credits as\NI mentioned earlier aren't present
Dialogue: 0,0:25:49.96,0:25:52.68,Default,,0,0,0,,in the recurrence language,\Nthe extraction has to erase
Dialogue: 0,0:25:52.68,0:25:54.72,Default,,0,0,0,,the modality and its\Ncorresponding form.
Dialogue: 0,0:25:54.72,0:25:58.36,Default,,0,0,0,,So, save gets erased completely and\Ntransfer gets turned into a let.
Dialogue: 0,0:25:59.44,0:26:01.92,Default,,0,0,0,,All good. So, now that we have\Nthe recurrence extraction
Dialogue: 0,0:26:01.92,0:26:05.40,Default,,0,0,0,,in place for lambda a,\Nlet's extract terms recurrences
Dialogue: 0,0:26:05.40,0:26:07.96,Default,,0,0,0,,for the binary counter,\Nsolve them and hopefully
Dialogue: 0,0:26:07.96,0:26:09.60,Default,,0,0,0,,get the tight boundary\Nwe're looking for.
Dialogue: 0,0:26:10.32,0:26:13.40,Default,,0,0,0,,So, above line here is the term\Nfor inc that we wrote earlier
Dialogue: 0,0:26:13.40,0:26:15.96,Default,,0,0,0,,and below I've written the cost\Ncomponent of the recurrence
Dialogue: 0,0:26:15.96,0:26:18.40,Default,,0,0,0,,you get in lambda C\Nfor this term.
Dialogue: 0,0:26:18.40,0:26:20.76,Default,,0,0,0,,So, when the argument to\Nthis recurrence is empty,
Dialogue: 0,0:26:20.76,0:26:22.80,Default,,0,0,0,,or has zero is the least\Nsignificant bit,
Dialogue: 0,0:26:22.80,0:26:26.24,Default,,0,0,0,,increment costs two, one from\Nthe cons one from creating credit
Dialogue: 0,0:26:26.24,0:26:29.68,Default,,0,0,0,,When is the least significant bit\None, the cost we extract is simply
Dialogue: 0,0:26:29.68,0:26:31.76,Default,,0,0,0,,the cost of the\Nrecursive call.
Dialogue: 0,0:26:31.76,0:26:34.60,Default,,0,0,0,,Now, why is this?\NWell, we do one cons operation
Dialogue: 0,0:26:34.60,0:26:37.00,Default,,0,0,0,,which costs one and\Nthen we spend a credit
Dialogue: 0,0:26:37.00,0:26:39.64,Default,,0,0,0,,from the least significant bit,\Nwhich subtracts one.
Dialogue: 0,0:26:39.64,0:26:42.92,Default,,0,0,0,,So, we're just left with the cost\Nof the recursive call down the tail.
Dialogue: 0,0:26:42.92,0:26:46.00,Default,,0,0,0,,It's super easy to see that this\Nfunction is two everywhere.
Dialogue: 0,0:26:46.00,0:26:48.68,Default,,0,0,0,,And indeed the monotone map\Nof posets that it denotes
Dialogue: 0,0:26:48.68,0:26:51.00,Default,,0,0,0,,is in fact the constant\Nfunction two.
Dialogue: 0,0:26:51.00,0:26:53.04,Default,,0,0,0,,So, carrying this\Nall through for set,
Dialogue: 0,0:26:53.04,0:26:55.88,Default,,0,0,0,,we get to the corresponding\Nmathematical recurrence
Dialogue: 0,0:26:55.88,0:27:00.64,Default,,0,0,0,,is order n as desired. So we have\Na recurrence extraction procedure
Dialogue: 0,0:27:00.64,0:27:03.20,Default,,0,0,0,,that extracts tight bounds\Nfor amortized analyses.
Dialogue: 0,0:27:03.20,0:27:05.60,Default,,0,0,0,,And the final step here\Nis to prove a theorem
Dialogue: 0,0:27:05.60,0:27:07.36,Default,,0,0,0,,like the bounding theorem\Nfor prior work
Dialogue: 0,0:27:07.36,0:27:10.36,Default,,0,0,0,,which connects these recurrences\Nto the operational semantics.
Dialogue: 0,0:27:10.88,0:27:13.12,Default,,0,0,0,,And similar to how we\Ndid it in prior work.
Dialogue: 0,0:27:13.12,0:27:16.56,Default,,0,0,0,,We first define a big step\Noperational semantics for lambda a,
Dialogue: 0,0:27:16.56,0:27:20.08,Default,,0,0,0,,but this time indexed by amortized\Ncost. So, this judgment reads
Dialogue: 0,0:27:20.08,0:27:24.16,Default,,0,0,0,,that M evaluates to V\Nwith an amortized cost.
Dialogue: 0,0:27:24.16,0:27:27.00,Default,,0,0,0,,Then we use a logical relation to\Nprove the same bounding theorem
Dialogue: 0,0:27:27.00,0:27:30.64,Default,,0,0,0,,as before but this time the cost\Nper bounding is an amortized cost.
Dialogue: 0,0:27:31.20,0:27:33.16,Default,,0,0,0,,But the crucial consequence\Nof this theorem
Dialogue: 0,0:27:33.16,0:27:36.36,Default,,0,0,0,,is that for closed terms, the\Namortized cost that we get
Dialogue: 0,0:27:36.36,0:27:39.92,Default,,0,0,0,,for the recurrence is a bound on\Nthe actual execution cost.
Dialogue: 0,0:27:39.92,0:27:42.80,Default,,0,0,0,,And so for example, the set\Nprogram isn't just linear
Dialogue: 0,0:27:42.80,0:27:45.40,Default,,0,0,0,,in this strange cost metric\Nwhere we can subtract
Dialogue: 0,0:27:45.40,0:27:46.84,Default,,0,0,0,,and add arbitrary costs.
Dialogue: 0,0:27:46.84,0:27:50.00,Default,,0,0,0,,It actually does a linear amount\Nof cons operations.
Dialogue: 0,0:27:50.52,0:27:52.64,Default,,0,0,0,,So, in summary,\Nwe formalize the process
Dialogue: 0,0:27:52.64,0:27:55.48,Default,,0,0,0,,of doing amortized analysis\Nby recurrence extraction.
Dialogue: 0,0:27:55.48,0:27:57.60,Default,,0,0,0,,Given an amortized analysis\Nof a data structure
Dialogue: 0,0:27:57.60,0:28:00.76,Default,,0,0,0,,such as a binary counter\Nor splay tree written in lambda a,
Dialogue: 0,0:28:00.76,0:28:04.52,Default,,0,0,0,,we can automatically extract\Ncorrect recurrences into lambda c.
Dialogue: 0,0:28:04.52,0:28:06.88,Default,,0,0,0,,This extraction procedure\Nhas been proven correct
Dialogue: 0,0:28:06.88,0:28:08.44,Default,,0,0,0,,and is expressive\Nenough to handle
Dialogue: 0,0:28:08.44,0:28:11.04,Default,,0,0,0,,non trivial analyses\Nlike splay trees.
Dialogue: 0,0:28:11.04,0:28:12.32,Default,,0,0,0,,Thank you very much.
Dialogue: 0,0:28:12.84,0:28:20.96,Default,,0,0,0,,AUDIENCE: Applause
Dialogue: 0,0:28:20.96,0:28:22.36,Default,,0,0,0,,RICHARD: Thanks, Joe.
Dialogue: 0,0:28:22.36,0:28:26.44,Default,,0,0,0,,Now in both the New York\Nand Asia time bands.
Dialogue: 0,0:28:26.44,0:28:30.48,Default,,0,0,0,,You should be able to click a\Nlink in the sidebar in Clowdr
Dialogue: 0,0:28:30.48,0:28:32.76,Default,,0,0,0,,to be able to access\Nthe Q&A sessions.
Dialogue: 0,0:28:38.60,0:28:42.92,Default,,0,0,0,,OK, our next talk is featuring\NArthur Chargueraud
Dialogue: 0,0:28:42.92,0:28:46.08,Default,,0,0,0,,about separation logic for\Nsequential programs.
Dialogue: 0,0:28:49.04,0:28:50.08,Default,,0,0,0,,ARTHUR CHARGUERAUD: Separation logic
Dialogue: 0,0:28:50.08,0:28:52.12,Default,,0,0,0,,was introduced in\Nthe early 2000s.
Dialogue: 0,0:28:52.12,0:28:55.76,Default,,0,0,0,,Since then, it has had tremendous\Nsuccess at program verification.
Dialogue: 0,0:28:56.88,0:29:00.40,Default,,0,0,0,,I believe that today, the ideas\Nof separation logic deserve
Dialogue: 0,0:29:00.40,0:29:02.24,Default,,0,0,0,,to be taught much more widely.
Dialogue: 0,0:29:03.76,0:29:06.68,Default,,0,0,0,,For this reason, I've been working\Non a course on separation logic.
Dialogue: 0,0:29:08.16,0:29:10.68,Default,,0,0,0,,The course focuses on\Nsequential programs.
Dialogue: 0,0:29:10.68,0:29:12.48,Default,,0,0,0,,Concurrency is interesting\Nbut it's much harder.
Dialogue: 0,0:29:13.52,0:29:17.52,Default,,0,0,0,,Course is written in the style of\Nthe Software Foundations series,
Dialogue: 0,0:29:17.52,0:29:19.76,Default,,0,0,0,,where every definition\Nevery lemma,
Dialogue: 0,0:29:19.76,0:29:23.20,Default,,0,0,0,,and every exercise is formalized\Nusing the Coq proof assistant.
Dialogue: 0,0:29:24.80,0:29:27.72,Default,,0,0,0,,The course covers modern\Nfeatures of Separation logic.
Dialogue: 0,0:29:27.72,0:29:30.60,Default,,0,0,0,,These are features that will not\Npresent in the original papers
Dialogue: 0,0:29:30.60,0:29:34.00,Default,,0,0,0,,in separation logic, but have\Nsince then proved very useful
Dialogue: 0,0:29:34.00,0:29:38.40,Default,,0,0,0,,for developing practical tools.\NThe third contribution of this paper
Dialogue: 0,0:29:38.40,0:29:40.40,Default,,0,0,0,,is an extensive\Nrelated work section,
Dialogue: 0,0:29:40.88,0:29:44.20,Default,,0,0,0,,which I believe nicely completes\N'Peter O'Hearn's' survey,
Dialogue: 0,0:29:44.20,0:29:47.28,Default,,0,0,0,,which was published last year\Nby focusing specifically
Dialogue: 0,0:29:47.28,0:29:51.96,Default,,0,0,0,,on the contributions to make a nice\Npresentations of separation logic.
Dialogue: 0,0:29:54.00,0:29:55.92,Default,,0,0,0,,The course is organized\Nin 10 chapters.
Dialogue: 0,0:29:56.40,0:29:58.12,Default,,0,0,0,,So, the first three\Nchapters focus on
Dialogue: 0,0:29:58.12,0:30:00.16,Default,,0,0,0,,basic features of\Nseparation logic,
Dialogue: 0,0:30:00.16,0:30:03.32,Default,,0,0,0,,such as heap predicates,\Ntriples, entailment.
Dialogue: 0,0:30:04.72,0:30:05.84,Default,,0,0,0,,The next few chapters focus
Dialogue: 0,0:30:05.84,0:30:07.88,Default,,0,0,0,,on the presentation\Nof reasoning rules,
Dialogue: 0,0:30:07.88,0:30:11.04,Default,,0,0,0,,either in the form of triples in the\Nform of weakest preconditions,
Dialogue: 0,0:30:11.04,0:30:13.40,Default,,0,0,0,,or in the form of\Ncharacteristic formulae,
Dialogue: 0,0:30:13.40,0:30:15.80,Default,,0,0,0,,which are a form of weakest\Nprecondition generator.
Dialogue: 0,0:30:16.76,0:30:19.68,Default,,0,0,0,,The remaining chapters focus\Non more advanced features
Dialogue: 0,0:30:19.68,0:30:22.84,Default,,0,0,0,,such as a magic wand,\Nthe treatment of affine predicates,
Dialogue: 0,0:30:22.84,0:30:27.24,Default,,0,0,0,,and language extensions,\Nsuch as records, arrays
Dialogue: 0,0:30:27.24,0:30:29.80,Default,,0,0,0,,loops or n-ary functions.
Dialogue: 0,0:30:29.80,0:30:32.16,Default,,0,0,0,,Let me take a few minutes\Nto explain how the course
Dialogue: 0,0:30:32.16,0:30:33.64,Default,,0,0,0,,is set up at a\Nvery high level.
Dialogue: 0,0:30:35.60,0:30:38.84,Default,,0,0,0,,Traditional courses on separation\Nlogic consider while loop language.
Dialogue: 0,0:30:40.16,0:30:42.68,Default,,0,0,0,,I consider instead like other\Ncolleagues before me
Dialogue: 0,0:30:42.68,0:30:44.12,Default,,0,0,0,,an imperative\Nlambda calculus.
Dialogue: 0,0:30:45.20,0:30:47.76,Default,,0,0,0,,This choice leads to\Nmajor simplification.
Dialogue: 0,0:30:47.76,0:30:50.16,Default,,0,0,0,,The fact that there are\Nno mutable variables lead
Dialogue: 0,0:30:50.16,0:30:52.00,Default,,0,0,0,,to an elegant statement\Nof the frame rule
Dialogue: 0,0:30:52.00,0:30:53.24,Default,,0,0,0,,without any side-condition.
Dialogue: 0,0:30:54.60,0:30:57.48,Default,,0,0,0,,At the same time, using\Nlambda calculus means
Dialogue: 0,0:30:57.48,0:30:59.08,Default,,0,0,0,,that every term\Nproduces a value
Dialogue: 0,0:30:59.08,0:31:01.28,Default,,0,0,0,,and this leads to a\Nminor complication.
Dialogue: 0,0:31:01.84,0:31:04.00,Default,,0,0,0,,The fact that post conditions\Nneed to describe
Dialogue: 0,0:31:04.00,0:31:06.16,Default,,0,0,0,,not just an output state\Nbut also an output value.
Dialogue: 0,0:31:07.48,0:31:11.00,Default,,0,0,0,,Quickly, where preconditions\Nare the type of heap to prop
Dialogue: 0,0:31:11.48,0:31:14.60,Default,,0,0,0,,post conditions of\Ntype value to heap to prop.
Dialogue: 0,0:31:15.76,0:31:19.64,Default,,0,0,0,,These set of operators such as the\Nstar, the magic wand or entailment,
Dialogue: 0,0:31:19.64,0:31:23.64,Default,,0,0,0,,this needs to be extended to a form\Nthat operates on post condition.
Dialogue: 0,0:31:25.16,0:31:28.88,Default,,0,0,0,,These are marked with a little\Ndot symbol below the operator.
Dialogue: 0,0:31:31.72,0:31:37.08,Default,,0,0,0,,The semantics is described in the\Nstandard way as a call by value,
Dialogue: 0,0:31:37.08,0:31:39.68,Default,,0,0,0,,substitution based,\Nbig step style semantics.
Dialogue: 0,0:31:40.60,0:31:43.08,Default,,0,0,0,,The choice of a big step semantics\Nis well suited for reasoning
Dialogue: 0,0:31:43.08,0:31:45.68,Default,,0,0,0,,about total correctness\Nof sequential programs.
Dialogue: 0,0:31:45.68,0:31:47.04,Default,,0,0,0,,It makes the proof simpler.
Dialogue: 0,0:31:47.84,0:31:50.36,Default,,0,0,0,,Both the syntax and\Nthe semantics are described
Dialogue: 0,0:31:50.36,0:31:53.24,Default,,0,0,0,,in standard ways following\Nthe style of the presentation
Dialogue: 0,0:31:53.24,0:31:55.40,Default,,0,0,0,,of the prior Software\NFoundation volumes,
Dialogue: 0,0:31:55.40,0:31:57.44,Default,,0,0,0,,which will make it easy\Nfor students to follow.
Dialogue: 0,0:32:00.04,0:32:02.24,Default,,0,0,0,,Separation logic is presented\Nin a shallow embedding.
Dialogue: 0,0:32:03.48,0:32:06.76,Default,,0,0,0,,This means that the core heap\Npredicates of separation logic
Dialogue: 0,0:32:06.76,0:32:11.32,Default,,0,0,0,,are defined as Coq functions\Nfrom heap to propositions.
Dialogue: 0,0:32:13.16,0:32:15.24,Default,,0,0,0,,Entailment is defined\Nin the standard way
Dialogue: 0,0:32:15.24,0:32:18.40,Default,,0,0,0,,as simplest possible way\Nas pointwise entailment.
Dialogue: 0,0:32:19.52,0:32:23.04,Default,,0,0,0,,The remaining operators\Nare encoded in terms of
Dialogue: 0,0:32:23.04,0:32:26.36,Default,,0,0,0,,these core operators.\NFor the details
Dialogue: 0,0:32:26.36,0:32:27.84,Default,,0,0,0,,I'll just refer\Nto the course.
Dialogue: 0,0:32:30.64,0:32:35.76,Default,,0,0,0,,Triples are defined in two stage.\NFirst, the hoarse Triple H t Q
Dialogue: 0,0:32:35.76,0:32:39.40,Default,,0,0,0,,asserts that for any state as\Nsatisfying the precondition,
Dialogue: 0,0:32:39.40,0:32:42.68,Default,,0,0,0,,the term t terminates on a value V\Nand an open state S prime
Dialogue: 0,0:32:42.68,0:32:45.56,Default,,0,0,0,,that together satisfy\Nthe post condition Q.
Dialogue: 0,0:32:47.08,0:32:50.16,Default,,0,0,0,,A separation logic\NTriple H t Q is defined
Dialogue: 0,0:32:50.16,0:32:52.64,Default,,0,0,0,,by quantifying universally\Non a predicate H prime
Dialogue: 0,0:32:53.48,0:32:56.24,Default,,0,0,0,,that describes\Nthe rest of the world.
Dialogue: 0,0:32:56.24,0:33:00.08,Default,,0,0,0,,And asserting that the triple\Nmade of H stop H prime
Dialogue: 0,0:33:00.08,0:33:05.24,Default,,0,0,0,,and Q-Star Q H prime makes\Nup a valid or triple.
Dialogue: 0,0:33:05.24,0:33:07.72,Default,,0,0,0,,The standard technique of\Nbaking in the frame rule
Dialogue: 0,0:33:07.72,0:33:10.04,Default,,0,0,0,,leads to simple proofs\Nfor the structural rules,
Dialogue: 0,0:33:10.04,0:33:15.48,Default,,0,0,0,,such as a frame rule\Nor the consequence rule.
Dialogue: 0,0:33:15.48,0:33:16.76,Default,,0,0,0,,I'd like to take\Nthe rest of the talk
Dialogue: 0,0:33:16.76,0:33:21.40,Default,,0,0,0,,to present four features of\Nmodern separation logic,
Dialogue: 0,0:33:21.40,0:33:24.24,Default,,0,0,0,,which I believe should\Nbe to interest
Dialogue: 0,0:33:24.24,0:33:28.00,Default,,0,0,0,,to every ICFP researcher.
Dialogue: 0,0:33:28.00,0:33:30.84,Default,,0,0,0,,Let me begin with\Na ramified frame rule.
Dialogue: 0,0:33:30.84,0:33:33.24,Default,,0,0,0,,The frame rule in its\Nmost standard statement
Dialogue: 0,0:33:33.24,0:33:34.92,Default,,0,0,0,,is almost never applicable.
Dialogue: 0,0:33:34.92,0:33:37.20,Default,,0,0,0,,Indeed, you need both\Nthe precondition
Dialogue: 0,0:33:37.20,0:33:44.28,Default,,0,0,0,,and the post-condition to\Nsyntactically feature a star H2.
Dialogue: 0,0:33:44.28,0:33:48.24,Default,,0,0,0,,But in practice, one would\Ntypically use a combined rule
Dialogue: 0,0:33:48.24,0:33:51.24,Default,,0,0,0,,that integrates\Nthe rule of consequence,
Dialogue: 0,0:33:51.24,0:33:55.48,Default,,0,0,0,,and is stated as follows;\Nto prove this triple H T Q
Dialogue: 0,0:33:55.48,0:33:58.40,Default,,0,0,0,,derivable from a triple H1 T Q1.
Dialogue: 0,0:33:58.40,0:34:01.64,Default,,0,0,0,,One has to show that\Nthe precondition H
Dialogue: 0,0:34:01.64,0:34:06.48,Default,,0,0,0,,decomposes as H1 star H2,
Dialogue: 0,0:34:06.48,0:34:08.48,Default,,0,0,0,,and then show that\Nthe post-condition Q1
Dialogue: 0,0:34:08.48,0:34:13.48,Default,,0,0,0,,when extended with H2 recovers\Nthe post-condition Q.
Dialogue: 0,0:34:13.48,0:34:18.48,Default,,0,0,0,,H2 can be computed as\Na difference between H and H1.
Dialogue: 0,0:34:18.48,0:34:21.04,Default,,0,0,0,,Computing this difference\Ncan be well automated
Dialogue: 0,0:34:21.04,0:34:24.72,Default,,0,0,0,,in a simple case, but\Nif H contains existentially
Dialogue: 0,0:34:24.72,0:34:27.08,Default,,0,0,0,,quantified variables,\Nit can be quite tricky
Dialogue: 0,0:34:27.08,0:34:29.16,Default,,0,0,0,,to figure out whether these\Ncorresponding variables
Dialogue: 0,0:34:29.16,0:34:33.24,Default,,0,0,0,,should get quantified\Nin H1 or in H2.
Dialogue: 0,0:34:33.24,0:34:36.92,Default,,0,0,0,,The ramified frame rule avoid\Nthis problem altogether
Dialogue: 0,0:34:36.92,0:34:40.20,Default,,0,0,0,,by removing the need to\Nintroduce H2 in the first place.
Dialogue: 0,0:34:40.20,0:34:44.08,Default,,0,0,0,,It reformulates the premises\Nas a single entailment.
Dialogue: 0,0:34:44.08,0:34:47.44,Default,,0,0,0,,H entails H1 star.
Dialogue: 0,0:34:47.44,0:34:49.44,Default,,0,0,0,,Some predicates, such that
Dialogue: 0,0:34:49.44,0:34:53.40,Default,,0,0,0,,when augmenting Q1\Nwith it, we obtain Q.
Dialogue: 0,0:34:53.40,0:34:55.88,Default,,0,0,0,,The operator at play\Nhere is the magic wand
Dialogue: 0,0:34:55.88,0:34:58.64,Default,,0,0,0,,for post-condition.
Dialogue: 0,0:34:58.64,0:35:00.80,Default,,0,0,0,,Without going into further\Ndetail, let me just point out
Dialogue: 0,0:35:00.80,0:35:04.96,Default,,0,0,0,,that the ramified frame rule\Nhas proved very practical
Dialogue: 0,0:35:04.96,0:35:10.32,Default,,0,0,0,,for developing practical tools.
Dialogue: 0,0:35:10.32,0:35:12.12,Default,,0,0,0,,The second point I'd\Nlike to focus on is;
Dialogue: 0,0:35:12.12,0:35:13.88,Default,,0,0,0,,the weakest preconditioned\Npresentation
Dialogue: 0,0:35:13.88,0:35:15.72,Default,,0,0,0,,of separation logic.
Dialogue: 0,0:35:15.72,0:35:17.32,Default,,0,0,0,,Just like in our logic,\Nweakest precondition
Dialogue: 0,0:35:17.32,0:35:20.08,Default,,0,0,0,,is a key ingredient, but what\Nis the definition of WP
Dialogue: 0,0:35:20.08,0:35:21.16,Default,,0,0,0,,in separation logic?
Dialogue: 0,0:35:21.16,0:35:22.72,Default,,0,0,0,,And what is a statement\Nof a frame rule
Dialogue: 0,0:35:22.72,0:35:26.00,Default,,0,0,0,,in weakest precondition style?
Dialogue: 0,0:35:26.00,0:35:28.76,Default,,0,0,0,,So WP, just like in our\Nlogic, can be defined
Dialogue: 0,0:35:28.76,0:35:32.28,Default,,0,0,0,,as an equivalence\Nbetween a triple H D Q
Dialogue: 0,0:35:32.28,0:35:37.04,Default,,0,0,0,,and the entailment from H to WP T Q.
Dialogue: 0,0:35:37.04,0:35:39.76,Default,,0,0,0,,This equivalence is not\Nquite a definition.
Dialogue: 0,0:35:39.76,0:35:44.68,Default,,0,0,0,,The two definitions that\Ncan be considered;
Dialogue: 0,0:35:44.68,0:35:48.56,Default,,0,0,0,,one is a low level definition\Nworking in terms of heaps.
Dialogue: 0,0:35:48.56,0:35:51.84,Default,,0,0,0,,Another one is based on an encoding
Dialogue: 0,0:35:51.84,0:35:57.40,Default,,0,0,0,,using the operators\Nof separation logic.
Dialogue: 0,0:35:57.40,0:36:01.92,Default,,0,0,0,,The weakest precondition frame\Nrule can be read as follows;
Dialogue: 0,0:36:01.92,0:36:05.64,Default,,0,0,0,,if I own a resource state\Nin which I can execute
Dialogue: 0,0:36:05.64,0:36:10.28,Default,,0,0,0,,the term T and obtain\Nthe post-condition Q
Dialogue: 0,0:36:10.28,0:36:14.20,Default,,0,0,0,,and separately, I own a piece\Nof state described by H.
Dialogue: 0,0:36:14.20,0:36:17.68,Default,,0,0,0,,Then altogether,\NI own a piece of state
Dialogue: 0,0:36:17.68,0:36:19.40,Default,,0,0,0,,in which the execution\Nof T terminates
Dialogue: 0,0:36:19.40,0:36:21.96,Default,,0,0,0,,and produces\Na post-condition described
Dialogue: 0,0:36:21.96,0:36:26.04,Default,,0,0,0,,by Q extended with H.
Dialogue: 0,0:36:26.04,0:36:28.88,Default,,0,0,0,,Interestingly, the weakest\Nprecondition frame rule
Dialogue: 0,0:36:28.88,0:36:32.28,Default,,0,0,0,,can be combined with the ideas\Nof the ramified frame rule,
Dialogue: 0,0:36:32.28,0:36:35.44,Default,,0,0,0,,leading to the rule shown at\Nthe bottom of the slide here.
Dialogue: 0,0:36:35.44,0:36:38.32,Default,,0,0,0,,This rule subsumes all\Nthe structural rules
Dialogue: 0,0:36:38.32,0:36:43.12,Default,,0,0,0,,of separation logic.
Dialogue: 0,0:36:43.12,0:36:44.80,Default,,0,0,0,,The third feature is\Nthe mixing of affine
Dialogue: 0,0:36:44.80,0:36:46.72,Default,,0,0,0,,and linear predicates.
Dialogue: 0,0:36:46.72,0:36:50.08,Default,,0,0,0,,A linear predicate describes\Na resource that must remain
Dialogue: 0,0:36:50.08,0:36:53.04,Default,,0,0,0,,accounted for throughout\Nthe reasoning.
Dialogue: 0,0:36:53.04,0:36:54.48,Default,,0,0,0,,It is essential, for example,
Dialogue: 0,0:36:54.48,0:36:57.24,Default,,0,0,0,,to prove that every allocated data
Dialogue: 0,0:36:57.24,0:36:59.44,Default,,0,0,0,,eventually gets deallocated,\Nor every file open
Dialogue: 0,0:36:59.44,0:37:02.36,Default,,0,0,0,,eventually gets closed.
Dialogue: 0,0:37:02.36,0:37:04.40,Default,,0,0,0,,And the affine heap predicate\Non the contrary,
Dialogue: 0,0:37:04.40,0:37:07.04,Default,,0,0,0,,describes a resource that\Nmay be freely discarded
Dialogue: 0,0:37:07.04,0:37:09.16,Default,,0,0,0,,in the reasoning.
Dialogue: 0,0:37:09.16,0:37:14.80,Default,,0,0,0,,Typically,this notion of affine predicate
Dialogue: 0,0:37:14.80,0:37:17.72,Default,,0,0,0,,is a must have for garbage\Ncollected languages,
Dialogue: 0,0:37:17.72,0:37:21.36,Default,,0,0,0,,which do not feature\Nexplicit free operations.
Dialogue: 0,0:37:21.36,0:37:23.36,Default,,0,0,0,,So it is straightforward to set up
Dialogue: 0,0:37:23.36,0:37:26.00,Default,,0,0,0,,a linear separation logic,\Nand it is not much harder
Dialogue: 0,0:37:26.00,0:37:28.56,Default,,0,0,0,,to set up an affine\Nseparation logic,
Dialogue: 0,0:37:28.56,0:37:31.28,Default,,0,0,0,,but what is a simple way to\Nset up a separation logic,
Dialogue: 0,0:37:31.28,0:37:36.88,Default,,0,0,0,,where both linear and affine\Npredicates can coexist?
Dialogue: 0,0:37:36.88,0:37:38.76,Default,,0,0,0,,By describing\Nthe (INAUDIBLE) construction
Dialogue: 0,0:37:38.76,0:37:40.92,Default,,0,0,0,,that is relatively simple,
Dialogue: 0,0:37:40.92,0:37:44.40,Default,,0,0,0,,which relies on\Nthe introduction of a predicate
Dialogue: 0,0:37:44.40,0:37:46.96,Default,,0,0,0,,H affine, that can be\Ncustomized to define
Dialogue: 0,0:37:46.96,0:37:52.32,Default,,0,0,0,,which heaps should be considered\Naffine as opposed to linear.
Dialogue: 0,0:37:52.32,0:37:55.84,Default,,0,0,0,,Top of that can define\Nthe notion of affine predicates
Dialogue: 0,0:37:55.84,0:37:59.40,Default,,0,0,0,,that characterize only\Nheaps that are affine.
Dialogue: 0,0:37:59.40,0:38:03.04,Default,,0,0,0,,And the notion of\Naffine top predicate
Dialogue: 0,0:38:03.04,0:38:08.20,Default,,0,0,0,,which characterizes any affine heap.
Dialogue: 0,0:38:08.20,0:38:10.32,Default,,0,0,0,,The definition of\Nseparation logic triples
Dialogue: 0,0:38:10.32,0:38:14.00,Default,,0,0,0,,can be generalized by\Nintroducing the top,
Dialogue: 0,0:38:14.00,0:38:17.68,Default,,0,0,0,,the affine top predicate\Nin the post-condition.
Dialogue: 0,0:38:17.68,0:38:20.80,Default,,0,0,0,,Doing so preserved\Nthe validity of all the prior
Dialogue: 0,0:38:20.80,0:38:26.24,Default,,0,0,0,,rules of separation logic\Nand adds two additional rules.
Dialogue: 0,0:38:26.24,0:38:28.16,Default,,0,0,0,,The first one asserts that any piece
Dialogue: 0,0:38:28.16,0:38:31.08,Default,,0,0,0,,of precondition H prime\Nmay be discarded
Dialogue: 0,0:38:31.08,0:38:36.08,Default,,0,0,0,,from the precondition\Nprovided that it's affine.
Dialogue: 0,0:38:36.08,0:38:38.24,Default,,0,0,0,,The second rule allows to\Nextend the post-condition
Dialogue: 0,0:38:38.24,0:38:41.40,Default,,0,0,0,,within the affine top predicate\Nreflecting on the fact
Dialogue: 0,0:38:41.40,0:38:45.04,Default,,0,0,0,,that it is fine to\Nproduce a post-condition
Dialogue: 0,0:38:45.04,0:38:51.76,Default,,0,0,0,,that is bigger than the desired one.
Dialogue: 0,0:38:51.76,0:38:54.44,Default,,0,0,0,,Fourth and last feature\NI'd like to describe
Dialogue: 0,0:38:54.44,0:38:58.80,Default,,0,0,0,,is a frame friendly rule\Nfor reasoning about loops.
Dialogue: 0,0:38:58.80,0:39:00.40,Default,,0,0,0,,So consider for\Nexample, an operation
Dialogue: 0,0:39:00.40,0:39:02.48,Default,,0,0,0,,that traverses a linked list,
Dialogue: 0,0:39:02.48,0:39:06.12,Default,,0,0,0,,or traverses a tree data\Nstructure recursively.
Dialogue: 0,0:39:06.12,0:39:10.20,Default,,0,0,0,,If the separation is implemented\Nas a recursive function,
Dialogue: 0,0:39:10.20,0:39:14.00,Default,,0,0,0,,one can invoke the frame rule\Naround the recursive calls
Dialogue: 0,0:39:14.00,0:39:18.24,Default,,0,0,0,,to forget about the cells\Nor the parts of the trees
Dialogue: 0,0:39:18.24,0:39:21.08,Default,,0,0,0,,that are passed by.
Dialogue: 0,0:39:21.08,0:39:23.68,Default,,0,0,0,,On the contrary, if\Nthe operation is implemented
Dialogue: 0,0:39:23.68,0:39:27.12,Default,,0,0,0,,as a loop and specified using\Na loop invariant,
Dialogue: 0,0:39:27.12,0:39:31.96,Default,,0,0,0,,the loop invariant must describe\Nthe list segment
Dialogue: 0,0:39:31.96,0:39:35.36,Default,,0,0,0,,of cells that have already\Nbeen passed by or worse,
Dialogue: 0,0:39:35.36,0:39:38.68,Default,,0,0,0,,in the case of a tree, must\Ndescribe the tree context
Dialogue: 0,0:39:38.68,0:39:43.04,Default,,0,0,0,,associated with the past that\Nhas already been traversed.
Dialogue: 0,0:39:43.04,0:39:45.88,Default,,0,0,0,,The question here is how can\Nwe reason about syntactic
Dialogue: 0,0:39:45.88,0:39:48.64,Default,,0,0,0,,loop construct as easily
Dialogue: 0,0:39:48.64,0:39:52.04,Default,,0,0,0,,as recursive function
Dialogue: 0,0:39:52.04,0:39:56.44,Default,,0,0,0,,that will allow us to\Nexploit the frame rule?
Dialogue: 0,0:39:56.44,0:39:58.56,Default,,0,0,0,,So what we're trying to achieve here
Dialogue: 0,0:39:58.56,0:40:02.68,Default,,0,0,0,,is essentially simulate\Nan encoding of a while loop
Dialogue: 0,0:40:02.68,0:40:05.68,Default,,0,0,0,,as a recursive function,\Nbut without introducing
Dialogue: 0,0:40:05.68,0:40:11.52,Default,,0,0,0,,the overheads of an actual\Nexplicit encoding.
Dialogue: 0,0:40:11.52,0:40:14.04,Default,,0,0,0,,The idea is to specify the while loop
Dialogue: 0,0:40:14.04,0:40:19.20,Default,,0,0,0,,by relating the behavior of\Nthe state at the given iteration
Dialogue: 0,0:40:19.20,0:40:23.88,Default,,0,0,0,,with the state at\Nthe last iteration.
Dialogue: 0,0:40:23.88,0:40:27.28,Default,,0,0,0,,And such a specification\Ncan be established
Dialogue: 0,0:40:27.28,0:40:32.32,Default,,0,0,0,,by induction using Coq's\Ninduction mechanism
Dialogue: 0,0:40:32.32,0:40:34.76,Default,,0,0,0,,by applying the following\Nunrolling rule,
Dialogue: 0,0:40:34.76,0:40:39.84,Default,,0,0,0,,which essentially unfolds\Nthe while loop one iteration.
Dialogue: 0,0:40:39.84,0:40:42.60,Default,,0,0,0,,This rule introduces\Na conditional sequence
Dialogue: 0,0:40:42.60,0:40:47.04,Default,,0,0,0,,and a recursive occurrence\Nof the while loop.
Dialogue: 0,0:40:47.04,0:40:48.88,Default,,0,0,0,,When reasoning about this\Nrecursive occurrence
Dialogue: 0,0:40:48.88,0:40:51.68,Default,,0,0,0,,of the while loop, one may\Napply the frame rule
Dialogue: 0,0:40:51.68,0:40:56.00,Default,,0,0,0,,to frame the parts of\Nthe list or of the tree
Dialogue: 0,0:40:56.00,0:41:01.00,Default,,0,0,0,,that we are stepping over.
Dialogue: 0,0:41:01.00,0:41:03.08,Default,,0,0,0,,So in the course,\NI described an example
Dialogue: 0,0:41:03.08,0:41:06.40,Default,,0,0,0,,illustrating this proof technique
Dialogue: 0,0:41:06.40,0:41:12.00,Default,,0,0,0,,and compare it with the proof\Nbased on the loop environment.
Dialogue: 0,0:41:12.00,0:41:15.12,Default,,0,0,0,,In conclusion, you can\Nfind on my web page
Dialogue: 0,0:41:15.12,0:41:18.44,Default,,0,0,0,,the paper, including\Nits eight page appendix
Dialogue: 0,0:41:18.44,0:41:21.68,Default,,0,0,0,,on all the course material,\Nboth in Coq format
Dialogue: 0,0:41:21.68,0:41:24.64,Default,,0,0,0,,and HTML format.
Dialogue: 0,0:41:24.64,0:41:26.60,Default,,0,0,0,,This course is meant\Nto be released soon
Dialogue: 0,0:41:26.60,0:41:30.40,Default,,0,0,0,,as a volume of the software\Nfoundation series.
Dialogue: 0,0:41:30.40,0:41:31.84,Default,,0,0,0,,I'm actually seeking for feedback,
Dialogue: 0,0:41:31.84,0:41:34.56,Default,,0,0,0,,both from students\Nand teachers to further
Dialogue: 0,0:41:34.56,0:41:36.36,Default,,0,0,0,,polish the material.
Dialogue: 0,0:41:36.36,0:41:39.40,Default,,0,0,0,,So if you're interested,\Nplease get in touch with me,
Dialogue: 0,0:41:39.40,0:41:42.20,Default,,0,0,0,,and I will be happy to\Nserve as a TA for you
Dialogue: 0,0:41:42.20,0:41:43.72,Default,,0,0,0,,if you are teaching the course.
Dialogue: 0,0:41:43.72,0:41:47.16,Default,,0,0,0,,Thank you very much.
Dialogue: 0,0:41:47.16,0:41:55.00,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,0:41:55.00,0:41:57.84,Default,,0,0,0,,Richard: OK, thank you\Nvery much, Arthur.
Dialogue: 0,0:41:57.84,0:41:59.96,Default,,0,0,0,,He is now available in\Nthe New York Time Band
Dialogue: 0,0:41:59.96,0:42:02.64,Default,,0,0,0,,for question and answer,
Dialogue: 0,0:42:02.64,0:42:04.60,Default,,0,0,0,,and we'll take a brief\Npause to sync up
Dialogue: 0,0:42:04.60,0:42:13.60,Default,,0,0,0,,with the advertised schedule.
Dialogue: 0,0:43:00.32,0:43:01.76,Default,,0,0,0,,Now, we have Aaron Stump,
Dialogue: 0,0:43:01.76,0:43:03.68,Default,,0,0,0,,presenting his "Strong\NFunctional Pearl:
Dialogue: 0,0:43:03.68,0:43:07.24,Default,,0,0,0,,"Harper's Regular-Expression\NMatcher in Cedille."
Dialogue: 0,0:43:07.24,0:43:08.80,Default,,0,0,0,,AARON: Hello, I'm Aaron Stump,
Dialogue: 0,0:43:08.80,0:43:10.04,Default,,0,0,0,,and today, I'm going to present to you
Dialogue: 0,0:43:10.04,0:43:11.20,Default,,0,0,0,,our "Strong Functional Pearl:
Dialogue: 0,0:43:11.20,0:43:15.24,Default,,0,0,0,,"Harper's Regular-Expression\NMatcher in Cedille."
Dialogue: 0,0:43:15.24,0:43:16.56,Default,,0,0,0,,Harper's regular-expression matcher
Dialogue: 0,0:43:16.56,0:43:18.52,Default,,0,0,0,,is a continuation-based algorithm
Dialogue: 0,0:43:18.52,0:43:20.24,Default,,0,0,0,,for regular-expression matching,
Dialogue: 0,0:43:20.24,0:43:23.60,Default,,0,0,0,,introduced by Robert\NHarper, in his JFP paper,
Dialogue: 0,0:43:23.60,0:43:25.36,Default,,0,0,0,,titled, "Proof-Directed Debugging."
Dialogue: 0,0:43:25.36,0:43:26.92,Default,,0,0,0,,And the basic idea of the algorithm
Dialogue: 0,0:43:26.92,0:43:29.48,Default,,0,0,0,,is to decompose regular expressions.
Dialogue: 0,0:43:29.48,0:43:31.12,Default,,0,0,0,,So, you're going to dig down\Ninto the regular expression,
Dialogue: 0,0:43:31.12,0:43:33.40,Default,,0,0,0,,building up a success continuation.
Dialogue: 0,0:43:33.92,0:43:34.92,Default,,0,0,0,,If you detect a clash,
Dialogue: 0,0:43:34.92,0:43:36.28,Default,,0,0,0,,where the regular\Nexpression is asking
Dialogue: 0,0:43:36.28,0:43:38.40,Default,,0,0,0,,for some character that's\Nnot there in the string,
Dialogue: 0,0:43:38.40,0:43:40.16,Default,,0,0,0,,then, you just return false.
Dialogue: 0,0:43:40.16,0:43:42.12,Default,,0,0,0,,But, if you find a character match,
Dialogue: 0,0:43:42.12,0:43:43.60,Default,,0,0,0,,then, you're gonna invoke\Nthe continuation,
Dialogue: 0,0:43:43.60,0:43:46.72,Default,,0,0,0,,to keep processing\Nthe suffix of the string.
Dialogue: 0,0:43:46.72,0:43:49.28,Default,,0,0,0,,And Harper's paper is, you know,
Dialogue: 0,0:43:49.28,0:43:50.64,Default,,0,0,0,,he called it\N"Proof-Directed Debugging,"
Dialogue: 0,0:43:50.64,0:43:53.00,Default,,0,0,0,,because there's an interesting bug
Dialogue: 0,0:43:53.00,0:43:55.96,Default,,0,0,0,,in the termination argument\Nfor this algorithm,
Dialogue: 0,0:43:55.96,0:43:58.84,Default,,0,0,0,,unless you use standard\Nregular expressions.
Dialogue: 0,0:43:58.84,0:44:00.20,Default,,0,0,0,,So, your R star is allowed,
Dialogue: 0,0:44:00.20,0:44:02.48,Default,,0,0,0,,only if the empty string, epsilon,
Dialogue: 0,0:44:02.48,0:44:04.36,Default,,0,0,0,,is not in language of R.
Dialogue: 0,0:44:04.36,0:44:05.84,Default,,0,0,0,,And here, in this talk,
Dialogue: 0,0:44:05.84,0:44:07.88,Default,,0,0,0,,we're gonna enforce\Nthat syntactically,
Dialogue: 0,0:44:07.88,0:44:11.20,Default,,0,0,0,,using a typed StdReg, for\Nstandard regular expressions.
Dialogue: 0,0:44:11.20,0:44:12.84,Default,,0,0,0,,And this is an idea\Nwe got from a paper,
Dialogue: 0,0:44:12.84,0:44:15.76,Default,,0,0,0,,from Dan Licata and his students.
Dialogue: 0,0:44:15.76,0:44:19.04,Default,,0,0,0,,So, here's a look at\Nthe implementation in Haskell.
Dialogue: 0,0:44:19.04,0:44:20.72,Default,,0,0,0,,We're going to move to\Nthe implementation in Cedille,
Dialogue: 0,0:44:20.72,0:44:22.72,Default,,0,0,0,,in a little bit, but to\Nstart off in Haskell,
Dialogue: 0,0:44:22.72,0:44:24.80,Default,,0,0,0,,so, it's a continuation-based\Nalgorithm.
Dialogue: 0,0:44:24.80,0:44:27.16,Default,,0,0,0,,So, we have a type K\Nfor continuations.
Dialogue: 0,0:44:27.16,0:44:28.32,Default,,0,0,0,,It takes strings to bools.
Dialogue: 0,0:44:28.32,0:44:29.80,Default,,0,0,0,,They're going to take suffixes,
Dialogue: 0,0:44:29.80,0:44:31.56,Default,,0,0,0,,tell us whether or not they match.
Dialogue: 0,0:44:32.32,0:44:34.12,Default,,0,0,0,,And then, there's a type,\NmatchT, for convenience.
Dialogue: 0,0:44:34.12,0:44:37.32,Default,,0,0,0,,It just says continuation\Ngoes to bool.
Dialogue: 0,0:44:37.32,0:44:39.44,Default,,0,0,0,,So here, we see the two helper-
Dialogue: 0,0:44:39.44,0:44:42.80,Default,,0,0,0,,central helper functions\Nof the algorithm.
Dialogue: 0,0:44:42.80,0:44:44.12,Default,,0,0,0,,There's matchh.
Dialogue: 0,0:44:44.12,0:44:46.84,Default,,0,0,0,,It takes a string, in one of\Nthese regular expressions,
Dialogue: 0,0:44:46.84,0:44:48.56,Default,,0,0,0,,and a continuation.
Dialogue: 0,0:44:48.56,0:44:50.84,Default,,0,0,0,,Now, the first equation\Nmatchh you see,
Dialogue: 0,0:44:50.84,0:44:53.36,Default,,0,0,0,,if that string is empty,\Nthen, we just return false,
Dialogue: 0,0:44:53.36,0:44:55.24,Default,,0,0,0,,'cause these are standard\Nregular expressions.
Dialogue: 0,0:44:55.24,0:44:57.96,Default,,0,0,0,,They cannot match the empty string.
Dialogue: 0,0:44:57.96,0:44:59.32,Default,,0,0,0,,Otherwise, we just split the string
Dialogue: 0,0:44:59.32,0:45:01.56,Default,,0,0,0,,into its head, c, and tail, cs,
Dialogue: 0,0:45:01.56,0:45:05.08,Default,,0,0,0,,and we invoke this second helper\Nfunction, called matchi.
Dialogue: 0,0:45:05.08,0:45:06.60,Default,,0,0,0,,OK, and here, we see the semantics,
Dialogue: 0,0:45:06.60,0:45:09.04,Default,,0,0,0,,in the form of these standard\Nregular expressions, too.
Dialogue: 0,0:45:09.04,0:45:11.04,Default,,0,0,0,,So, matchi, this,
Dialogue: 0,0:45:11.04,0:45:12.56,Default,,0,0,0,,you could match NoMatch\Nregular expression.
Dialogue: 0,0:45:12.56,0:45:14.12,Default,,0,0,0,,That just says\Nnothing's gonna match.
Dialogue: 0,0:45:14.12,0:45:15.72,Default,,0,0,0,,We just return false.
Dialogue: 0,0:45:15.72,0:45:18.40,Default,,0,0,0,,There's MatchChar, with\Na character of c prime,
Dialogue: 0,0:45:18.40,0:45:19.40,Default,,0,0,0,,and then, you check,
Dialogue: 0,0:45:19.40,0:45:22.20,Default,,0,0,0,,does c equal c prime?
Dialogue: 0,0:45:22.20,0:45:24.00,Default,,0,0,0,,And if so, that's the success case,
Dialogue: 0,0:45:24.00,0:45:28.52,Default,,0,0,0,,and you invoke this continuation,\Nk,on the suffix, cs,
Dialogue: 0,0:45:28.52,0:45:30.44,Default,,0,0,0,,and otherwise, you return false.
Dialogue: 0,0:45:30.44,0:45:32.60,Default,,0,0,0,,For an Or regular expression,\Nwe just decompose,
Dialogue: 0,0:45:32.60,0:45:34.48,Default,,0,0,0,,and just check disjunctively
Dialogue: 0,0:45:34.48,0:45:37.32,Default,,0,0,0,,the two parts of\Nthe regular expression.
Dialogue: 0,0:45:37.32,0:45:38.32,Default,,0,0,0,,For the Plus case, though,
Dialogue: 0,0:45:38.32,0:45:41.04,Default,,0,0,0,,this is where the interesting\Ntermination issue comes up.
Dialogue: 0,0:45:41.04,0:45:43.08,Default,,0,0,0,,So, if we have Plus r,
Dialogue: 0,0:45:43.08,0:45:45.36,Default,,0,0,0,,we want to match r, to see\Nif it matches one time,
Dialogue: 0,0:45:45.36,0:45:48.68,Default,,0,0,0,,'cause this is Plus r, of course,\Nbeing one or more matches.
Dialogue: 0,0:45:48.68,0:45:49.92,Default,,0,0,0,,So, we match it one time,
Dialogue: 0,0:45:49.92,0:45:51.12,Default,,0,0,0,,and then, in the continuation
Dialogue: 0,0:45:51.12,0:45:53.56,Default,,0,0,0,,that starts out with\NLambda cs prime,
Dialogue: 0,0:45:53.56,0:45:54.56,Default,,0,0,0,,we're gonna say, well,
Dialogue: 0,0:45:54.56,0:45:57.16,Default,,0,0,0,,let's try just calling\Nthe continuation k on cs prime.
Dialogue: 0,0:45:57.16,0:46:00.28,Default,,0,0,0,,That would represent\Nexactly one match of r.
Dialogue: 0,0:46:00.28,0:46:01.28,Default,,0,0,0,,But, if that fails,
Dialogue: 0,0:46:01.28,0:46:04.40,Default,,0,0,0,,then, we want to go,\Nand we're supposed to recursively
Dialogue: 0,0:46:04.40,0:46:06.16,Default,,0,0,0,,try the whole\Nregular-expression again,
Dialogue: 0,0:46:06.16,0:46:07.68,Default,,0,0,0,,on the suffix, cs prime.
Dialogue: 0,0:46:07.68,0:46:10.08,Default,,0,0,0,,So, that's what I've got\Nhighlighted in red there.
Dialogue: 0,0:46:10.08,0:46:11.52,Default,,0,0,0,,And the interesting thing\Nabout that, of course,
Dialogue: 0,0:46:11.52,0:46:13.36,Default,,0,0,0,,is that the regular expression
Dialogue: 0,0:46:13.36,0:46:15.52,Default,,0,0,0,,is exactly the same\Nas we started with.
Dialogue: 0,0:46:15.52,0:46:17.72,Default,,0,0,0,,Plus r, we just make\Nour criss-cross plus r.
Dialogue: 0,0:46:17.72,0:46:19.36,Default,,0,0,0,,So, there's been no\Nstructural decrease here,
Dialogue: 0,0:46:19.36,0:46:23.44,Default,,0,0,0,,which is quite worrisome for\Na termination situation.
Dialogue: 0,0:46:23.44,0:46:24.68,Default,,0,0,0,,And then, concat,
Dialogue: 0,0:46:24.68,0:46:28.92,Default,,0,0,0,,similarly decomposes\Nand updates the continuation.
Dialogue: 0,0:46:28.92,0:46:32.56,Default,,0,0,0,,So, the problem of termination\Nfor this algorithm
Dialogue: 0,0:46:32.56,0:46:33.60,Default,,0,0,0,,has been actually studied,
Dialogue: 0,0:46:33.60,0:46:35.96,Default,,0,0,0,,by a number of different\Nprevious works.
Dialogue: 0,0:46:35.96,0:46:37.96,Default,,0,0,0,,You can sort of see\Nthe main problem right here,
Dialogue: 0,0:46:37.96,0:46:39.40,Default,,0,0,0,,in this little part\Nthat I pulled out
Dialogue: 0,0:46:39.40,0:46:41.52,Default,,0,0,0,,from the code we were\Njust looking at.
Dialogue: 0,0:46:41.52,0:46:44.16,Default,,0,0,0,,And so, we have a matchh,\Nthat calls matchi,
Dialogue: 0,0:46:44.16,0:46:46.00,Default,,0,0,0,,and matchi wants to\Ncall back to matchh,
Dialogue: 0,0:46:46.00,0:46:48.92,Default,,0,0,0,,in this red highlighted\Ncall site there,
Dialogue: 0,0:46:48.92,0:46:50.68,Default,,0,0,0,,but it's calling it\Nwith the cs prime.
Dialogue: 0,0:46:50.68,0:46:54.20,Default,,0,0,0,,It's just a value it got\Nfrom a continuation.
Dialogue: 0,0:46:54.20,0:46:55.40,Default,,0,0,0,,It has no idea.
Dialogue: 0,0:46:55.40,0:46:58.24,Default,,0,0,0,,You know, the code, there's no\Nobvious syntactic connection
Dialogue: 0,0:46:58.24,0:47:00.20,Default,,0,0,0,,between cs prime and cs.
Dialogue: 0,0:47:00.20,0:47:01.92,Default,,0,0,0,,So, it seems that you need\Nsomething like a proof
Dialogue: 0,0:47:01.92,0:47:03.36,Default,,0,0,0,,that the length of cs prime
Dialogue: 0,0:47:03.36,0:47:04.60,Default,,0,0,0,,is less than the length of cs,
Dialogue: 0,0:47:04.60,0:47:05.80,Default,,0,0,0,,or something like this.
Dialogue: 0,0:47:05.80,0:47:08.92,Default,,0,0,0,,And, in fact, previous works\Nthe tackled termination
Dialogue: 0,0:47:08.92,0:47:10.72,Default,,0,0,0,,of Harper's\Nregular-expression matcher,
Dialogue: 0,0:47:10.72,0:47:11.84,Default,,0,0,0,,some of them anyway,
Dialogue: 0,0:47:11.84,0:47:14.52,Default,,0,0,0,,used dependently typed continuations.
Dialogue: 0,0:47:14.52,0:47:16.88,Default,,0,0,0,,And, in fact, one of these papers,
Dialogue: 0,0:47:16.88,0:47:18.56,Default,,0,0,0,,a very nice paper\NI highly recommend,
Dialogue: 0,0:47:18.56,0:47:20.40,Default,,0,0,0,,by Bove, Krauss, and Sozeau,
Dialogue: 0,0:47:20.40,0:47:23.28,Default,,0,0,0,,raise this challenge, that\Nthere seems to be no easy way
Dialogue: 0,0:47:23.28,0:47:25.04,Default,,0,0,0,,to achieve the same effect,
Dialogue: 0,0:47:25.04,0:47:28.56,Default,,0,0,0,,without the use of dependent types.
Dialogue: 0,0:47:28.56,0:47:31.36,Default,,0,0,0,,So, in this pearl, we're gonna show-
Dialogue: 0,0:47:31.36,0:47:32.56,Default,,0,0,0,,we're showing Harper's matcher
Dialogue: 0,0:47:32.56,0:47:34.44,Default,,0,0,0,,as a strong functional program,
Dialogue: 0,0:47:34.44,0:47:36.44,Default,,0,0,0,,in the sense of David Turner.
Dialogue: 0,0:47:36.44,0:47:38.08,Default,,0,0,0,,So, the idea is that we want,
Dialogue: 0,0:47:38.08,0:47:39.24,Default,,0,0,0,,in strong functional programming,
Dialogue: 0,0:47:39.24,0:47:41.92,Default,,0,0,0,,is we want to statically enforce\Ntermination of programs,
Dialogue: 0,0:47:41.92,0:47:43.52,Default,,0,0,0,,but the name of the game here is,
Dialogue: 0,0:47:43.52,0:47:44.88,Default,,0,0,0,,you're only allowed to use
Dialogue: 0,0:47:44.88,0:47:47.80,Default,,0,0,0,,the types of regular old\Nfunctional programming.
Dialogue: 0,0:47:47.80,0:47:50.64,Default,,0,0,0,,Just polymorphic types.
Dialogue: 0,0:47:50.64,0:47:52.12,Default,,0,0,0,,You can't use dependent types.
Dialogue: 0,0:47:52.12,0:47:53.28,Default,,0,0,0,,You can't use sized types.
Dialogue: 0,0:47:53.28,0:47:55.08,Default,,0,0,0,,You're not allowed to use\Ntermination proofs,
Dialogue: 0,0:47:55.08,0:47:57.12,Default,,0,0,0,,or variants, or metrics,\Nor well-founded orders.
Dialogue: 0,0:47:57.12,0:48:01.44,Default,,0,0,0,,All that heavy duty machinery\Nof termination is not allowed,
Dialogue: 0,0:48:01.44,0:48:04.24,Default,,0,0,0,,in the regime of strong\Nfunctional programming.
Dialogue: 0,0:48:04.24,0:48:07.12,Default,,0,0,0,,And so, we are happy to report that,
Dialogue: 0,0:48:07.12,0:48:10.84,Default,,0,0,0,,in fact, you can do this example\Nwithout dependent types.
Dialogue: 0,0:48:10.84,0:48:12.56,Default,,0,0,0,,You can just use the tool box
Dialogue: 0,0:48:12.56,0:48:16.60,Default,,0,0,0,,of well, advanced, strong\Nfunctional program.
Dialogue: 0,0:48:16.60,0:48:17.80,Default,,0,0,0,,How so, how can you do that?
Dialogue: 0,0:48:17.80,0:48:18.88,Default,,0,0,0,,That's what we're going to talk about,
Dialogue: 0,0:48:18.88,0:48:21.28,Default,,0,0,0,,for the time we have here.
Dialogue: 0,0:48:21.28,0:48:25.72,Default,,0,0,0,,And this is - we're using our\Nlanguage, Cedille, for this.
Dialogue: 0,0:48:25.72,0:48:27.96,Default,,0,0,0,,And so, strong functional\Nprogramming in Cedille.
Dialogue: 0,0:48:27.96,0:48:29.52,Default,,0,0,0,,Cedille is a dependent type theory,
Dialogue: 0,0:48:29.52,0:48:32.56,Default,,0,0,0,,kind of like Coq or Agda,
Dialogue: 0,0:48:32.56,0:48:36.28,Default,,0,0,0,,and termination of programs\Nis enforced by typing.
Dialogue: 0,0:48:36.28,0:48:39.36,Default,,0,0,0,,But here, Cedille has\Nsome particularities
Dialogue: 0,0:48:39.36,0:48:41.24,Default,,0,0,0,,that make it a bit different\Nfrom Coq and Agda,
Dialogue: 0,0:48:41.24,0:48:44.32,Default,,0,0,0,,and one of them is how\Ntermination is handled.
Dialogue: 0,0:48:44.32,0:48:47.08,Default,,0,0,0,,So, and that's part of what we're going to have\Na little tutorial about,
Dialogue: 0,0:48:47.08,0:48:48.16,Default,,0,0,0,,in this talk.
Dialogue: 0,0:48:48.16,0:48:49.20,Default,,0,0,0,,So, in Cedille,
Dialogue: 0,0:48:49.20,0:48:50.68,Default,,0,0,0,,when you're writing\Na recursive function,
Dialogue: 0,0:48:50.68,0:48:51.68,Default,,0,0,0,,you're presented with something
Dialogue: 0,0:48:51.68,0:48:54.16,Default,,0,0,0,,that we call a recursion universe.
Dialogue: 0,0:48:54.16,0:48:58.40,Default,,0,0,0,,It's a typed interface for\Ndoing the recursion, OK?
Dialogue: 0,0:48:58.40,0:49:00.48,Default,,0,0,0,,So, you get an abstract type r.
Dialogue: 0,0:49:00.48,0:49:03.20,Default,,0,0,0,,That's what you're sort of\Nthinking of as the universe,
Dialogue: 0,0:49:03.20,0:49:04.20,Default,,0,0,0,,the recursion universe,
Dialogue: 0,0:49:04.20,0:49:05.72,Default,,0,0,0,,and it has some operations on it,
Dialogue: 0,0:49:05.72,0:49:07.36,Default,,0,0,0,,that help you write your recursion.
Dialogue: 0,0:49:07.36,0:49:10.48,Default,,0,0,0,,You're not allowed to make\Ndirect recursive calls,
Dialogue: 0,0:49:10.48,0:49:11.48,Default,,0,0,0,,in your code.
Dialogue: 0,0:49:11.48,0:49:14.12,Default,,0,0,0,,You have to kinda go\Nthrough this interface.
Dialogue: 0,0:49:14.12,0:49:15.60,Default,,0,0,0,,And the language, though, provides-
Dialogue: 0,0:49:15.60,0:49:17.28,Default,,0,0,0,,Cedille provides special syntax
Dialogue: 0,0:49:17.28,0:49:19.32,Default,,0,0,0,,for these recursion universes,\Nthat pretty much hide
Dialogue: 0,0:49:20.00,0:49:22.00,Default,,0,0,0,,that hide\Na lot of the machinery
Dialogue: 0,0:49:22.00,0:49:24.32,Default,,0,0,0,,and make it feel\Na quite idiomatic,
Dialogue: 0,0:49:24.32,0:49:26.40,Default,,0,0,0,,way of writing\Nrecursive functions.
Dialogue: 0,0:49:26.40,0:49:29.00,Default,,0,0,0,,So, I want to emphasize\Neven though Cedille
Dialogue: 0,0:49:29.00,0:49:31.04,Default,,0,0,0,,is this type theory\Nthat lets you do proofs
Dialogue: 0,0:49:31.04,0:49:34.00,Default,,0,0,0,,and things like that,\Ndependently typed programs
Dialogue: 0,0:49:34.00,0:49:35.68,Default,,0,0,0,,here we're not using\Nany dependent types
Dialogue: 0,0:49:35.68,0:49:36.96,Default,,0,0,0,,or any of that\Nkind of machinery,
Dialogue: 0,0:49:36.96,0:49:40.08,Default,,0,0,0,,we're just using\Nstrong functional programming.
Dialogue: 0,0:49:40.08,0:49:41.64,Default,,0,0,0,,OK. So let's see\Nhow this works
Dialogue: 0,0:49:41.64,0:49:44.56,Default,,0,0,0,,in several steps.\NSo first, the first point,
Dialogue: 0,0:49:44.56,0:49:47.04,Default,,0,0,0,,we're going to see\NCedille's recursion universes.
Dialogue: 0,0:49:47.04,0:49:48.72,Default,,0,0,0,,So we start off\Nwith something called
Dialogue: 0,0:49:48.72,0:49:51.16,Default,,0,0,0,,a Mendler style\Nrecursion universe.
Dialogue: 0,0:49:51.16,0:49:54.24,Default,,0,0,0,,OK. And so this is kind\Nof like the underlying interface.
Dialogue: 0,0:49:54.24,0:49:55.52,Default,,0,0,0,,And again, Cedille\Nprovides sort of a little
Dialogue: 0,0:49:55.52,0:49:58.12,Default,,0,0,0,,bit nicer surface language\Naccess to this interface,
Dialogue: 0,0:49:58.12,0:50:00.72,Default,,0,0,0,,but this is the basic interface\Nthat we're relying on.
Dialogue: 0,0:50:00.72,0:50:04.12,Default,,0,0,0,,So let's let F be a signature\Nfunction for a data type.
Dialogue: 0,0:50:04.12,0:50:06.64,Default,,0,0,0,,So for example,\Nif your data type was list of A's,
Dialogue: 0,0:50:06.64,0:50:11.24,Default,,0,0,0,,then your signature function\Nis FX equals unit or A cross X.
Dialogue: 0,0:50:11.24,0:50:15.00,Default,,0,0,0,,OK. So, if you wanna\Nsuppose you're trying
Dialogue: 0,0:50:15.00,0:50:17.04,Default,,0,0,0,,to write a function.\Nthat's gonna compute
Dialogue: 0,0:50:17.04,0:50:19.84,Default,,0,0,0,,a value of type X\Nfrom your datatype D
Dialogue: 0,0:50:19.84,0:50:22.56,Default,,0,0,0,,then what the recursion universe\Nprovides you is
Dialogue: 0,0:50:22.56,0:50:24.56,Default,,0,0,0,,this abstract type R\Nis mentioning.
Dialogue: 0,0:50:24.56,0:50:25.96,Default,,0,0,0,,It's just some type.\NYou have no idea,
Dialogue: 0,0:50:25.96,0:50:28.08,Default,,0,0,0,,anything about the type,\Nexcept what the interface
Dialogue: 0,0:50:28.08,0:50:30.60,Default,,0,0,0,,gives you about it.\NThe first thing it gives you
Dialogue: 0,0:50:30.60,0:50:34.00,Default,,0,0,0,,is an eval function\NR to X, OK.
Dialogue: 0,0:50:34.00,0:50:35.64,Default,,0,0,0,,And this is the function\Nyou have to invoke.
Dialogue: 0,0:50:35.64,0:50:37.68,Default,,0,0,0,,If you want to make\Na recursive call,
Dialogue: 0,0:50:37.68,0:50:39.48,Default,,0,0,0,,you gotta call eval,\Nbut you can only call it
Dialogue: 0,0:50:39.48,0:50:40.92,Default,,0,0,0,,on an R thing.\NYou can't call it
Dialogue: 0,0:50:40.92,0:50:43.44,Default,,0,0,0,,on just some random\Nother D thing.
Dialogue: 0,0:50:43.44,0:50:45.88,Default,,0,0,0,,And you're also given\Na substructure, sub data structure
Dialogue: 0,0:50:45.88,0:50:49.92,Default,,0,0,0,,of type fr, in other words,\Nyou're given this little package
Dialogue: 0,0:50:49.92,0:50:53.40,Default,,0,0,0,,That is presenting you,\Nthe data that you have,
Dialogue: 0,0:50:53.40,0:50:57.84,Default,,0,0,0,,except at the sort\Nof factorial position it's got
Dialogue: 0,0:50:57.84,0:51:01.84,Default,,0,0,0,,The abstract type R.\NAnd so the key thing
Dialogue: 0,0:51:01.84,0:51:03.56,Default,,0,0,0,,about this is that,\Nand this is, this goes
Dialogue: 0,0:51:03.56,0:51:07.28,Default,,0,0,0,,back to this idea\Nof Mendler style recursion
Dialogue: 0,0:51:07.28,0:51:10.76,Default,,0,0,0,,is that you can only call\Neval on sub data,
Dialogue: 0,0:51:10.76,0:51:12.36,Default,,0,0,0,,because the only things\Nyou have lying around
Dialogue: 0,0:51:12.36,0:51:14.52,Default,,0,0,0,,of type R, are the things\Nthat are hidden,
Dialogue: 0,0:51:14.52,0:51:16.68,Default,,0,0,0,,you know, presented to you\Nin this sub data structure.
Dialogue: 0,0:51:16.68,0:51:19.84,Default,,0,0,0,,And so that's the only stuff\Nyou can call it eval on.
Dialogue: 0,0:51:19.84,0:51:21.64,Default,,0,0,0,,So that ensures your,\Nyou are doing
Dialogue: 0,0:51:21.64,0:51:24.04,Default,,0,0,0,,a structural termination,\Neven though there's no
Dialogue: 0,0:51:24.04,0:51:27.16,Default,,0,0,0,,sort of check about,\Nyou know, is this variable,
Dialogue: 0,0:51:27.16,0:51:30.32,Default,,0,0,0,,I'm making a quick call\Non somehow structurally
Dialogue: 0,0:51:30.32,0:51:32.24,Default,,0,0,0,,derived from my input\Nor anything like that.
Dialogue: 0,0:51:32.24,0:51:34.16,Default,,0,0,0,,It's all done\Nthrough the typing.
Dialogue: 0,0:51:34.16,0:51:37.04,Default,,0,0,0,,OK. So that's Mendler-Style.\NNow Mendler-Style paramorphic
Dialogue: 0,0:51:37.04,0:51:40.16,Default,,0,0,0,,recursion universe.\NSo this is the next sort
Dialogue: 0,0:51:40.16,0:51:44.08,Default,,0,0,0,,of step that presenting\Nsort of a conceptual development
Dialogue: 0,0:51:44.08,0:51:47.00,Default,,0,0,0,,of this idea of Cedille's\Nrecursion universe.
Dialogue: 0,0:51:47.00,0:51:49.28,Default,,0,0,0,,So for computing X,\Nfrom data type D
Dialogue: 0,0:51:49.28,0:51:52.20,Default,,0,0,0,,now for paramorphic recursion,\Nthe universe gives you
Dialogue: 0,0:51:52.20,0:51:54.80,Default,,0,0,0,,the same stuff you had\Nbefore the recursion universe
Dialogue: 0,0:51:54.80,0:51:56.88,Default,,0,0,0,,has all these same pieces,\Nbut it also comes
Dialogue: 0,0:51:56.88,0:52:00.56,Default,,0,0,0,,as, highlighted in black,\Nwith a reveal function,
Dialogue: 0,0:52:00.56,0:52:06.52,Default,,0,0,0,,R to D, so this unmasks R\Nas really being D, OK.
Dialogue: 0,0:52:06.52,0:52:09.08,Default,,0,0,0,,So, but notice you can't\Ngo the other way around.
Dialogue: 0,0:52:09.08,0:52:11.52,Default,,0,0,0,,You cannot inject D into R\Nthat would be totally
Dialogue: 0,0:52:11.52,0:52:13.44,Default,,0,0,0,,unsound from\Na termination perspective.
Dialogue: 0,0:52:13.44,0:52:15.76,Default,,0,0,0,,'Cause you could just\Nstick random values into R
Dialogue: 0,0:52:15.76,0:52:18.16,Default,,0,0,0,,and the recurse on them.\NBut here you,
Dialogue: 0,0:52:18.16,0:52:20.64,Default,,0,0,0,,you are allowed to sort of\Nleave the recursion universe.
Dialogue: 0,0:52:20.64,0:52:22.88,Default,,0,0,0,,You can sort of, you know,\NI don't know wormhole
Dialogue: 0,0:52:22.88,0:52:24.08,Default,,0,0,0,,out of there\Nif you want to,
Dialogue: 0,0:52:24.08,0:52:27.48,Default,,0,0,0,,to have some data D,\Nand this is really important.
Dialogue: 0,0:52:27.48,0:52:28.80,Default,,0,0,0,,If you wanna write\Nefficient accessor
Dialogue: 0,0:52:28.80,0:52:31.48,Default,,0,0,0,,functions like predecessor\Nor tail or something.
Dialogue: 0,0:52:32.04,0:52:34.40,Default,,0,0,0,,Now finally, what we need\Nfor the Harper's
Dialogue: 0,0:52:34.40,0:52:36.68,Default,,0,0,0,,regular expression matcher\Nis we need support
Dialogue: 0,0:52:36.68,0:52:39.44,Default,,0,0,0,,for nested recursion.\NSo you have all the same stuff
Dialogue: 0,0:52:39.44,0:52:41.68,Default,,0,0,0,,we had before,\Nexcept we change a little bit,
Dialogue: 0,0:52:41.68,0:52:44.20,Default,,0,0,0,,the return type\Nof your function.
Dialogue: 0,0:52:44.20,0:52:49.16,Default,,0,0,0,,Now couldn't is now\Ncould depend on D.
Dialogue: 0,0:52:49.16,0:52:52.56,Default,,0,0,0,,So you compute X of D\Nfrom a data type D
Dialogue: 0,0:52:52.56,0:52:55.20,Default,,0,0,0,,and the, the reason\Nthat's really important to shift,
Dialogue: 0,0:52:55.20,0:52:57.48,Default,,0,0,0,,as I see it say below\Nmy bullet points there
Dialogue: 0,0:52:57.48,0:53:00.72,Default,,0,0,0,,from X of kind star,\Nto X of kind star to star,
Dialogue: 0,0:53:00.72,0:53:03.96,Default,,0,0,0,,is it now the eval function,\Nyou can write eval function
Dialogue: 0,0:53:03.96,0:53:06.96,Default,,0,0,0,,that goes from R to X of R.\NAnd that gives you
Dialogue: 0,0:53:06.96,0:53:09.36,Default,,0,0,0,,the possibility of seeing\Nwhen you return something
Dialogue: 0,0:53:09.36,0:53:12.16,Default,,0,0,0,,from your recursive call,\Nthat it also has
Dialogue: 0,0:53:12.16,0:53:13.68,Default,,0,0,0,,type R and hence,\Nyou could make
Dialogue: 0,0:53:13.68,0:53:18.64,Default,,0,0,0,,a recursive call again on that.\NSo a recursion is then allowed
Dialogue: 0,0:53:18.64,0:53:21.00,Default,,0,0,0,,on values that\NVal has returned.
Dialogue: 0,0:53:21.00,0:53:22.72,Default,,0,0,0,,So that enables a form\Nof nested recursion,
Dialogue: 0,0:53:22.72,0:53:25.36,Default,,0,0,0,,and the continuations\Nare basically hiding
Dialogue: 0,0:53:25.36,0:53:28.52,Default,,0,0,0,,a form of nested recursion.\NOK. So let's take
Dialogue: 0,0:53:28.52,0:53:30.12,Default,,0,0,0,,a look at how we do\Nthis in Cedille
Dialogue: 0,0:53:30.12,0:53:35.68,Default,,0,0,0,,Harper's match in Cedille.\NSo, the critical part
Dialogue: 0,0:53:35.68,0:53:38.80,Default,,0,0,0,,about the nested\Nrecursion is here.
Dialogue: 0,0:53:38.80,0:53:44.68,Default,,0,0,0,,So in,\NIn blue, I've had,
Dialogue: 0,0:53:44.68,0:53:48.48,Default,,0,0,0,,it's Cedille syntax\Nfor indicating the abstract type R,
Dialogue: 0,0:53:48.48,0:53:49.88,Default,,0,0,0,,if we're doing\Na recursion here,
Dialogue: 0,0:53:49.88,0:53:52.64,Default,,0,0,0,,mu match, then mu\Nis for the sort of
Dialogue: 0,0:53:52.64,0:53:56.36,Default,,0,0,0,,kicking off recursion\Nthen type/match is R
Dialogue: 0,0:53:56.36,0:53:58.68,Default,,0,0,0,,That's the abstract type\Nof the recursion universe.
Dialogue: 0,0:53:58.68,0:54:01.00,Default,,0,0,0,,And the X, the type\Nwe're computing here
Dialogue: 0,0:54:01.00,0:54:03.08,Default,,0,0,0,,has to be given explicitly\NCedille can't
Dialogue: 0,0:54:03.08,0:54:07.12,Default,,0,0,0,,infer this for you.\NAnd it can mention this R,
Dialogue: 0,0:54:07.12,0:54:10.40,Default,,0,0,0,,and that's just like XR, XD.\NNow we have
Dialogue: 0,0:54:10.40,0:54:13.56,Default,,0,0,0,,a way of mentioning\Nwe're indicating
Dialogue: 0,0:54:13.56,0:54:17.60,Default,,0,0,0,,the functionality of X\Nand X does have to be
Dialogue: 0,0:54:17.60,0:54:21.76,Default,,0,0,0,,positive for this to work.\NAnd finally where
Dialogue: 0,0:54:21.76,0:54:24.80,Default,,0,0,0,,the eval function\Nis conveniently called match.
Dialogue: 0,0:54:24.80,0:54:26.28,Default,,0,0,0,,And so it looks,\Nthis looks very much like
Dialogue: 0,0:54:26.28,0:54:27.68,Default,,0,0,0,,an idiomatic recursion.\NNow, here, we're doing
Dialogue: 0,0:54:27.68,0:54:30.52,Default,,0,0,0,,something it'd be tough\Nto do in other type theories
Dialogue: 0,0:54:30.52,0:54:32.76,Default,,0,0,0,,where passing the recursive
Dialogue: 0,0:54:32.76,0:54:36.32,Default,,0,0,0,,the recursive function match\Nthere to the helper
Dialogue: 0,0:54:36.32,0:54:38.20,Default,,0,0,0,,function matchi,\Nbut anyway,
Dialogue: 0,0:54:38.20,0:54:40.88,Default,,0,0,0,,that match is the eval\Nand it has the type below
Dialogue: 0,0:54:40.88,0:54:42.84,Default,,0,0,0,,it takes in the abstract type R\Nwhich here is denoted
Dialogue: 0,0:54:42.84,0:54:45.92,Default,,0,0,0,,type/match and proceeds.
Dialogue: 0,0:54:45.92,0:54:49.00,Default,,0,0,0,,OK. So that's sort\Nof the setup for the recursion,
Dialogue: 0,0:54:49.00,0:54:51.60,Default,,0,0,0,,introducing, the recursion\Nuniverse pieces
Dialogue: 0,0:54:51.60,0:54:55.36,Default,,0,0,0,,that we then need\Nto write this helper function
Dialogue: 0,0:54:55.36,0:54:58.40,Default,,0,0,0,,and make that deal with that\None nasty recursive call.
Dialogue: 0,0:54:58.40,0:55:00.72,Default,,0,0,0,,So you can see\Nhighlighted here,
Dialogue: 0,0:55:00.72,0:55:02.56,Default,,0,0,0,,it's transliterated\Ninto Cedille.
Dialogue: 0,0:55:02.56,0:55:04.64,Default,,0,0,0,,I hope you can sort of\Nstill make out the structure.
Dialogue: 0,0:55:04.64,0:55:07.96,Default,,0,0,0,,We have a plus R case\Nand that I pulled out here
Dialogue: 0,0:55:07.96,0:55:09.92,Default,,0,0,0,,and we were gonna\Nmake this recursive call
Dialogue: 0,0:55:09.92,0:55:14.92,Default,,0,0,0,,to check one\Noccurrence of R,
Dialogue: 0,0:55:14.92,0:55:16.80,Default,,0,0,0,,and, then in the end,\Nwhen we make
Dialogue: 0,0:55:16.80,0:55:19.76,Default,,0,0,0,,the recursive call\Nwe're calling and match cs prime,
Dialogue: 0,0:55:19.76,0:55:22.08,Default,,0,0,0,,and that's great,\Nthis match function is,
Dialogue: 0,0:55:22.08,0:55:24.84,Default,,0,0,0,,is actually coming in to matchi\NAs you saw it,
Dialogue: 0,0:55:24.84,0:55:27.00,Default,,0,0,0,,where matchi was invoked\Nin my previous slide,
Dialogue: 0,0:55:27.00,0:55:28.80,Default,,0,0,0,,this match functions\Ncoming into matchi
Dialogue: 0,0:55:28.80,0:55:31.08,Default,,0,0,0,,and it's expecting type T\Nwhere T is actually
Dialogue: 0,0:55:31.08,0:55:32.28,Default,,0,0,0,,just some abstract type.\NYou really don't need
Dialogue: 0,0:55:32.28,0:55:35.36,Default,,0,0,0,,to know much about it,\Nexcept we can recurse on it.
Dialogue: 0,0:55:35.36,0:55:36.92,Default,,0,0,0,,If you're looking\Nat the type signature
Dialogue: 0,0:55:36.92,0:55:39.12,Default,,0,0,0,,of matchi at the top,\Nwe can recurse on it.
Dialogue: 0,0:55:39.12,0:55:42.40,Default,,0,0,0,,And the suffix comes\Nin at that time.
Dialogue: 0,0:55:42.40,0:55:46.08,Default,,0,0,0,,And so when we call\Nmatch of CS prime, match
Dialogue: 0,0:55:46.08,0:55:49.04,Default,,0,0,0,,is expecting input of type\NT and CS prime has type T
Dialogue: 0,0:55:49.04,0:55:51.96,Default,,0,0,0,,because CS prime\Nis the input to the continuation.
Dialogue: 0,0:55:51.96,0:55:53.80,Default,,0,0,0,,And the continuation\Nis denoted there
Dialogue: 0,0:55:53.80,0:55:58.96,Default,,0,0,0,,in blue has type KT,\Nwhich is T to bool.
Dialogue: 0,0:55:58.96,0:56:00.88,Default,,0,0,0,,OK. So to conclude,\Nwe've talked about
Dialogue: 0,0:56:00.88,0:56:02.84,Default,,0,0,0,,Harper's regular\Nexpression matcher,
Dialogue: 0,0:56:02.84,0:56:05.88,Default,,0,0,0,,which uses continuations\Nfor very elegant control flow
Dialogue: 0,0:56:05.88,0:56:08.72,Default,,0,0,0,,that leads to complications\Nfor termination reasoning.
Dialogue: 0,0:56:08.72,0:56:11.96,Default,,0,0,0,,And we saw a solution now using\Nstrong functional programming
Dialogue: 0,0:56:11.96,0:56:13.72,Default,,0,0,0,,in Cedille,\Nit's type based.
Dialogue: 0,0:56:13.72,0:56:15.64,Default,,0,0,0,,There's no fancy,\Nextra additions
Dialogue: 0,0:56:15.64,0:56:18.64,Default,,0,0,0,,beyond regular types\Nof functional programming,
Dialogue: 0,0:56:18.64,0:56:20.08,Default,,0,0,0,,no dependent types,\Nnothing like that,
Dialogue: 0,0:56:20.08,0:56:22.92,Default,,0,0,0,,even though Cedille\Ndoes support those separately.
Dialogue: 0,0:56:22.92,0:56:26.36,Default,,0,0,0,,So we use this idea\Nof a recursion universe that,
Dialogue: 0,0:56:26.36,0:56:29.92,Default,,0,0,0,,that gives you a form\Nof type based nested
Dialogue: 0,0:56:29.92,0:56:32.28,Default,,0,0,0,,paramorphic recursion.\NAnd it turns out that
Dialogue: 0,0:56:32.28,0:56:34.76,Default,,0,0,0,,Harper's matcher is just\Na perfect fit for this.
Dialogue: 0,0:56:34.76,0:56:36.16,Default,,0,0,0,,It's very easy.\NWe don't have time
Dialogue: 0,0:56:36.16,0:56:37.72,Default,,0,0,0,,to wade through\Nall the code,
Dialogue: 0,0:56:37.72,0:56:40.92,Default,,0,0,0,,but it's really pretty much\Na direct port of the
Dialogue: 0,0:56:40.92,0:56:42.92,Default,,0,0,0,,Haskell code\Nbecause of the way
Dialogue: 0,0:56:42.92,0:56:45.60,Default,,0,0,0,,that the abstract type\Nfor the eval function
Dialogue: 0,0:56:45.60,0:56:47.64,Default,,0,0,0,,matches up perfectly\Nwith the inputs
Dialogue: 0,0:56:47.64,0:56:51.52,Default,,0,0,0,,for the continuation.\NSo thanks very much to funders,
Dialogue: 0,0:56:51.52,0:56:54.00,Default,,0,0,0,,and I'd really like to thank\Nthe very dedicated
Dialogue: 0,0:56:54.00,0:56:55.88,Default,,0,0,0,,anonymous ICFP reviewers\Nwho gave us
Dialogue: 0,0:56:55.88,0:56:58.36,Default,,0,0,0,,outstanding really\Nabove and beyond
Dialogue: 0,0:56:58.36,0:57:00.76,Default,,0,0,0,,kind of criticism\Nand help getting this
Dialogue: 0,0:57:00.76,0:57:04.28,Default,,0,0,0,,into good shape\Nand shepherd Richard Eisenberg
Dialogue: 0,0:57:04.28,0:57:06.16,Default,,0,0,0,,and colleagues\Nhere at Iowa.
Dialogue: 0,0:57:06.16,0:57:08.44,Default,,0,0,0,,And thanks to you\Nfor watching.
Dialogue: 0,0:57:08.44,0:57:15.76,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,0:57:16.44,0:57:17.52,Default,,0,0,0,,RICHARD: Great,\Nthanks, Aaron.
Dialogue: 0,0:57:17.52,0:57:20.12,Default,,0,0,0,,And now in the New York\Nand Asia time band,
Dialogue: 0,0:57:20.12,0:57:22.36,Default,,0,0,0,,we have authors available\Nfor question and answer.
Dialogue: 0,0:57:22.36,0:57:24.00,Default,,0,0,0,,So please follow\Nthe links via Clowdr,
Dialogue: 0,0:57:24.00,0:57:26.04,Default,,0,0,0,,if you wish to join them.\NWe'll take a brief pause
Dialogue: 0,0:57:26.04,0:57:29.88,Default,,0,0,0,,until the next talk at 11:45\Nin the New York time band.
Dialogue: 0,0:58:01.96,0:58:05.88,Default,,0,0,0,,Next up we have Nandor Licker\Nwho will present Duplo,
Dialogue: 0,0:58:05.88,0:58:10.04,Default,,0,0,0,,a framework for\NOcaml post-link optimization.
Dialogue: 0,0:58:10.68,0:58:12.56,Default,,0,0,0,,NANDOR LICKER: Hello,\Nmy name is Nandor Licker
Dialogue: 0,0:58:12.56,0:58:15.16,Default,,0,0,0,,And today I'm going to talk\Nabout Duplo a framework
Dialogue: 0,0:58:15.16,0:58:18.96,Default,,0,0,0,,for Ocaml post link optimization.\NI built with Dr. Tim Jones
Dialogue: 0,0:58:18.96,0:58:21.32,Default,,0,0,0,,at the university of Cambridge.
Dialogue: 0,0:58:21.32,0:58:23.24,Default,,0,0,0,,Why build a post link optimizer?
Dialogue: 0,0:58:23.24,0:58:26.20,Default,,0,0,0,,And why build one\Nfor Ocaml in particular.
Dialogue: 0,0:58:26.20,0:58:28.64,Default,,0,0,0,,Ocaml is a high level language,\Nwhich means that it is not
Dialogue: 0,0:58:28.64,0:58:31.80,Default,,0,0,0,,well suited for expressing\Nspecific low-level constructs
Dialogue: 0,0:58:31.80,0:58:34.40,Default,,0,0,0,,as an example,\Nwe consider a simple type
Dialogue: 0,0:58:34.40,0:58:36.84,Default,,0,0,0,,to represent complex numbers,\Ncomposed of an imaginary
Dialogue: 0,0:58:36.84,0:58:39.16,Default,,0,0,0,,and a real component.\NIf we declare
Dialogue: 0,0:58:39.16,0:58:40.76,Default,,0,0,0,,a complex number\Nas a pair of floats,
Dialogue: 0,0:58:40.76,0:58:43.04,Default,,0,0,0,,we ended up\Nwith many allocations,
Dialogue: 0,0:58:43.04,0:58:45.16,Default,,0,0,0,,even though we only care\Nabout eight bytes of data
Dialogue: 0,0:58:45.16,0:58:48.16,Default,,0,0,0,,to store two 32 bit floats,\Nthe object will be spread
Dialogue: 0,0:58:48.16,0:58:51.56,Default,,0,0,0,,across 56 bytes\Nand three distinct allocations
Dialogue: 0,0:58:51.56,0:58:54.84,Default,,0,0,0,,producing three distinct blocks\Non the heap.
Dialogue: 0,0:58:54.84,0:58:57.32,Default,,0,0,0,,Ideally, we'd like\Na single block with a header
Dialogue: 0,0:58:57.32,0:59:00.76,Default,,0,0,0,,and eight bytes of data.\NSo how do we get there?
Dialogue: 0,0:59:00.76,0:59:03.24,Default,,0,0,0,,We can write a lot of code,\Npossibly fiddling with bits
Dialogue: 0,0:59:03.24,0:59:04.92,Default,,0,0,0,,and express the type\Nin Ocaml.
Dialogue: 0,0:59:04.92,0:59:08.16,Default,,0,0,0,,However, the solution\Nis unlikely to be elegant.
Dialogue: 0,0:59:08.16,0:59:11.04,Default,,0,0,0,,We could also change\Nthe runtime or the compiler.
Dialogue: 0,0:59:11.04,0:59:13.32,Default,,0,0,0,,However, this is not\Npractical nor scalable,
Dialogue: 0,0:59:13.32,0:59:15.80,Default,,0,0,0,,and could become\Na maintenance nightmare.
Dialogue: 0,0:59:15.80,0:59:17.40,Default,,0,0,0,,We choose to instead\Nuse an existing
Dialogue: 0,0:59:17.40,0:59:20.80,Default,,0,0,0,,language feature namely\Nthe foreign function interface,
Dialogue: 0,0:59:20.80,0:59:24.52,Default,,0,0,0,,the FFI allows us to use\Nthe right tool for the right job.
Dialogue: 0,0:59:24.52,0:59:26.32,Default,,0,0,0,,We can express\Nlow level constructs
Dialogue: 0,0:59:26.32,0:59:29.36,Default,,0,0,0,,in C and call them\Nfrom Ocaml.
Dialogue: 0,0:59:29.92,0:59:33.04,Default,,0,0,0,,The FFI of Ocaml\Nis particularly powerful.
Dialogue: 0,0:59:33.04,0:59:37.00,Default,,0,0,0,,Thanks to its minimal runtime\Nand simple object representation.
Dialogue: 0,0:59:37.00,0:59:39.20,Default,,0,0,0,,This allows us\Nto read arbitrary objects
Dialogue: 0,0:59:39.20,0:59:41.56,Default,,0,0,0,,from the Ocaml heap\Nand also to allocate
Dialogue: 0,0:59:41.56,0:59:44.32,Default,,0,0,0,,arbitrary objects\Non the Ocaml heap.
Dialogue: 0,0:59:44.32,0:59:47.12,Default,,0,0,0,,Such features allow the FFI\Nto be flexible enough
Dialogue: 0,0:59:47.12,0:59:50.76,Default,,0,0,0,,to build a wide variety\Nof types and functions.
Dialogue: 0,0:59:50.76,0:59:53.64,Default,,0,0,0,,However, the FFI\Ndoes not come for free.
Dialogue: 0,0:59:53.64,0:59:56.72,Default,,0,0,0,,Besides the implicit trampolines\Nthat heap management code
Dialogue: 0,0:59:56.72,0:59:59.00,Default,,0,0,0,,requires to invoke\NC from Ocaml,
Dialogue: 0,0:59:59.00,1:00:02.48,Default,,0,0,0,,we pay the cost of missed\Noptimization opportunities.
Dialogue: 0,1:00:02.48,1:00:05.60,Default,,0,0,0,,In the typical build, Ocaml\Nand C meet in assembly
Dialogue: 0,1:00:05.60,1:00:08.64,Default,,0,0,0,,and the linker unfortunately\Nhigh level transformations
Dialogue: 0,1:00:08.64,1:00:11.00,Default,,0,0,0,,in machine code\Nare far from trivial.
Dialogue: 0,1:00:11.00,1:00:14.60,Default,,0,0,0,,We need a common form,\Nmore suitable for analysis,
Dialogue: 0,1:00:14.60,1:00:17.20,Default,,0,0,0,,ideally, a representation\Nthat has not yet gone
Dialogue: 0,1:00:17.20,1:00:21.08,Default,,0,0,0,,through register allocation\Nnor instruction selection.
Dialogue: 0,1:00:21.08,1:00:25.40,Default,,0,0,0,,So the goal of Duplo is to\Nameliorate this FFI overhead
Dialogue: 0,1:00:25.40,1:00:27.76,Default,,0,0,0,,and to lose the overhead,\Nwe want to optimize
Dialogue: 0,1:00:27.76,1:00:30.52,Default,,0,0,0,,across the language boundary.\NHowever, on one side,
Dialogue: 0,1:00:30.52,1:00:32.92,Default,,0,0,0,,we have a Ocaml\Nand C on the other.
Dialogue: 0,1:00:32.92,1:00:35.68,Default,,0,0,0,,Two very different languages\Nwith different memory models
Dialogue: 0,1:00:35.68,1:00:39.12,Default,,0,0,0,,and different run times.\NIn order to apply
Dialogue: 0,1:00:39.12,1:00:41.16,Default,,0,0,0,,any optimizations,\Nwe need to first find
Dialogue: 0,1:00:41.16,1:00:43.16,Default,,0,0,0,,a common denominator\Ncapable of capturing
Dialogue: 0,1:00:43.16,1:00:46.48,Default,,0,0,0,,the semantics of both\NC and Ocaml.
Dialogue: 0,1:00:46.48,1:00:48.44,Default,,0,0,0,,Duplo achieves this\Nwith representation,
Dialogue: 0,1:00:48.44,1:00:52.20,Default,,0,0,0,,we call LLIR, low level\Nintermediate representation.
Dialogue: 0,1:00:52.20,1:00:54.40,Default,,0,0,0,,The framework provides\Na custom version
Dialogue: 0,1:00:54.40,1:00:57.52,Default,,0,0,0,,of (INAUDIBLE) to LLIR\Na custom version
Dialogue: 0,1:00:57.52,1:01:00.64,Default,,0,0,0,,of the Ocaml compiler\Nto lower Ocaml to LLIR
Dialogue: 0,1:01:00.64,1:01:03.16,Default,,0,0,0,,and an entire tool chain\Nturning LLIR modules
Dialogue: 0,1:01:03.16,1:01:06.56,Default,,0,0,0,,into a single module containing\Nwhole program information.
Dialogue: 0,1:01:06.56,1:01:09.52,Default,,0,0,0,,And finally an optimizer,\Nwhich we call LLIR opt
Dialogue: 0,1:01:09.52,1:01:11.68,Default,,0,0,0,,to analyze and transform\Nthe program
Dialogue: 0,1:01:11.68,1:01:15.12,Default,,0,0,0,,before lowering it\Nto executable machine code.
Dialogue: 0,1:01:15.96,1:01:19.00,Default,,0,0,0,,LLIR is the central\Ncomponent of our project.
Dialogue: 0,1:01:19.00,1:01:21.80,Default,,0,0,0,,It is built to be easy to optimize.\NIt is in SSA form
Dialogue: 0,1:01:21.80,1:01:24.40,Default,,0,0,0,,has virtual registers,\Nsimple instructions
Dialogue: 0,1:01:24.40,1:01:27.40,Default,,0,0,0,,and primitive types\Nwith direct hardware equivalents,
Dialogue: 0,1:01:27.40,1:01:30.68,Default,,0,0,0,,even though it is not LLVM IR\Nit's in their representation
Dialogue: 0,1:01:30.68,1:01:34.52,Default,,0,0,0,,in C++ is almost\Nidentical to LLVM IR.
Dialogue: 0,1:01:34.52,1:01:37.64,Default,,0,0,0,,Mirroring several useful methods\Nand we're using support libraries,
Dialogue: 0,1:01:37.64,1:01:39.76,Default,,0,0,0,,including valuable functions\Nand iterators
Dialogue: 0,1:01:39.76,1:01:43.16,Default,,0,0,0,,such as dominator reconstruction.\NAnd (INAUDIBLE) traversals.
Dialogue: 0,1:01:43.16,1:01:45.48,Default,,0,0,0,,We find a cool style\Nof our transformations
Dialogue: 0,1:01:45.48,1:01:48.00,Default,,0,0,0,,to be quite similar\Nto that of LLVM.
Dialogue: 0,1:01:48.00,1:01:50.68,Default,,0,0,0,,And this familiarity\Nis highly valuable.
Dialogue: 0,1:01:50.68,1:01:54.84,Default,,0,0,0,,Despite some similarities LLVM\Nis definitely not LLVM IR.
Dialogue: 0,1:01:54.84,1:01:58.52,Default,,0,0,0,,It is less abstract\Nand a lot closer to hardware.
Dialogue: 0,1:01:59.40,1:02:01.80,Default,,0,0,0,,Why is LLIR low level?
Dialogue: 0,1:02:01.80,1:02:04.00,Default,,0,0,0,,This choice is almost\Nentirely constrained
Dialogue: 0,1:02:04.00,1:02:06.24,Default,,0,0,0,,by the Ocaml compiler\Nand the intermediate
Dialogue: 0,1:02:06.24,1:02:09.36,Default,,0,0,0,,representations found in clang.\NOcaml first compiles
Dialogue: 0,1:02:09.36,1:02:10.88,Default,,0,0,0,,to Lambda form\Nwith closures,
Dialogue: 0,1:02:10.88,1:02:13.32,Default,,0,0,0,,which have no direct\Nequivalent in LLVM.
Dialogue: 0,1:02:13.32,1:02:16.92,Default,,0,0,0,,Requires to step one level down\Nin the Ocaml compiler.
Dialogue: 0,1:02:16.92,1:02:19.28,Default,,0,0,0,,The next step is CMM,\Nwhich still has
Dialogue: 0,1:02:19.28,1:02:20.92,Default,,0,0,0,,some high level features.\NSo we need to go
Dialogue: 0,1:02:20.92,1:02:23.56,Default,,0,0,0,,down another level.\NWe are left with building
Dialogue: 0,1:02:23.56,1:02:26.52,Default,,0,0,0,,LLIR from Mach Linear,\Nwhich are essentially
Dialogue: 0,1:02:26.52,1:02:28.32,Default,,0,0,0,,equivalent to machine code,
Dialogue: 0,1:02:28.32,1:02:31.12,Default,,0,0,0,,LLVM IR is more\Nabstract than that.
Dialogue: 0,1:02:31.12,1:02:33.52,Default,,0,0,0,,We need to lower it\Na bit in LLVM.
Dialogue: 0,1:02:33.52,1:02:38.52,Default,,0,0,0,,Conveniently, we defined LLIR\Nto be almost like machine code.
Dialogue: 0,1:02:38.52,1:02:41.64,Default,,0,0,0,,We lower LLVM IR\Nto LLIR to the target
Dialogue: 0,1:02:41.64,1:02:44.04,Default,,0,0,0,,specific back end of LLVM\Npassing through
Dialogue: 0,1:02:44.04,1:02:47.56,Default,,0,0,0,,selection DAG and LLIR\Nspecific machine IR.
Dialogue: 0,1:02:47.56,1:02:49.96,Default,,0,0,0,,On the Ocaml side.\NWe generate LLIR
Dialogue: 0,1:02:49.96,1:02:52.64,Default,,0,0,0,,from linear as the mapping\Nis almost one to one.
Dialogue: 0,1:02:52.64,1:02:54.36,Default,,0,0,0,,We are essentially\Ncross-compiling
Dialogue: 0,1:02:54.36,1:02:57.80,Default,,0,0,0,,to a new target\Nin both compilers.
Dialogue: 0,1:02:57.80,1:03:01.68,Default,,0,0,0,,Getting to LLIR\Nis only the start of the journey.
Dialogue: 0,1:03:01.68,1:03:04.00,Default,,0,0,0,,We also need to generate\Nmachine code from LLIR.
Dialogue: 0,1:03:04.00,1:03:06.52,Default,,0,0,0,,And this step is not trivial.\NCode generators
Dialogue: 0,1:03:06.52,1:03:09.24,Default,,0,0,0,,tend to be complex\Npieces of code
Dialogue: 0,1:03:09.24,1:03:11.64,Default,,0,0,0,,and Ocaml has run time\Nand a garbage collector
Dialogue: 0,1:03:11.64,1:03:13.76,Default,,0,0,0,,that we do not wish\Nto alter that imposes
Dialogue: 0,1:03:13.76,1:03:16.44,Default,,0,0,0,,further constraints.\NSince our tool chain
Dialogue: 0,1:03:16.44,1:03:18.52,Default,,0,0,0,,already includes clang\NWe decided to use
Dialogue: 0,1:03:18.52,1:03:21.04,Default,,0,0,0,,the LLVM code generator\Nfrom its selection diagram
Dialogue: 0,1:03:21.04,1:03:22.52,Default,,0,0,0,,presentation onwards.
Dialogue: 0,1:03:22.52,1:03:24.36,Default,,0,0,0,,We have added\Ncustom instructions
Dialogue: 0,1:03:24.36,1:03:27.32,Default,,0,0,0,,required by the Ocaml GC\Nwe're using the entirety
Dialogue: 0,1:03:27.32,1:03:30.52,Default,,0,0,0,,of the target-specific\Nmachine IR pipeline.
Dialogue: 0,1:03:31.08,1:03:34.16,Default,,0,0,0,,Since we cross compile C to LLIR,\Nwe have a mapping
Dialogue: 0,1:03:34.16,1:03:37.36,Default,,0,0,0,,from a selection DAG to LLIR,\Nin our back end,
Dialogue: 0,1:03:37.36,1:03:41.96,Default,,0,0,0,,we map LLIR to selection DAG\Ndue to the circular dependency.
Dialogue: 0,1:03:41.96,1:03:44.72,Default,,0,0,0,,Most of the LLIR instructions\Nhave a direct correspondent
Dialogue: 0,1:03:44.72,1:03:46.76,Default,,0,0,0,,in selection DAG\Nwith the exception
Dialogue: 0,1:03:46.76,1:03:48.48,Default,,0,0,0,,of some more\Ncomplex constructs,
Dialogue: 0,1:03:48.48,1:03:51.24,Default,,0,0,0,,such as function calls\Nand 80 bits floats.
Dialogue: 0,1:03:51.24,1:03:56.20,Default,,0,0,0,,Simple instructions such as\Nadd, subtract, multiply, and so on.
Dialogue: 0,1:03:56.20,1:03:57.88,Default,,0,0,0,,Do not really warrant\Na custom mapping
Dialogue: 0,1:03:57.88,1:04:00.12,Default,,0,0,0,,from selection DAG\Nto LLIR, nor from
Dialogue: 0,1:04:00.12,1:04:04.76,Default,,0,0,0,,LLIR to selection DAG.\NSo, we simply map selection DAG,
Dialogue: 0,1:04:04.76,1:04:07.80,Default,,0,0,0,,to LLIR instruction,\Nand LLIR instruction
Dialogue: 0,1:04:07.80,1:04:10.52,Default,,0,0,0,,back to selection DAG\Nbut function calls
Dialogue: 0,1:04:10.52,1:04:16.20,Default,,0,0,0,,are specific to each target.\NAnd even in all of LLVM's back end,
Dialogue: 0,1:04:16.20,1:04:20.44,Default,,0,0,0,,they require a custom mapping\Nfrom LLVM IR to selection DAG,
Dialogue: 0,1:04:20.44,1:04:23.44,Default,,0,0,0,,and we have that mapping\Nfor LLIR as well.
Dialogue: 0,1:04:23.44,1:04:25.40,Default,,0,0,0,,And because\Nof these constraints,
Dialogue: 0,1:04:25.40,1:04:26.76,Default,,0,0,0,,we actually had\Nvery little freedom
Dialogue: 0,1:04:26.76,1:04:30.88,Default,,0,0,0,,when designing\Nour new representation.
Dialogue: 0,1:04:32.16,1:04:33.84,Default,,0,0,0,,Probably the most\Npressing question
Dialogue: 0,1:04:33.84,1:04:37.92,Default,,0,0,0,,is why not lower to LLVM IR.\NPrevious attempts
Dialogue: 0,1:04:37.92,1:04:39.84,Default,,0,0,0,,made some progress\Nalbeit with
Dialogue: 0,1:04:39.84,1:04:41.88,Default,,0,0,0,,a run time cost,\NOcaml is not
Dialogue: 0,1:04:41.88,1:04:44.08,Default,,0,0,0,,an easy language\Nto map to LLVM
Dialogue: 0,1:04:44.08,1:04:46.24,Default,,0,0,0,,it's exception handling\Nrequires explicit
Dialogue: 0,1:04:46.24,1:04:48.92,Default,,0,0,0,,stack manipulation\NOcaml also has
Dialogue: 0,1:04:48.92,1:04:50.56,Default,,0,0,0,,a shadow stack\Nfor root pointers.
Dialogue: 0,1:04:50.56,1:04:52.92,Default,,0,0,0,,This aspect is crucial\Nfor performance
Dialogue: 0,1:04:52.92,1:04:55.72,Default,,0,0,0,,while LLVM offers some support\Nfor garbage collectors.
Dialogue: 0,1:04:55.72,1:04:58.08,Default,,0,0,0,,It does not get\Na specific to the needs
Dialogue: 0,1:04:58.08,1:05:01.16,Default,,0,0,0,,of Ocaml. Through Duplo\Nwe made significant progress though.
Dialogue: 0,1:05:01.16,1:05:03.16,Default,,0,0,0,,We have added\Nthe required instruction
Dialogue: 0,1:05:03.16,1:05:06.68,Default,,0,0,0,,to a single portion\Nof the target specific pipeline
Dialogue: 0,1:05:06.68,1:05:09.12,Default,,0,0,0,,in order to handle\Nthe frame tables used by the,
Dialogue: 0,1:05:09.12,1:05:13.28,Default,,0,0,0,,the default Ocaml\Ngarbage collector and run time.
Dialogue: 0,1:05:13.28,1:05:16.48,Default,,0,0,0,,However, to achieve\Nthe same ideal at the LLVM IR level,
Dialogue: 0,1:05:16.48,1:05:19.72,Default,,0,0,0,,extensive changes\Nare required.
Dialogue: 0,1:05:21.84,1:05:24.72,Default,,0,0,0,,To illustrate LLIR,\Nwe can look at the simple methods
Dialogue: 0,1:05:24.72,1:05:26.92,Default,,0,0,0,,in LLIR form,\Nwhich confused the magnitude
Dialogue: 0,1:05:26.92,1:05:30.24,Default,,0,0,0,,of a vector allocated\Non your Ocaml heap.
Dialogue: 0,1:05:30.24,1:05:32.64,Default,,0,0,0,,It reads an argument,\Na pointer to a pair
Dialogue: 0,1:05:32.64,1:05:34.92,Default,,0,0,0,,using an arg instruction.\NIndividual elements
Dialogue: 0,1:05:34.92,1:05:37.52,Default,,0,0,0,,are loaded using LD\Nfrom offsets computed
Dialogue: 0,1:05:37.52,1:05:40.92,Default,,0,0,0,,using basic pointer arithmetic,\Nthe elements of squared
Dialogue: 0,1:05:40.92,1:05:44.32,Default,,0,0,0,,using the multiply instruction,\Nare passed on to the sqrt function
Dialogue: 0,1:05:44.32,1:05:46.00,Default,,0,0,0,,before being boxed\Ninto a heap allocated.
Dialogue: 0,1:05:46.64,1:05:49.00,Default,,0,0,0,,block, we can\Nnotice the annotations,
Dialogue: 0,1:05:49.00,1:05:50.96,Default,,0,0,0,,the Ocaml runtime requires us
Dialogue: 0,1:05:50.96,1:05:53.12,Default,,0,0,0,,to identify all heap pointers,
Dialogue: 0,1:05:53.12,1:05:54.76,Default,,0,0,0,,which we do using @camel_value.
Dialogue: 0,1:05:54.76,1:05:57.20,Default,,0,0,0,,And emit frame tables\Ndescribing those which are live
Dialogue: 0,1:05:57.20,1:05:59.28,Default,,0,0,0,,across call sites that can allocate,
Dialogue: 0,1:05:59.28,1:06:03.16,Default,,0,0,0,,all marked through @caml_frame.
Dialogue: 0,1:06:03.16,1:06:04.84,Default,,0,0,0,,Finding a common representation
Dialogue: 0,1:06:04.84,1:06:06.80,Default,,0,0,0,,is the only part of the problem.
Dialogue: 0,1:06:06.80,1:06:10.08,Default,,0,0,0,,In this representation,\Noptimizations,
Dialogue: 0,1:06:10.08,1:06:13.16,Default,,0,0,0,,opportunities to prefer\Noptimizations should be scarce
Dialogue: 0,1:06:13.16,1:06:15.52,Default,,0,0,0,,Ocaml should have\Nalready optimized everything
Dialogue: 0,1:06:15.52,1:06:18.68,Default,,0,0,0,,LLVM should have also\Noptimized everything,
Dialogue: 0,1:06:18.68,1:06:20.72,Default,,0,0,0,,and we are left with\Nthe nontrivial task
Dialogue: 0,1:06:20.72,1:06:22.60,Default,,0,0,0,,of identifying optimization\Nopportunities
Dialogue: 0,1:06:22.60,1:06:24.60,Default,,0,0,0,,that are exposed only when both Ocaml
Dialogue: 0,1:06:24.60,1:06:27.16,Default,,0,0,0,,and C sources are present.
Dialogue: 0,1:06:27.16,1:06:28.84,Default,,0,0,0,,Naturally, the first step is
Dialogue: 0,1:06:28.84,1:06:32.00,Default,,0,0,0,,to create optimization\Nopportunities for other steps.
Dialogue: 0,1:06:32.00,1:06:33.60,Default,,0,0,0,,Inlining achieves this,
Dialogue: 0,1:06:33.60,1:06:35.44,Default,,0,0,0,,unfortunately, inlining\Nin this context
Dialogue: 0,1:06:35.44,1:06:39.04,Default,,0,0,0,,is not as simple as copying\Na body into a callee.
Dialogue: 0,1:06:39.04,1:06:42.04,Default,,0,0,0,,The world is split into two\Nrealms: Ocaml and C,
Dialogue: 0,1:06:42.04,1:06:43.84,Default,,0,0,0,,the two communicate through a trampoline
Dialogue: 0,1:06:43.84,1:06:47.48,Default,,0,0,0,,recording vital information\Nfor the runtime.
Dialogue: 0,1:06:47.48,1:06:49.48,Default,,0,0,0,,When we inline C into Ocaml,
Dialogue: 0,1:06:49.48,1:06:51.48,Default,,0,0,0,,we actually create\Na bigger Ocaml function
Dialogue: 0,1:06:51.48,1:06:53.28,Default,,0,0,0,,and push the trampolines down.
Dialogue: 0,1:06:53.28,1:06:56.08,Default,,0,0,0,,Even though G initially called\NF without a trampoline,
Dialogue: 0,1:06:56.08,1:07:00.28,Default,,0,0,0,,after in-lining, it requires\None, each kind of allocation,
Dialogue: 0,1:07:00.28,1:07:03.12,Default,,0,0,0,,doesn't need one, in Ocaml FF,
Dialogue: 0,1:07:03.12,1:07:04.48,Default,,0,0,0,,we are left with a mess.
Dialogue: 0,1:07:04.48,1:07:07.08,Default,,0,0,0,,The function now tracks heap\Nroots using both Ocaml values
Dialogue: 0,1:07:07.08,1:07:12.08,Default,,0,0,0,,and the specific root measurement\Nmechanism specific to C.
Dialogue: 0,1:07:12.08,1:07:14.24,Default,,0,0,0,,In the future, we aim to\Naddress this problem
Dialogue: 0,1:07:14.24,1:07:16.68,Default,,0,0,0,,by moving roots over to\Nthe Ocaml value mechanism.
Dialogue: 0,1:07:16.68,1:07:18.44,Default,,0,0,0,,This is a great improvement
Dialogue: 0,1:07:18.44,1:07:21.56,Default,,0,0,0,,since it eliminates the upfront\Ncost of root management,
Dialogue: 0,1:07:21.56,1:07:24.40,Default,,0,0,0,,that's necessary in C.
Dialogue: 0,1:07:24.40,1:07:26.40,Default,,0,0,0,,As your global information,\Nin the future,
Dialogue: 0,1:07:26.40,1:07:28.00,Default,,0,0,0,,we will also build to\Nmove C functions,
Dialogue: 0,1:07:28.00,1:07:30.28,Default,,0,0,0,,which allocate over\Nto the Ocaml realm.
Dialogue: 0,1:07:30.28,1:07:32.60,Default,,0,0,0,,First simplify manual\Nroot management,
Dialogue: 0,1:07:32.60,1:07:36.08,Default,,0,0,0,,and possibly ending up on\Nusing Ocaml value annotations
Dialogue: 0,1:07:36.08,1:07:38.68,Default,,0,0,0,,to identify roots.
Dialogue: 0,1:07:38.68,1:07:40.92,Default,,0,0,0,,While you're not there\Nyet, at some point,
Dialogue: 0,1:07:40.92,1:07:43.12,Default,,0,0,0,,we will be able to not care\Nabout whether our function
Dialogue: 0,1:07:43.12,1:07:46.28,Default,,0,0,0,,is Ocaml specific or C\Nspecific erasing the boundary
Dialogue: 0,1:07:46.28,1:07:48.88,Default,,0,0,0,,between the two heaps.
Dialogue: 0,1:07:48.88,1:07:50.20,Default,,0,0,0,,To illustrate some more problems,
Dialogue: 0,1:07:50.20,1:07:52.60,Default,,0,0,0,,we consider a function that\Nincrements of double,
Dialogue: 0,1:07:52.60,1:07:56.08,Default,,0,0,0,,unboxing a value, adding one\Nto it and boxing it back,
Dialogue: 0,1:07:56.08,1:07:58.56,Default,,0,0,0,,sending it back to the Ocaml heap.
Dialogue: 0,1:07:58.56,1:07:59.76,Default,,0,0,0,,After in-lining,
Dialogue: 0,1:07:59.76,1:08:02.64,Default,,0,0,0,,we see that the boxing\NOcaml copy double call
Dialogue: 0,1:08:02.64,1:08:06.44,Default,,0,0,0,,is now annotated,\Nand it has a trampoline.
Dialogue: 0,1:08:06.44,1:08:10.08,Default,,0,0,0,,But what happens if we inline\Ntwo consecutive invocations?
Dialogue: 0,1:08:10.08,1:08:14.12,Default,,0,0,0,,Unfortunately, we get the chain\Nof boxing unboxing steps.
Dialogue: 0,1:08:14.12,1:08:16.52,Default,,0,0,0,,This is expected\Nand quite unfortunate.
Dialogue: 0,1:08:16.52,1:08:19.08,Default,,0,0,0,,We are now faced with\Nthe nontrivial task
Dialogue: 0,1:08:19.08,1:08:22.92,Default,,0,0,0,,of understanding pointers\Nand blocks on the heap
Dialogue: 0,1:08:22.92,1:08:25.16,Default,,0,0,0,,to perform even\Na simple transformation,
Dialogue: 0,1:08:25.16,1:08:29.12,Default,,0,0,0,,such as constant propagation.
Dialogue: 0,1:08:29.12,1:08:31.68,Default,,0,0,0,,And the stage we are at in\Nthe pipeline does not help,
Dialogue: 0,1:08:31.68,1:08:32.84,Default,,0,0,0,,the common ground between C
Dialogue: 0,1:08:32.84,1:08:34.40,Default,,0,0,0,,and Ocaml memory\Nrepresentations
Dialogue: 0,1:08:34.40,1:08:36.36,Default,,0,0,0,,is not particularly verbose.
Dialogue: 0,1:08:36.36,1:08:38.72,Default,,0,0,0,,We can work only with the assumption
Dialogue: 0,1:08:38.72,1:08:40.20,Default,,0,0,0,,that pointers have stored
Dialogue: 0,1:08:40.20,1:08:43.52,Default,,0,0,0,,at addresses aligned to eight bytes.
Dialogue: 0,1:08:43.52,1:08:45.48,Default,,0,0,0,,We essentially have no\Ntype of information.
Dialogue: 0,1:08:45.48,1:08:48.32,Default,,0,0,0,,And if, even if we have\Ntype information,
Dialogue: 0,1:08:48.32,1:08:50.80,Default,,0,0,0,,due to the fact that C has unions,
Dialogue: 0,1:08:50.80,1:08:53.40,Default,,0,0,0,,the type information you could\Npossibly keep would be minimal,
Dialogue: 0,1:08:53.40,1:08:58.04,Default,,0,0,0,,and the only piece of\Ninformation we'll be left with
Dialogue: 0,1:08:58.04,1:09:02.48,Default,,0,0,0,,is this fact that pointers\Nare aligned to eight bytes,
Dialogue: 0,1:09:02.48,1:09:06.12,Default,,0,0,0,,which allows us to model\Nthe heap as bags of pointers
Dialogue: 0,1:09:06.12,1:09:08.96,Default,,0,0,0,,aligned as specific addresses.
Dialogue: 0,1:09:08.96,1:09:11.80,Default,,0,0,0,,As a proof of concept, we have\Nbuilt two transformations
Dialogue: 0,1:09:11.80,1:09:13.08,Default,,0,0,0,,working with pointers.
Dialogue: 0,1:09:13.08,1:09:17.20,Default,,0,0,0,,A local analysis to propagate\Nvalue store to memory
Dialogue: 0,1:09:17.20,1:09:18.68,Default,,0,0,0,,to loads reading them
Dialogue: 0,1:09:18.68,1:09:21.64,Default,,0,0,0,,and a global analysis to\Nidentify indirect call targets
Dialogue: 0,1:09:21.64,1:09:25.20,Default,,0,0,0,,essential for dead code elimination.
Dialogue: 0,1:09:25.20,1:09:27.44,Default,,0,0,0,,Presently, our optimizer\Nimplements a number
Dialogue: 0,1:09:27.44,1:09:29.40,Default,,0,0,0,,of classic transformations\Nwhich are required
Dialogue: 0,1:09:29.40,1:09:31.68,Default,,0,0,0,,mostly to eliminate inefficiencies
Dialogue: 0,1:09:31.68,1:09:35.52,Default,,0,0,0,,in the C, OCaml, LLIR lowering.
Dialogue: 0,1:09:35.52,1:09:38.00,Default,,0,0,0,,While we have exposed\Nmany new opportunities,
Dialogue: 0,1:09:38.00,1:09:40.40,Default,,0,0,0,,our goal for the moment\Nwas to implement
Dialogue: 0,1:09:40.40,1:09:42.44,Default,,0,0,0,,the minimal battery of\Ntransformations required
Dialogue: 0,1:09:42.44,1:09:45.56,Default,,0,0,0,,to emit code as fast as,
Dialogue: 0,1:09:45.56,1:09:49.80,Default,,0,0,0,,at least as fast as\Nit was emitted by,
Dialogue: 0,1:09:49.80,1:09:52.96,Default,,0,0,0,,OCaml and C previously.
Dialogue: 0,1:09:52.96,1:09:55.32,Default,,0,0,0,,The other transformations\Ninclude sparse condition
Dialogue: 0,1:09:55.32,1:09:56.48,Default,,0,0,0,,and constant propagation,
Dialogue: 0,1:09:56.48,1:09:59.76,Default,,0,0,0,,unreachable code elimination\Ncontrol flow simplification
Dialogue: 0,1:09:59.76,1:10:01.40,Default,,0,0,0,,and these are schedules\Nafter inlining
Dialogue: 0,1:10:01.40,1:10:04.16,Default,,0,0,0,,and simplify\Nthe program quite a bit.
Dialogue: 0,1:10:04.16,1:10:05.72,Default,,0,0,0,,Tail recursion elimination is vital.
Dialogue: 0,1:10:05.72,1:10:08.20,Default,,0,0,0,,LLVM cannot lower direct tail recursion
Dialogue: 0,1:10:08.20,1:10:09.96,Default,,0,0,0,,as effectively as OCaml,
Dialogue: 0,1:10:09.96,1:10:12.76,Default,,0,0,0,,but it generates identical code
Dialogue: 0,1:10:12.76,1:10:16.76,Default,,0,0,0,,if these functions are\Nturned into loops instead.
Dialogue: 0,1:10:16.76,1:10:19.20,Default,,0,0,0,,An interesting transformation\Nspecific to this context
Dialogue: 0,1:10:19.20,1:10:20.76,Default,,0,0,0,,is trampoline elimination.
Dialogue: 0,1:10:20.76,1:10:22.96,Default,,0,0,0,,OCaml requires a trampoline
Dialogue: 0,1:10:22.96,1:10:24.84,Default,,0,0,0,,to switch from\Nthe OCaml calling convention
Dialogue: 0,1:10:24.84,1:10:26.84,Default,,0,0,0,,to the C calling\Nconvention when invoking
Dialogue: 0,1:10:26.84,1:10:28.60,Default,,0,0,0,,a C method indirectly.
Dialogue: 0,1:10:28.60,1:10:30.76,Default,,0,0,0,,Since you have global information,
Dialogue: 0,1:10:30.76,1:10:32.72,Default,,0,0,0,,we can change the calling\Nconvention of C method
Dialogue: 0,1:10:32.72,1:10:34.32,Default,,0,0,0,,to the OCaml one,
Dialogue: 0,1:10:34.32,1:10:37.72,Default,,0,0,0,,completely eliminating\Nthese trampolines.
Dialogue: 0,1:10:37.72,1:10:38.84,Default,,0,0,0,,These transformations,
Dialogue: 0,1:10:38.84,1:10:42.60,Default,,0,0,0,,along with the LLVM code generator\Nprovide some benefit.
Dialogue: 0,1:10:42.60,1:10:44.76,Default,,0,0,0,,We benchmarked our optimizer\Non a subset of benchmarks
Dialogue: 0,1:10:44.76,1:10:47.16,Default,,0,0,0,,from operf-macro\Nand operf-micro.
Dialogue: 0,1:10:47.16,1:10:49.72,Default,,0,0,0,,Unfortunately, we did not yet\Nimplement some optimizations
Dialogue: 0,1:10:49.72,1:10:51.16,Default,,0,0,0,,performed by the OCaml compiler
Dialogue: 0,1:10:51.16,1:10:54.04,Default,,0,0,0,,which we have disabled in\Nour reference version.
Dialogue: 0,1:10:54.04,1:10:56.96,Default,,0,0,0,,We do not cache some\Nglobals in registers
Dialogue: 0,1:10:56.96,1:10:59.96,Default,,0,0,0,,and we do not inline allocations.
Dialogue: 0,1:10:59.96,1:11:01.96,Default,,0,0,0,,Despite these mitigations,
Dialogue: 0,1:11:01.96,1:11:05.56,Default,,0,0,0,,the relative results should\Nstill be relevant.
Dialogue: 0,1:11:05.56,1:11:07.64,Default,,0,0,0,,Our linker delivers\Na significant reduction
Dialogue: 0,1:11:07.64,1:11:09.48,Default,,0,0,0,,in code size while LLVM manages
Dialogue: 0,1:11:09.48,1:11:12.60,Default,,0,0,0,,to select better instructions\Nproviding some improvement
Dialogue: 0,1:11:12.60,1:11:13.88,Default,,0,0,0,,on large informations
Dialogue: 0,1:11:13.88,1:11:16.40,Default,,0,0,0,,and we're quite happy\Nabout these results.
Dialogue: 0,1:11:16.40,1:11:19.36,Default,,0,0,0,,When comparing\Nthe fact of the small set
Dialogue: 0,1:11:19.36,1:11:21.36,Default,,0,0,0,,of transformations we\Nhave implemented,
Dialogue: 0,1:11:21.36,1:11:23.44,Default,,0,0,0,,the effect is moderate.
Dialogue: 0,1:11:23.44,1:11:25.08,Default,,0,0,0,,There are not many opportunities
Dialogue: 0,1:11:25.08,1:11:26.88,Default,,0,0,0,,for cross-language optimization
Dialogue: 0,1:11:26.88,1:11:29.00,Default,,0,0,0,,as our in-line heuristics\Nand (INAUDIBLE) analysis
Dialogue: 0,1:11:29.00,1:11:30.44,Default,,0,0,0,,are quite primitive.
Dialogue: 0,1:11:30.44,1:11:33.36,Default,,0,0,0,,As an example, we currently\Ninline aggressively functions
Dialogue: 0,1:11:33.36,1:11:35.04,Default,,0,0,0,,which box or\Ndeconstruct arguments
Dialogue: 0,1:11:35.04,1:11:38.64,Default,,0,0,0,,in the hope of propagating\Nconstants through them.
Dialogue: 0,1:11:38.64,1:11:41.12,Default,,0,0,0,,In the future, we have to\Nbuild better heuristics
Dialogue: 0,1:11:41.12,1:11:42.72,Default,,0,0,0,,to base our inline decision on how,
Dialogue: 0,1:11:42.72,1:11:44.60,Default,,0,0,0,,for the purpose of this project,
Dialogue: 0,1:11:44.60,1:11:46.56,Default,,0,0,0,,the difficultly was in figuring out
Dialogue: 0,1:11:46.56,1:11:50.00,Default,,0,0,0,,how to do inlining\Nin the first place.
Dialogue: 0,1:11:50.00,1:11:51.68,Default,,0,0,0,,We do gain in performance a bit
Dialogue: 0,1:11:51.68,1:11:53.80,Default,,0,0,0,,by mitigating inefficiencies\Nin both back ends
Dialogue: 0,1:11:53.80,1:11:56.28,Default,,0,0,0,,and inlining some small\Nmethods through the
Dialogue: 0,1:11:56.28,1:12:00.36,Default,,0,0,0,,battery of transformations\Nwe have presented earlier.
Dialogue: 0,1:12:00.36,1:12:02.44,Default,,0,0,0,,To sum up, we have presented\Na Duplo framework
Dialogue: 0,1:12:02.44,1:12:03.84,Default,,0,0,0,,to inline C into OCaml,
Dialogue: 0,1:12:03.84,1:12:06.88,Default,,0,0,0,,analyzing and transforming\Nthe resulting code.
Dialogue: 0,1:12:06.88,1:12:09.12,Default,,0,0,0,,We built a new representation\Nto capture both
Dialogue: 0,1:12:09.12,1:12:12.28,Default,,0,0,0,,OCaml and C which we call LLIR.
Dialogue: 0,1:12:12.28,1:12:14.16,Default,,0,0,0,,Finally, as our code generator,
Dialogue: 0,1:12:14.16,1:12:16.96,Default,,0,0,0,,we assure how OCaml can be lowered
Dialogue: 0,1:12:16.96,1:12:18.52,Default,,0,0,0,,to part of the LLVM pipeline,
Dialogue: 0,1:12:18.52,1:12:21.76,Default,,0,0,0,,yielding and improving in\Ncode size and performance.
Dialogue: 0,1:12:21.76,1:12:29.72,Default,,0,0,0,,(CROWN APPLAUDS)
Dialogue: 0,1:12:29.72,1:12:31.96,Default,,0,0,0,,RICHARD: Thanks very much, Nandor,
Dialogue: 0,1:12:31.96,1:12:34.60,Default,,0,0,0,,who's now available in\Nthe New York Time Band
Dialogue: 0,1:12:34.60,1:12:36.48,Default,,0,0,0,,for question and answer,
Dialogue: 0,1:12:36.48,1:12:44.68,Default,,0,0,0,,you can click the link in Clowdr.
Dialogue: 0,1:13:01.28,1:13:03.64,Default,,0,0,0,,Now we have Vikraman Choudhury
Dialogue: 0,1:13:03.64,1:13:06.80,Default,,0,0,0,,discussing how to embed\Npurity in an impure language
Dialogue: 0,1:13:06.80,1:13:12.36,Default,,0,0,0,,via the use of a comonad.
Dialogue: 0,1:13:12.36,1:13:16.32,Default,,0,0,0,,VIKRAMAN: Hello, I'm\NVikraman Choudhury,
Dialogue: 0,1:13:16.32,1:13:18.08,Default,,0,0,0,,and I'm going to be presenting
Dialogue: 0,1:13:18.08,1:13:22.36,Default,,0,0,0,,some joint work with Neel\NKrishnaswami on our paper,
Dialogue: 0,1:13:22.36,1:13:28.68,Default,,0,0,0,,'Recovering Purity With\NComonads and Capabilities'.
Dialogue: 0,1:13:28.68,1:13:32.52,Default,,0,0,0,,The basic problem in this\Npaper is the following,
Dialogue: 0,1:13:32.52,1:13:35.20,Default,,0,0,0,,we've known for a while\Nnow how to extend
Dialogue: 0,1:13:35.20,1:13:38.36,Default,,0,0,0,,a purely functional\Nlanguage with monads
Dialogue: 0,1:13:38.36,1:13:41.76,Default,,0,0,0,,to encode side effects.
Dialogue: 0,1:13:41.76,1:13:46.36,Default,,0,0,0,,However, what if we already have\Nan impure functional language?
Dialogue: 0,1:13:46.36,1:13:48.36,Default,,0,0,0,,Can we extend the type system
Dialogue: 0,1:13:48.36,1:13:52.76,Default,,0,0,0,,to encode the absence of effects?
Dialogue: 0,1:13:52.76,1:13:54.48,Default,,0,0,0,,So let's try to motivate
Dialogue: 0,1:13:54.48,1:14:01.12,Default,,0,0,0,,why you such a thing might be\Nuseful with some examples.
Dialogue: 0,1:14:01.12,1:14:04.64,Default,,0,0,0,,Consider a strict call\Nby value language,
Dialogue: 0,1:14:04.64,1:14:06.64,Default,,0,0,0,,which allows side effects
Dialogue: 0,1:14:06.64,1:14:11.00,Default,,0,0,0,,and let's consider\Nthe map functional.
Dialogue: 0,1:14:11.00,1:14:13.00,Default,,0,0,0,,So map is a higher order function,
Dialogue: 0,1:14:13.00,1:14:15.08,Default,,0,0,0,,which takes the function F
Dialogue: 0,1:14:15.08,1:14:17.60,Default,,0,0,0,,and applies it to every\Nelement of the list,
Dialogue: 0,1:14:17.60,1:14:20.08,Default,,0,0,0,,because there are at least two\Ndifferent ways of writing map.
Dialogue: 0,1:14:24.56,1:14:25.56,Default,,0,0,0,,In map one,
Dialogue: 0,1:14:25.56,1:14:29.32,Default,,0,0,0,,we recursively call map one\Non the tail of the list
Dialogue: 0,1:14:29.32,1:14:32.96,Default,,0,0,0,,before evaluating F on\Nthe head of the list.
Dialogue: 0,1:14:32.96,1:14:34.60,Default,,0,0,0,,And in map two,
Dialogue: 0,1:14:34.60,1:14:37.20,Default,,0,0,0,,we evaluate F on\Nthe head of the list
Dialogue: 0,1:14:37.20,1:14:42.36,Default,,0,0,0,,before recursively calling\Nmap two on the tail of the list.
Dialogue: 0,1:14:42.36,1:14:45.92,Default,,0,0,0,,So these two functions\Nshould be equal,
Dialogue: 0,1:14:45.92,1:14:48.72,Default,,0,0,0,,but in an impure language like this,
Dialogue: 0,1:14:48.72,1:14:51.44,Default,,0,0,0,,they can have different\Nside effects.
Dialogue: 0,1:14:51.44,1:14:53.20,Default,,0,0,0,,So, as an example,
Dialogue: 0,1:14:53.20,1:14:58.08,Default,,0,0,0,,let's evaluate map one and map\Ntwo on the following inputs.
Dialogue: 0,1:14:58.08,1:15:01.48,Default,,0,0,0,,So here F is the identity\Nfunction on strings,
Dialogue: 0,1:15:01.48,1:15:02.88,Default,,0,0,0,,but it's impure.
Dialogue: 0,1:15:02.88,1:15:05.76,Default,,0,0,0,,It prints its input\Nstring to standard out
Dialogue: 0,1:15:05.76,1:15:09.68,Default,,0,0,0,,before returning it.
Dialogue: 0,1:15:09.68,1:15:13.16,Default,,0,0,0,,So let's try to use map one.
Dialogue: 0,1:15:13.16,1:15:15.96,Default,,0,0,0,,We expand the let and we observe
Dialogue: 0,1:15:15.96,1:15:19.16,Default,,0,0,0,,that it reaches the end of the list
Dialogue: 0,1:15:19.16,1:15:23.36,Default,,0,0,0,,when it tries to evaluate\NF on the string right.
Dialogue: 0,1:15:23.36,1:15:26.60,Default,,0,0,0,,So this prints, right.
Dialogue: 0,1:15:26.60,1:15:30.88,Default,,0,0,0,,Reducing more where you see\Nthat it calls F on to,
Dialogue: 0,1:15:30.88,1:15:32.72,Default,,0,0,0,,which prints to,
Dialogue: 0,1:15:32.72,1:15:37.20,Default,,0,0,0,,and then it calls F on left,\Nwhich prints left
Dialogue: 0,1:15:37.20,1:15:41.36,Default,,0,0,0,,and finally it\Nreturns the original list.
Dialogue: 0,1:15:41.36,1:15:47.72,Default,,0,0,0,,So it produced a side effect\Nwhere it printed right to left.
Dialogue: 0,1:15:47.72,1:15:51.88,Default,,0,0,0,,If however, we reduce map\Ntwo on the same inputs,
Dialogue: 0,1:15:51.88,1:15:56.88,Default,,0,0,0,,we notice that it evaluates\Nf first on the string left,
Dialogue: 0,1:15:56.88,1:16:01.20,Default,,0,0,0,,then on the string to\Nand then on right,
Dialogue: 0,1:16:01.20,1:16:04.68,Default,,0,0,0,,and finally returns\Nthe original list.
Dialogue: 0,1:16:04.68,1:16:07.04,Default,,0,0,0,,So even though both of\Nthese map functions
Dialogue: 0,1:16:07.04,1:16:08.92,Default,,0,0,0,,return the same output,
Dialogue: 0,1:16:08.92,1:16:15.12,Default,,0,0,0,,they produce different side effects.
Dialogue: 0,1:16:15.12,1:16:19.04,Default,,0,0,0,,Alternatively consider\Nthese two functions f and g
Dialogue: 0,1:16:19.04,1:16:20.72,Default,,0,0,0,,from int to int.
Dialogue: 0,1:16:21.48,1:16:23.56,Default,,0,0,0,,They perform different side effects
Dialogue: 0,1:16:23.56,1:16:26.84,Default,,0,0,0,,before returning their output.
Dialogue: 0,1:16:26.84,1:16:30.12,Default,,0,0,0,,Now, suppose we map g on xs,
Dialogue: 0,1:16:30.12,1:16:34.20,Default,,0,0,0,,followed by mapping f on the output,
Dialogue: 0,1:16:34.20,1:16:38.08,Default,,0,0,0,,and optimizing compiler\Ncould perform map fusion
Dialogue: 0,1:16:38.08,1:16:40.08,Default,,0,0,0,,on this expression.
Dialogue: 0,1:16:40.08,1:16:42.80,Default,,0,0,0,,But in this impure language,
Dialogue: 0,1:16:42.80,1:16:46.08,Default,,0,0,0,,if we mapped f compose g on xs,
Dialogue: 0,1:16:46.08,1:16:49.08,Default,,0,0,0,,that would produce\Na different side effect.
Dialogue: 0,1:16:49.08,1:16:54.08,Default,,0,0,0,,So this map fusion optimization\Npass would be invalid.
Dialogue: 0,1:16:55.40,1:16:59.12,Default,,0,0,0,,So I hope these examples\Nare motivating
Dialogue: 0,1:16:59.12,1:17:02.80,Default,,0,0,0,,and they show that it\Nwould indeed be useful
Dialogue: 0,1:17:02.80,1:17:06.00,Default,,0,0,0,,to be able to encode\Nthe absence of effects
Dialogue: 0,1:17:06.00,1:17:07.84,Default,,0,0,0,,in an impure language.
Dialogue: 0,1:17:07.84,1:17:11.12,Default,,0,0,0,,So first let's see how\Neffects are being encoded
Dialogue: 0,1:17:11.12,1:17:16.64,Default,,0,0,0,,in this language with some examples.
Dialogue: 0,1:17:16.64,1:17:19.48,Default,,0,0,0,,Let's consider the function g.
Dialogue: 0,1:17:19.48,1:17:23.68,Default,,0,0,0,,It takes the channel c, a string s,
Dialogue: 0,1:17:23.68,1:17:28.84,Default,,0,0,0,,prints s on the channel\Nc, then returns s.
Dialogue: 0,1:17:28.84,1:17:31.72,Default,,0,0,0,,So this function is impure\Nbecause it uses the channel
Dialogue: 0,1:17:31.72,1:17:33.60,Default,,0,0,0,,it was passed to,
Dialogue: 0,1:17:33.60,1:17:37.20,Default,,0,0,0,,to perform an effect.
Dialogue: 0,1:17:37.20,1:17:42.32,Default,,0,0,0,,Now consider this function\Nf from string to string.
Dialogue: 0,1:17:42.32,1:17:44.68,Default,,0,0,0,,This is also impure,
Dialogue: 0,1:17:44.68,1:17:50.24,Default,,0,0,0,,but it is defined by partially\Napplying g to standard out.
Dialogue: 0,1:17:50.24,1:17:52.80,Default,,0,0,0,,Now standard out is\Na channel that's available
Dialogue: 0,1:17:52.80,1:17:56.56,Default,,0,0,0,,in the global environment.
Dialogue: 0,1:17:56.56,1:18:00.24,Default,,0,0,0,,So there's a difference\Nbetween f and g.
Dialogue: 0,1:18:00.24,1:18:02.36,Default,,0,0,0,,g isn't safe,
Dialogue: 0,1:18:02.36,1:18:03.68,Default,,0,0,0,,because it uses the channel
Dialogue: 0,1:18:03.68,1:18:06.20,Default,,0,0,0,,that was passed as an argument.
Dialogue: 0,1:18:06.20,1:18:10.08,Default,,0,0,0,,But f uses standard\Nout which is used
Dialogue: 0,1:18:10.08,1:18:12.96,Default,,0,0,0,,from the global environment.
Dialogue: 0,1:18:12.96,1:18:15.96,Default,,0,0,0,,So, this gives us an idea,
Dialogue: 0,1:18:15.96,1:18:18.40,Default,,0,0,0,,we should be able to\Ncontrol the use of effects
Dialogue: 0,1:18:18.40,1:18:20.68,Default,,0,0,0,,by controlling the channel variables
Dialogue: 0,1:18:20.68,1:18:24.68,Default,,0,0,0,,that a function has access\Nto in its environment.
Dialogue: 0,1:18:24.68,1:18:26.96,Default,,0,0,0,,So we were interested in purity,
Dialogue: 0,1:18:26.96,1:18:33.40,Default,,0,0,0,,but we can refine this to\Na different notion of safety.
Dialogue: 0,1:18:33.40,1:18:38.64,Default,,0,0,0,,So we formalize this idea using\Nthe notion of capabilities.
Dialogue: 0,1:18:38.64,1:18:40.56,Default,,0,0,0,,So capabilities are\Na well known thing
Dialogue: 0,1:18:40.56,1:18:44.60,Default,,0,0,0,,in the systems\Nprogramming community.
Dialogue: 0,1:18:44.60,1:18:48.60,Default,,0,0,0,,A capability is defined to\Nbe a token of authority,
Dialogue: 0,1:18:48.60,1:18:51.28,Default,,0,0,0,,for example, a security token
Dialogue: 0,1:18:51.28,1:18:54.48,Default,,0,0,0,,or a permission
Dialogue: 0,1:18:54.48,1:18:56.36,Default,,0,0,0,,in our impure language.
Dialogue: 0,1:18:56.36,1:18:59.20,Default,,0,0,0,,A channel variable, for\Nexample, standard out
Dialogue: 0,1:18:59.20,1:19:02.68,Default,,0,0,0,,is a capability.
Dialogue: 0,1:19:02.68,1:19:06.48,Default,,0,0,0,,Then we define the notion\Nof capability safety.
Dialogue: 0,1:19:06.48,1:19:09.16,Default,,0,0,0,,We say that a program\Nis capability safe
Dialogue: 0,1:19:09.16,1:19:12.84,Default,,0,0,0,,when it only performs effects\Nusing the capabilities
Dialogue: 0,1:19:12.84,1:19:15.84,Default,,0,0,0,,it has access to at runtime.
Dialogue: 0,1:19:15.84,1:19:20.44,Default,,0,0,0,,So for example, this function\NG is capability safe,
Dialogue: 0,1:19:20.44,1:19:24.48,Default,,0,0,0,,but F is not.
Dialogue: 0,1:19:24.48,1:19:28.68,Default,,0,0,0,,But G is not pure, it's only safe.
Dialogue: 0,1:19:28.68,1:19:30.08,Default,,0,0,0,,So, we'll come back to how
Dialogue: 0,1:19:30.08,1:19:33.44,Default,,0,0,0,,we could encode purity using safety.
Dialogue: 0,1:19:33.44,1:19:39.76,Default,,0,0,0,,But for now, let's try to extend\Nour language with safety.
Dialogue: 0,1:19:39.76,1:19:41.44,Default,,0,0,0,,So first, we want to distinguish
Dialogue: 0,1:19:41.44,1:19:43.76,Default,,0,0,0,,between two kinds of variables,
Dialogue: 0,1:19:43.76,1:19:47.48,Default,,0,0,0,,safe variables and impure variables.
Dialogue: 0,1:19:47.48,1:19:52.04,Default,,0,0,0,,Safe variables, are capability\Nsafe and impure variables
Dialogue: 0,1:19:52.04,1:19:55.84,Default,,0,0,0,,are just arbitrary\Nvariables in our language.
Dialogue: 0,1:19:55.84,1:20:01.32,Default,,0,0,0,,So we use these qualifiers,\NS or I in blue and red
Dialogue: 0,1:20:01.32,1:20:06.24,Default,,0,0,0,,to annotate the bindings of\Nvariables in our context.
Dialogue: 0,1:20:06.24,1:20:10.40,Default,,0,0,0,,Then, we would like to\Ninternalize the notion of safety
Dialogue: 0,1:20:10.40,1:20:13.52,Default,,0,0,0,,using a safe type constructor.
Dialogue: 0,1:20:13.52,1:20:16.72,Default,,0,0,0,,We add a box type constructor
Dialogue: 0,1:20:16.72,1:20:22.20,Default,,0,0,0,,and we add two new term\Nformers, box and let box.
Dialogue: 0,1:20:22.20,1:20:25.04,Default,,0,0,0,,So, these are expressions and
Dialogue: 0,1:20:25.04,1:20:28.76,Default,,0,0,0,,we distinguish between\Nexpressions and values.
Dialogue: 0,1:20:28.76,1:20:33.12,Default,,0,0,0,,Boxing an expression\Nturns it into a value.
Dialogue: 0,1:20:33.12,1:20:36.80,Default,,0,0,0,,We also have a new safety judgment
Dialogue: 0,1:20:36.80,1:20:41.04,Default,,0,0,0,,which we use to judge\Nwhether a term E of type A
Dialogue: 0,1:20:41.04,1:20:46.52,Default,,0,0,0,,is safe in context gamma.
Dialogue: 0,1:20:46.52,1:20:49.60,Default,,0,0,0,,So now we want to ensure\Nthat safe variables
Dialogue: 0,1:20:49.60,1:20:53.08,Default,,0,0,0,,can only depend on\Nother safe variables.
Dialogue: 0,1:20:53.08,1:20:57.76,Default,,0,0,0,,So we add a sub structural\Noperation on our contexts,
Dialogue: 0,1:20:57.76,1:21:00.48,Default,,0,0,0,,so this purify operation
Dialogue: 0,1:21:00.48,1:21:05.56,Default,,0,0,0,,drops all the impure\Nvariables in our context.
Dialogue: 0,1:21:05.56,1:21:09.72,Default,,0,0,0,,Then, if we know that\Na term is well typed
Dialogue: 0,1:21:09.72,1:21:13.96,Default,,0,0,0,,in a safe context, we\Nknow that it's safe.
Dialogue: 0,1:21:13.96,1:21:17.04,Default,,0,0,0,,And if we know that a term is safe,
Dialogue: 0,1:21:17.04,1:21:19.16,Default,,0,0,0,,we can put it inside the box
Dialogue: 0,1:21:19.16,1:21:22.84,Default,,0,0,0,,using our box introduction rule.
Dialogue: 0,1:21:23.88,1:21:28.04,Default,,0,0,0,,And finally, we also have\Na let box elimination rule
Dialogue: 0,1:21:28.04,1:21:30.84,Default,,0,0,0,,for our box type constructor.
Dialogue: 0,1:21:30.84,1:21:33.44,Default,,0,0,0,,So if E1 is a boxed term,
Dialogue: 0,1:21:33.44,1:21:36.52,Default,,0,0,0,,we can bind to\Nthe underlying value X.
Dialogue: 0,1:21:36.52,1:21:39.16,Default,,0,0,0,,And we can eliminate to E2
Dialogue: 0,1:21:39.16,1:21:42.96,Default,,0,0,0,,if it is well typed in\Nthe extended context,
Dialogue: 0,1:21:42.96,1:21:49.00,Default,,0,0,0,,where X is marked with\Na safe annotation.
Dialogue: 0,1:21:49.00,1:21:53.12,Default,,0,0,0,,So these were the additional\Ntyping rules for the box type.
Dialogue: 0,1:21:53.12,1:21:58.20,Default,,0,0,0,,Let's also take a quick look\Nat the other typing rules.
Dialogue: 0,1:21:58.20,1:22:03.24,Default,,0,0,0,,The rules for variables\Nremains essentially unchanged.
Dialogue: 0,1:22:03.24,1:22:05.96,Default,,0,0,0,,For functions, to introduce a lambda
Dialogue: 0,1:22:05.96,1:22:09.12,Default,,0,0,0,,we allow the bound\Nvariable to be impure.
Dialogue: 0,1:22:09.12,1:22:12.64,Default,,0,0,0,,So that we can substitute\Narbitrary expressions.
Dialogue: 0,1:22:13.32,1:22:18.28,Default,,0,0,0,,The Lambda application\Nrule remains the same.
Dialogue: 0,1:22:18.28,1:22:23.08,Default,,0,0,0,,And then finally, the rule for\Nprint is just as expected.
Dialogue: 0,1:22:23.08,1:22:26.72,Default,,0,0,0,,It's simply a unit.
Dialogue: 0,1:22:27.76,1:22:30.48,Default,,0,0,0,,Now, at this point we note\Nthat this box constructor
Dialogue: 0,1:22:30.48,1:22:32.92,Default,,0,0,0,,is a comonad.
Dialogue: 0,1:22:32.92,1:22:37.64,Default,,0,0,0,,It has a co-unit,\Nand it has a co-multiplication.
Dialogue: 0,1:22:37.64,1:22:40.48,Default,,0,0,0,,And in fact, our syntax\Nfor adding comonads
Dialogue: 0,1:22:40.48,1:22:44.80,Default,,0,0,0,,to our type theory is inspired\Nby the classic Pfenning Davies
Dialogue: 0,1:22:44.80,1:22:51.00,Default,,0,0,0,,paper on the judgmental\Nreconstruction of S4 modal logic.
Dialogue: 0,1:22:51.00,1:22:53.04,Default,,0,0,0,,Instead of a dual context,
Dialogue: 0,1:22:53.04,1:22:56.44,Default,,0,0,0,,we use annotations on our variables.
Dialogue: 0,1:22:56.44,1:23:03.28,Default,,0,0,0,,And for more details on\Nthe syntax, see our paper.
Dialogue: 0,1:23:03.28,1:23:06.16,Default,,0,0,0,,So coming back to our\Noriginal motivation,
Dialogue: 0,1:23:06.16,1:23:10.36,Default,,0,0,0,,can we used this notion of\Nsafety to recover purity?
Dialogue: 0,1:23:10.36,1:23:15.60,Default,,0,0,0,,Well, we say that a function\Nis pure if it is safe
Dialogue: 0,1:23:15.60,1:23:20.52,Default,,0,0,0,,and it has access to zero\Ncapabilities in its environment.
Dialogue: 0,1:23:20.52,1:23:25.24,Default,,0,0,0,,So box of A arrow B is\Nthe type of safe functions
Dialogue: 0,1:23:25.24,1:23:28.20,Default,,0,0,0,,but they're not necessarily pure.
Dialogue: 0,1:23:28.20,1:23:34.56,Default,,0,0,0,,And box of box of A arrow\NB is the the type of pure functions.
Dialogue: 0,1:23:34.56,1:23:37.40,Default,,0,0,0,,So going back to our\Noriginal example,
Dialogue: 0,1:23:37.40,1:23:39.32,Default,,0,0,0,,we can now write a pure variant
Dialogue: 0,1:23:39.32,1:23:44.04,Default,,0,0,0,,of our map one\Nand map two functions.
Dialogue: 0,1:23:44.04,1:23:47.80,Default,,0,0,0,,We force the function\Nargument to be pure
Dialogue: 0,1:23:47.80,1:23:54.28,Default,,0,0,0,,and it should be only applied\Nto a list of safe expressions.
Dialogue: 0,1:23:54.28,1:23:57.84,Default,,0,0,0,,We can use box and let\Nbox to rewrite the body
Dialogue: 0,1:23:57.84,1:24:00.72,Default,,0,0,0,,of map one and map two.
Dialogue: 0,1:24:00.72,1:24:05.80,Default,,0,0,0,,So using this new definition\Nfor map one and map two,
Dialogue: 0,1:24:05.80,1:24:09.04,Default,,0,0,0,,we can show that they\Nare provably equal
Dialogue: 0,1:24:09.04,1:24:13.64,Default,,0,0,0,,in the extended calculus.
Dialogue: 0,1:24:13.64,1:24:17.32,Default,,0,0,0,,Finally to conclude, let me\Npoint out some of the main
Dialogue: 0,1:24:17.32,1:24:20.40,Default,,0,0,0,,takeaways from this talk.
Dialogue: 0,1:24:20.40,1:24:26.08,Default,,0,0,0,,First, we can use this notion\Nof capabilities to control effects,
Dialogue: 0,1:24:26.08,1:24:30.64,Default,,0,0,0,,and to control the usage of effects.
Dialogue: 0,1:24:30.64,1:24:34.96,Default,,0,0,0,,This idea of capability\Nsafety or denying the usage
Dialogue: 0,1:24:34.96,1:24:38.32,Default,,0,0,0,,of a capability from\Nthe environment can be captured
Dialogue: 0,1:24:38.32,1:24:43.36,Default,,0,0,0,,using a comonad\Ntype discipline.
Dialogue: 0,1:24:43.36,1:24:45.84,Default,,0,0,0,,Let me also highlight some\Nof the technical results
Dialogue: 0,1:24:45.84,1:24:48.32,Default,,0,0,0,,in our paper.
Dialogue: 0,1:24:48.32,1:24:52.44,Default,,0,0,0,,We formalize an effectful\Ncalculus and we extended
Dialogue: 0,1:24:52.44,1:24:57.00,Default,,0,0,0,,with a safety modality and we\Nshow how to do substitution
Dialogue: 0,1:24:57.00,1:25:00.12,Default,,0,0,0,,and so on.
Dialogue: 0,1:25:00.12,1:25:04.68,Default,,0,0,0,,We show how to recover purity\Nfrom capability safety.
Dialogue: 0,1:25:04.68,1:25:09.24,Default,,0,0,0,,And we also discussed how\Nto do capability taming.
Dialogue: 0,1:25:09.24,1:25:13.00,Default,,0,0,0,,That is, how to incrementally\Nadd safety to an already
Dialogue: 0,1:25:13.00,1:25:17.24,Default,,0,0,0,,impure language or a library.
Dialogue: 0,1:25:17.24,1:25:21.08,Default,,0,0,0,,We give a categorical\Nsemantics for this language.
Dialogue: 0,1:25:21.08,1:25:24.32,Default,,0,0,0,,It is given by a cartesian\Nclosed category
Dialogue: 0,1:25:24.32,1:25:26.20,Default,,0,0,0,,with a monad\Nand a comonad
Dialogue: 0,1:25:26.20,1:25:29.56,Default,,0,0,0,,which interact with each other.
Dialogue: 0,1:25:29.56,1:25:33.24,Default,,0,0,0,,We give a construction of\Ncapability spaces,
Dialogue: 0,1:25:33.24,1:25:36.40,Default,,0,0,0,,which give us\Na denotational semantics,
Dialogue: 0,1:25:36.40,1:25:40.64,Default,,0,0,0,,which satisfies the axiomatic\Ncategorical structure
Dialogue: 0,1:25:40.64,1:25:44.32,Default,,0,0,0,,that we need for our semantics.
Dialogue: 0,1:25:44.32,1:25:46.52,Default,,0,0,0,,The idea of this\Nconstruction in fact
Dialogue: 0,1:25:46.52,1:25:50.64,Default,,0,0,0,,comes from an old paper\Nof Martin Hoffman.
Dialogue: 0,1:25:50.64,1:25:53.48,Default,,0,0,0,,Also capability spaces\Nhave more structure
Dialogue: 0,1:25:53.48,1:25:57.08,Default,,0,0,0,,than we actually use\Nfor our semantics.
Dialogue: 0,1:25:57.08,1:26:00.64,Default,,0,0,0,,It can be used to give\Nthe model of linear type theory,
Dialogue: 0,1:26:00.64,1:26:04.56,Default,,0,0,0,,which we discussed in the paper.
Dialogue: 0,1:26:04.56,1:26:08.32,Default,,0,0,0,,We also give the full equational\Ntheory for this calculus
Dialogue: 0,1:26:08.32,1:26:11.00,Default,,0,0,0,,and we use our\Ndenotational semantics
Dialogue: 0,1:26:11.00,1:26:14.28,Default,,0,0,0,,to prove its soundness.
Dialogue: 0,1:26:14.28,1:26:17.04,Default,,0,0,0,,Finally, we also show how to embed
Dialogue: 0,1:26:17.04,1:26:19.56,Default,,0,0,0,,the pure simply-typed\Nlambda calculus
Dialogue: 0,1:26:19.56,1:26:25.12,Default,,0,0,0,,into our language, using\Nthis comonadic modality.
Dialogue: 0,1:26:25.12,1:26:27.68,Default,,0,0,0,,This embedding, preserves\Nthe equational theory
Dialogue: 0,1:26:27.68,1:26:30.64,Default,,0,0,0,,of the pure STLC.
Dialogue: 0,1:26:30.64,1:26:34.00,Default,,0,0,0,,Also, we show that our language\Nis a conservative extension
Dialogue: 0,1:26:34.00,1:26:36.84,Default,,0,0,0,,of the STLC.
Dialogue: 0,1:26:36.84,1:26:40.20,Default,,0,0,0,,This is a requirement for\Na purely functional language
Dialogue: 0,1:26:40.20,1:26:45.88,Default,,0,0,0,,that Amr Sabry told us\Nabout a long time ago.
Dialogue: 0,1:26:45.88,1:26:49.56,Default,,0,0,0,,And yeah, that's all I had to say.
Dialogue: 0,1:26:49.56,1:26:52.12,Default,,0,0,0,,Please see the extended\Nversion of our paper
Dialogue: 0,1:26:52.12,1:26:53.48,Default,,0,0,0,,if you're interested
Dialogue: 0,1:26:53.48,1:26:58.40,Default,,0,0,0,,and thank you very much\Nfor listening.
Dialogue: 0,1:26:58.40,1:27:06.76,Default,,0,0,0,,(AUDIENCE CLAPS)
Dialogue: 0,1:27:06.76,1:27:08.44,Default,,0,0,0,,RICHARD: Thanks Vikraman.
Dialogue: 0,1:27:08.44,1:27:12.44,Default,,0,0,0,,He is now available in both\Nthe New York and Asia time bands
Dialogue: 0,1:27:12.44,1:27:14.40,Default,,0,0,0,,for question and answer.
Dialogue: 0,1:27:14.40,1:27:17.00,Default,,0,0,0,,I will take a brief pause\Nfor the next talk at 12:15
Dialogue: 0,1:27:17.00,1:27:23.12,Default,,0,0,0,,in the New York time band.
Dialogue: 0,1:28:01.28,1:28:04.12,Default,,0,0,0,,Next up, we have Xiaohong\NChen to present
Dialogue: 0,1:28:04.12,1:28:09.12,Default,,0,0,0,,a general approach to define\Nbinders using matching logic.
Dialogue: 0,1:28:09.12,1:28:10.28,Default,,0,0,0,,XIAOHONG CHEN: Hello everyone.
Dialogue: 0,1:28:10.28,1:28:11.92,Default,,0,0,0,,Welcome to this video.
Dialogue: 0,1:28:11.92,1:28:13.68,Default,,0,0,0,,My name is Xiaohong Chen.
Dialogue: 0,1:28:13.68,1:28:14.92,Default,,0,0,0,,My talk today is about
Dialogue: 0,1:28:14.92,1:28:18.88,Default,,0,0,0,,a general approach to define\Nbinders using matching logic.
Dialogue: 0,1:28:18.88,1:28:21.28,Default,,0,0,0,,This is a joint work\Nwith my supervisor
Dialogue: 0,1:28:21.28,1:28:23.08,Default,,0,0,0,,Professor Grigore Rosu.
Dialogue: 0,1:28:23.08,1:28:26.00,Default,,0,0,0,,Our papers can be found\Nat the links below.
Dialogue: 0,1:28:26.00,1:28:28.44,Default,,0,0,0,,The technical report includes\Nall the proof details
Dialogue: 0,1:28:28.44,1:28:30.64,Default,,0,0,0,,in the appendix.
Dialogue: 0,1:28:30.64,1:28:32.40,Default,,0,0,0,,The main motivation of the work
Dialogue: 0,1:28:32.40,1:28:34.40,Default,,0,0,0,,is the K formal semantic framework
Dialogue: 0,1:28:34.40,1:28:37.44,Default,,0,0,0,,and its logical foundation,\Nmatching logic.
Dialogue: 0,1:28:37.44,1:28:40.64,Default,,0,0,0,,The K framework allows users to\Ndefine the formal semantics
Dialogue: 0,1:28:40.64,1:28:43.12,Default,,0,0,0,,of any programming languages.
Dialogue: 0,1:28:43.12,1:28:46.92,Default,,0,0,0,,As shown in the picture, once\Nthe semantics is defined,
Dialogue: 0,1:28:46.92,1:28:48.32,Default,,0,0,0,,all language tools
Dialogue: 0,1:28:48.32,1:28:50.44,Default,,0,0,0,,such as parsers, interpreters,
Dialogue: 0,1:28:50.44,1:28:55.00,Default,,0,0,0,,and verifiers are\Nautomatically generated by K.
Dialogue: 0,1:28:55.00,1:28:57.60,Default,,0,0,0,,In practice, K has been used\Nto define
Dialogue: 0,1:28:57.60,1:29:00.12,Default,,0,0,0,,the formal semantics\Nof many real world languages,
Dialogue: 0,1:29:00.12,1:29:03.48,Default,,0,0,0,,such as C, Java\Nand JavaScript.
Dialogue: 0,1:29:03.48,1:29:04.88,Default,,0,0,0,,K allows users to define
Dialogue: 0,1:29:04.88,1:29:08.44,Default,,0,0,0,,the common language features\Neasily, including binders.
Dialogue: 0,1:29:08.44,1:29:11.28,Default,,0,0,0,,For example, the following K\Ndefinition defines the syntax
Dialogue: 0,1:29:11.28,1:29:13.12,Default,,0,0,0,,of lambda calculus.
Dialogue: 0,1:29:13.12,1:29:16.60,Default,,0,0,0,,An expression is either a variable\Nor an expression applied
Dialogue: 0,1:29:16.60,1:29:17.88,Default,,0,0,0,,to another expression
Dialogue: 0,1:29:17.88,1:29:22.32,Default,,0,0,0,,or has the form lambda var.e.
Dialogue: 0,1:29:22.32,1:29:24.04,Default,,0,0,0,,The binder is an attribute,
Dialogue: 0,1:29:24.04,1:29:27.60,Default,,0,0,0,,which will trigger the internal\Nsubstitution mechanism in K
Dialogue: 0,1:29:27.60,1:29:29.56,Default,,0,0,0,,to provide the correct implementation
Dialogue: 0,1:29:29.56,1:29:31.60,Default,,0,0,0,,of capture-avoiding substitution.
Dialogue: 0,1:29:31.60,1:29:34.36,Default,,0,0,0,,Currently, this only works\Nfor a restricted form
Dialogue: 0,1:29:34.36,1:29:36.80,Default,,0,0,0,,of binders but with this paper,
Dialogue: 0,1:29:36.80,1:29:38.44,Default,,0,0,0,,we can give the binding attributes
Dialogue: 0,1:29:38.44,1:29:40.80,Default,,0,0,0,,a clean, mathematical explanation,
Dialogue: 0,1:29:40.80,1:29:43.60,Default,,0,0,0,,which will make K to support\Nmore general binders
Dialogue: 0,1:29:43.60,1:29:45.44,Default,,0,0,0,,in the future.
Dialogue: 0,1:29:45.44,1:29:47.96,Default,,0,0,0,,Mathematically speaking,\Nevery K definition
Dialogue: 0,1:29:47.96,1:29:50.44,Default,,0,0,0,,is a logical theory of matching logic
Dialogue: 0,1:29:50.44,1:29:53.48,Default,,0,0,0,,where the syntax and semantics\Nof a programming language
Dialogue: 0,1:29:53.48,1:29:56.76,Default,,0,0,0,,are defined using\Nmatching logic axioms.
Dialogue: 0,1:29:56.76,1:29:58.80,Default,,0,0,0,,So our job in this paper
Dialogue: 0,1:29:58.80,1:30:04.36,Default,,0,0,0,,is to show how to define binders\Nas matching logic theories.
Dialogue: 0,1:30:04.36,1:30:06.76,Default,,0,0,0,,Matching logic is expressive.
Dialogue: 0,1:30:06.76,1:30:09.20,Default,,0,0,0,,Many important logical\Nsystems can be defined
Dialogue: 0,1:30:09.20,1:30:11.08,Default,,0,0,0,,as matching logic theories.
Dialogue: 0,1:30:11.08,1:30:13.24,Default,,0,0,0,,These include first-order logic,
Dialogue: 0,1:30:13.24,1:30:17.16,Default,,0,0,0,,separation logic, Hoare\Nlogic for verification,
Dialogue: 0,1:30:17.16,1:30:19.72,Default,,0,0,0,,temporal logics,\Nand many others.
Dialogue: 0,1:30:19.72,1:30:23.84,Default,,0,0,0,,However no logical systems where\Nbinding plays a major role
Dialogue: 0,1:30:23.84,1:30:26.76,Default,,0,0,0,,have been thoroughly\Ndefined in matching logic
Dialogue: 0,1:30:26.76,1:30:28.56,Default,,0,0,0,,until this paper.
Dialogue: 0,1:30:28.56,1:30:30.44,Default,,0,0,0,,In this paper, we studied\Nthe typical systems
Dialogue: 0,1:30:30.44,1:30:33.44,Default,,0,0,0,,that include binders,\Nsuch as lambda calculus
Dialogue: 0,1:30:33.44,1:30:35.12,Default,,0,0,0,,and type systems.
Dialogue: 0,1:30:35.12,1:30:37.68,Default,,0,0,0,,We defined them as\Nmatching logic theories
Dialogue: 0,1:30:37.68,1:30:40.48,Default,,0,0,0,,and we proved that our\Ndefinitions are correct
Dialogue: 0,1:30:40.48,1:30:43.12,Default,,0,0,0,,by showing that they\Npreserve the syntax,
Dialogue: 0,1:30:43.12,1:30:48.40,Default,,0,0,0,,semantics and formal reasoning\Nof the target system.
Dialogue: 0,1:30:48.40,1:30:50.72,Default,,0,0,0,,Here is an overview of\Nthe main contribution
Dialogue: 0,1:30:50.72,1:30:52.16,Default,,0,0,0,,of the paper.
Dialogue: 0,1:30:52.16,1:30:54.52,Default,,0,0,0,,Firstly, we simplify matching logic
Dialogue: 0,1:30:54.52,1:30:57.04,Default,,0,0,0,,and propose a variant\Nthat is more suitable
Dialogue: 0,1:30:57.04,1:30:58.36,Default,,0,0,0,,to define binders.
Dialogue: 0,1:30:58.36,1:31:01.84,Default,,0,0,0,,Secondly, we use lambda\Ncalculus as an example
Dialogue: 0,1:31:01.84,1:31:05.60,Default,,0,0,0,,and define it as a machine\Nlogic theory, Gamma lambda.
Dialogue: 0,1:31:05.60,1:31:08.44,Default,,0,0,0,,The key observation\Nis that lambda X.E
Dialogue: 0,1:31:08.44,1:31:10.44,Default,,0,0,0,,does two things at a time.
Dialogue: 0,1:31:10.44,1:31:12.68,Default,,0,0,0,,It creates the binding of X in E
Dialogue: 0,1:31:12.68,1:31:15.68,Default,,0,0,0,,and also builds a term,\Nlambda X.E.
Dialogue: 0,1:31:15.68,1:31:18.92,Default,,0,0,0,,In matching logic, we\Nseparate these two.
Dialogue: 0,1:31:18.92,1:31:21.40,Default,,0,0,0,,We first use [X]E
Dialogue: 0,1:31:21.40,1:31:23.68,Default,,0,0,0,,to define the graph of the function
Dialogue: 0,1:31:23.68,1:31:25.56,Default,,0,0,0,,that maps X to E.
Dialogue: 0,1:31:25.56,1:31:28.76,Default,,0,0,0,,Here, <X,E> is the pair of X and E
Dialogue: 0,1:31:28.76,1:31:31.60,Default,,0,0,0,,and the matching logic\Nexists means union.
Dialogue: 0,1:31:31.60,1:31:35.80,Default,,0,0,0,,So this pattern is\Nthe set of all pairs <X,E>
Dialogue: 0,1:31:35.80,1:31:38.96,Default,,0,0,0,,where X ranges over the variables.
Dialogue: 0,1:31:38.96,1:31:42.60,Default,,0,0,0,,The intention packs\Nthe graph set into one element,
Dialogue: 0,1:31:42.60,1:31:46.60,Default,,0,0,0,,which then includes all\Nthe binding information.
Dialogue: 0,1:31:46.60,1:31:50.84,Default,,0,0,0,,Then we define lambda X.E by\Napplying the construct lambda
Dialogue: 0,1:31:50.84,1:31:53.08,Default,,0,0,0,,to the graph set [X]E.
Dialogue: 0,1:31:53.08,1:31:55.64,Default,,0,0,0,,The constructor builds the term.
Dialogue: 0,1:31:55.64,1:31:59.76,Default,,0,0,0,,In short, we use the built-in\Nexist binder of matching logic
Dialogue: 0,1:31:59.76,1:32:02.60,Default,,0,0,0,,to build a graph set\Nand create a binding
Dialogue: 0,1:32:02.60,1:32:06.88,Default,,0,0,0,,and then use constructors\Nto build the term.
Dialogue: 0,1:32:06.88,1:32:11.08,Default,,0,0,0,,To show that the above\Ndefinition is indeed correct,
Dialogue: 0,1:32:11.08,1:32:13.16,Default,,0,0,0,,we prove the following theorems.
Dialogue: 0,1:32:13.16,1:32:16.60,Default,,0,0,0,,We proof that Gamma lambda\Nis a conservative extension
Dialogue: 0,1:32:16.60,1:32:18.00,Default,,0,0,0,,of lambda calculus.
Dialogue: 0,1:32:18.00,1:32:21.00,Default,,0,0,0,,So any equations between\Ntwo lambda expressions
Dialogue: 0,1:32:21.00,1:32:23.40,Default,,0,0,0,,are provable in lambda calculus
Dialogue: 0,1:32:23.40,1:32:27.08,Default,,0,0,0,,if and only if they are probable\Nin theory Gamma lambda.
Dialogue: 0,1:32:27.08,1:32:29.04,Default,,0,0,0,,We also show that Gamma lambda
Dialogue: 0,1:32:29.04,1:32:30.44,Default,,0,0,0,,is sound and complete.
Dialogue: 0,1:32:30.44,1:32:34.56,Default,,0,0,0,,So semantic validity\Nand provability coincide.
Dialogue: 0,1:32:34.56,1:32:37.20,Default,,0,0,0,,One important advantage\Nof our approach
Dialogue: 0,1:32:37.20,1:32:40.68,Default,,0,0,0,,is that the theory Gamma\Nlambda automatically
Dialogue: 0,1:32:40.68,1:32:43.36,Default,,0,0,0,,gives a class of\Nmatching logic models
Dialogue: 0,1:32:43.36,1:32:46.76,Default,,0,0,0,,and the following two theorems\Nconnect those models
Dialogue: 0,1:32:46.76,1:32:48.48,Default,,0,0,0,,to lambda calculus.
Dialogue: 0,1:32:48.48,1:32:51.56,Default,,0,0,0,,The representative\Ncompleteness states
Dialogue: 0,1:32:51.56,1:32:54.00,Default,,0,0,0,,that for any lambda theory, T,
Dialogue: 0,1:32:54.00,1:32:57.00,Default,,0,0,0,,which is a set of lambda equations,
Dialogue: 0,1:32:57.00,1:33:01.08,Default,,0,0,0,,there is a model M_T of\Ntheory Gamma lambda,
Dialogue: 0,1:33:01.08,1:33:05.16,Default,,0,0,0,,such that M_T captures\Nprecisely the lambda theory T.
Dialogue: 0,1:33:05.16,1:33:08.92,Default,,0,0,0,,That is E1 equals E2\Nis provable in T,
Dialogue: 0,1:33:08.92,1:33:12.36,Default,,0,0,0,,if and only if it holds in M_T.
Dialogue: 0,1:33:12.36,1:33:13.80,Default,,0,0,0,,The last theorem states
Dialogue: 0,1:33:13.80,1:33:16.52,Default,,0,0,0,,that for any lambda\Ncalculus model A,
Dialogue: 0,1:33:16.52,1:33:18.84,Default,,0,0,0,,there is a matching logic model, M_A,
Dialogue: 0,1:33:18.84,1:33:22.36,Default,,0,0,0,,of the theory Gamma\Nlambda that captures A.
Dialogue: 0,1:33:22.36,1:33:24.48,Default,,0,0,0,,Lambda calculus has\Nmany different models.
Dialogue: 0,1:33:24.48,1:33:26.52,Default,,0,0,0,,In this paper, we\Nconsider the models
Dialogue: 0,1:33:26.52,1:33:28.84,Default,,0,0,0,,that are concrete Cartesian\Nclosed categories
Dialogue: 0,1:33:28.84,1:33:31.60,Default,,0,0,0,,or called concrete CCC models.
Dialogue: 0,1:33:31.60,1:33:34.72,Default,,0,0,0,,The technical details can\Nbe found in the paper.
Dialogue: 0,1:33:34.72,1:33:37.72,Default,,0,0,0,,To sum up, our definition\Nof lambda calculus
Dialogue: 0,1:33:37.72,1:33:39.96,Default,,0,0,0,,that first creates the binding
Dialogue: 0,1:33:39.96,1:33:42.76,Default,,0,0,0,,and then, builds the term is correct
Dialogue: 0,1:33:42.76,1:33:45.20,Default,,0,0,0,,and captures lambda\Ncalculus faithfully.
Dialogue: 0,1:33:45.20,1:33:47.48,Default,,0,0,0,,Then at the end of the paper,
Dialogue: 0,1:33:47.48,1:33:49.96,Default,,0,0,0,,we generalize it to other systems
Dialogue: 0,1:33:49.96,1:33:52.16,Default,,0,0,0,,with binders, such as system F,
Dialogue: 0,1:33:52.16,1:33:56.00,Default,,0,0,0,,pure type systems, et cetera.
Dialogue: 0,1:33:56.00,1:33:58.20,Default,,0,0,0,,In the following, I'll give\Na high-level overview
Dialogue: 0,1:33:58.20,1:33:59.44,Default,,0,0,0,,of matching logic,
Dialogue: 0,1:33:59.44,1:34:01.56,Default,,0,0,0,,including the syntax semantics
Dialogue: 0,1:34:01.56,1:34:03.80,Default,,0,0,0,,and then as an example,
Dialogue: 0,1:34:03.80,1:34:06.56,Default,,0,0,0,,I'll define lambda calculus\Nin matching logic.
Dialogue: 0,1:34:06.56,1:34:07.56,Default,,0,0,0,,Due to time limit,
Dialogue: 0,1:34:07.56,1:34:10.44,Default,,0,0,0,,I won't discuss the generalization\Npart in this talk.
Dialogue: 0,1:34:10.44,1:34:15.52,Default,,0,0,0,,However, I'll be happy to\Naddress it in the Q&A session.
Dialogue: 0,1:34:15.52,1:34:18.56,Default,,0,0,0,,Matching logic is a very\Nsimple and minimal
Dialogue: 0,1:34:18.56,1:34:20.48,Default,,0,0,0,,and yet, expressive logic.
Dialogue: 0,1:34:20.48,1:34:23.84,Default,,0,0,0,,It is the logical foundation\Nof the K framework.
Dialogue: 0,1:34:23.84,1:34:25.84,Default,,0,0,0,,Its syntax defines formulas,
Dialogue: 0,1:34:25.84,1:34:27.52,Default,,0,0,0,,which we call patterns,
Dialogue: 0,1:34:27.52,1:34:29.64,Default,,0,0,0,,using only 7 constructs.
Dialogue: 0,1:34:29.64,1:34:32.16,Default,,0,0,0,,They are element variables,
Dialogue: 0,1:34:32.16,1:34:34.48,Default,,0,0,0,,which are like first-order logic variables
Dialogue: 0,1:34:34.48,1:34:36.52,Default,,0,0,0,,that range over elements.
Dialogue: 0,1:34:36.52,1:34:39.68,Default,,0,0,0,,Set variables, which are like\Npropositional variables
Dialogue: 0,1:34:39.68,1:34:42.88,Default,,0,0,0,,in modal logic that\Nrange over subsets.
Dialogue: 0,1:34:42.88,1:34:45.64,Default,,0,0,0,,Symbols are like set variables,
Dialogue: 0,1:34:45.64,1:34:47.92,Default,,0,0,0,,except that their\Ninterpretations are fixed
Dialogue: 0,1:34:47.92,1:34:50.76,Default,,0,0,0,,by the models and do not change.
Dialogue: 0,1:34:50.76,1:34:53.56,Default,,0,0,0,,Phi one, phi two is\Nthe application value
Dialogue: 0,1:34:53.56,1:34:55.68,Default,,0,0,0,,where we apply phi one to phi two.
Dialogue: 0,1:34:55.68,1:34:58.00,Default,,0,0,0,,if phi one is\Na functional constructor,
Dialogue: 0,1:34:58.00,1:35:00.56,Default,,0,0,0,,then the result is like\Na first-order logic term.
Dialogue: 0,1:35:00.56,1:35:02.00,Default,,0,0,0,,If phi one is a predicate,
Dialogue: 0,1:35:02.00,1:35:05.52,Default,,0,0,0,,then the result is like\Na first-order logic atomic formula
Dialogue: 0,1:35:05.52,1:35:08.00,Default,,0,0,0,,but in general, any\Npattern can be applied
Dialogue: 0,1:35:08.00,1:35:09.44,Default,,0,0,0,,to any other pattern,
Dialogue: 0,1:35:09.44,1:35:12.84,Default,,0,0,0,,giving matching logic\Nmaximum flexibility.
Dialogue: 0,1:35:12.84,1:35:16.56,Default,,0,0,0,,Next two constructs,\Nbottom and implication
Dialogue: 0,1:35:16.56,1:35:19.48,Default,,0,0,0,,are standard propositional\Nconstructs.
Dialogue: 0,1:35:19.48,1:35:23.76,Default,,0,0,0,,Other propositional operations\Ncan be defined from these two.
Dialogue: 0,1:35:23.76,1:35:25.88,Default,,0,0,0,,Finally exists x phi
Dialogue: 0,1:35:25.88,1:35:29.72,Default,,0,0,0,,is the existential quantification\Nlike in first-order logic.
Dialogue: 0,1:35:29.72,1:35:32.20,Default,,0,0,0,,Now, we move on to the semantics.
Dialogue: 0,1:35:32.20,1:35:34.96,Default,,0,0,0,,The semantics of matching\Nlogic is one sentence,
Dialogue: 0,1:35:34.96,1:35:38.60,Default,,0,0,0,,a pattern phi is interpreted\Nas the set of elements
Dialogue: 0,1:35:38.60,1:35:42.60,Default,,0,0,0,,that match it, in other\Nwords, patterns mean sets.
Dialogue: 0,1:35:42.60,1:35:46.00,Default,,0,0,0,,Formally, a model M has\Na non-empty carrier set
Dialogue: 0,1:35:46.00,1:35:49.72,Default,,0,0,0,,and binary application\Nfunction from M x M
Dialogue: 0,1:35:49.72,1:35:51.64,Default,,0,0,0,,to the power set of M,
Dialogue: 0,1:35:51.64,1:35:54.88,Default,,0,0,0,,which will be used to interpret\Nthe application pattern.
Dialogue: 0,1:35:54.88,1:35:58.92,Default,,0,0,0,,Each symbol is also\Ninterpreted as a subset of M.
Dialogue: 0,1:35:58.92,1:36:02.60,Default,,0,0,0,,Now, given a valuation that\Nassigns element variables
Dialogue: 0,1:36:02.60,1:36:05.92,Default,,0,0,0,,to elements and set\Nvariables to sets,
Dialogue: 0,1:36:05.92,1:36:10.92,Default,,0,0,0,,the pattern interpretation\Nphi rho is defined like this,
Dialogue: 0,1:36:10.92,1:36:14.56,Default,,0,0,0,,for example, x evaluates\Nto the elements rho of x,
Dialogue: 0,1:36:14.56,1:36:18.36,Default,,0,0,0,,sigma evaluates to\Nthe interpretation, sigma M,
Dialogue: 0,1:36:18.36,1:36:20.68,Default,,0,0,0,,bottom evaluates to the empty set,
Dialogue: 0,1:36:20.68,1:36:23.72,Default,,0,0,0,,meaning that no\Nelements can match it.
Dialogue: 0,1:36:23.72,1:36:27.52,Default,,0,0,0,,Application is interpreted\Nusing the application function,
Dialogue: 0,1:36:27.52,1:36:30.68,Default,,0,0,0,,but now phi one\Nand phi two are also sets,
Dialogue: 0,1:36:30.68,1:36:34.12,Default,,0,0,0,,we range over their\Ninhabitants by a1 and a2
Dialogue: 0,1:36:34.12,1:36:36.40,Default,,0,0,0,,and take the union\Nof all the results,
Dialogue: 0,1:36:36.40,1:36:39.64,Default,,0,0,0,,this is called\Nthe pointwise extension.
Dialogue: 0,1:36:39.64,1:36:42.56,Default,,0,0,0,,Finally, exists x phi is interpreted
Dialogue: 0,1:36:42.56,1:36:45.48,Default,,0,0,0,,by ranging over all elements a in M,
Dialogue: 0,1:36:45.48,1:36:48.56,Default,,0,0,0,,and taking the big union of\Nall the resulting sets,
Dialogue: 0,1:36:48.56,1:36:53.88,Default,,0,0,0,,in short, exists means big\Nunion in matching logic.
Dialogue: 0,1:36:53.88,1:36:54.88,Default,,0,0,0,,In matching logic,
Dialogue: 0,1:36:54.88,1:36:57.68,Default,,0,0,0,,we use theories to capture\Nthe target logical systems
Dialogue: 0,1:36:57.68,1:36:59.68,Default,,0,0,0,,such as lambda calculus,
Dialogue: 0,1:36:59.68,1:37:02.04,Default,,0,0,0,,a theory consists of two components,
Dialogue: 0,1:37:02.04,1:37:04.40,Default,,0,0,0,,a set of symbols\Nand a set of axioms
Dialogue: 0,1:37:04.40,1:37:07.32,Default,,0,0,0,,that define the behavior\Nof the symbols.
Dialogue: 0,1:37:07.32,1:37:11.08,Default,,0,0,0,,We also define notations which\Nare just syntactic sugar.
Dialogue: 0,1:37:11.08,1:37:12.88,Default,,0,0,0,,With the proper notations,
Dialogue: 0,1:37:12.88,1:37:15.40,Default,,0,0,0,,we can capture the formulas\Nof those expressions
Dialogue: 0,1:37:15.40,1:37:19.76,Default,,0,0,0,,in the target system as is\Nwithout any translation.
Dialogue: 0,1:37:19.76,1:37:23.28,Default,,0,0,0,,We say that a model M is\Na model of the theory, Gamma,
Dialogue: 0,1:37:23.28,1:37:25.60,Default,,0,0,0,,if all axioms hold in a model,
Dialogue: 0,1:37:25.60,1:37:29.04,Default,,0,0,0,,that is they are interpreted\Nto the total sets,
Dialogue: 0,1:37:29.04,1:37:33.12,Default,,0,0,0,,then for each theory, we have\Na class of these models
Dialogue: 0,1:37:33.12,1:37:35.80,Default,,0,0,0,,whose properties can be\Nexpressed by patterns
Dialogue: 0,1:37:35.80,1:37:39.08,Default,,0,0,0,,for Gamma to correctly\Ncapture the target system,
Dialogue: 0,1:37:39.08,1:37:41.56,Default,,0,0,0,,we need to establish an equivalence
Dialogue: 0,1:37:41.56,1:37:43.12,Default,,0,0,0,,between the models of Gamma
Dialogue: 0,1:37:43.12,1:37:45.28,Default,,0,0,0,,and the models of the target system.
Dialogue: 0,1:37:45.28,1:37:48.84,Default,,0,0,0,,Then, we can use matching\Nlogic patterns to express
Dialogue: 0,1:37:48.84,1:37:54.08,Default,,0,0,0,,and reason about the properties\Nabout the target system.
Dialogue: 0,1:37:54.08,1:37:56.12,Default,,0,0,0,,In section four of the paper,
Dialogue: 0,1:37:56.12,1:37:58.08,Default,,0,0,0,,we define the matching logic theories
Dialogue: 0,1:37:58.08,1:38:01.72,Default,,0,0,0,,that captures many important\Nmathematical concepts
Dialogue: 0,1:38:01.72,1:38:04.36,Default,,0,0,0,,such as equality, membership,
Dialogue: 0,1:38:04.36,1:38:07.08,Default,,0,0,0,,the concept of sorts\Nand many sorted functions,
Dialogue: 0,1:38:07.08,1:38:09.76,Default,,0,0,0,,pairs and the power\Nsort 2 to the s,
Dialogue: 0,1:38:09.76,1:38:13.36,Default,,0,0,0,,whose elements are the sets\Nof elements of sort s.
Dialogue: 0,1:38:13.36,1:38:16.28,Default,,0,0,0,,Based on these\Ninfrastructure definitions,
Dialogue: 0,1:38:16.28,1:38:20.56,Default,,0,0,0,,we now define binders\Nin matching logic.
Dialogue: 0,1:38:20.56,1:38:22.84,Default,,0,0,0,,We define the theory Gamma lambda
Dialogue: 0,1:38:22.84,1:38:24.76,Default,,0,0,0,,that captures lambda calculus
Dialogue: 0,1:38:24.76,1:38:28.36,Default,,0,0,0,,due to time limits I'll only\Nshow intuitive ideas.
Dialogue: 0,1:38:28.36,1:38:32.16,Default,,0,0,0,,Intuitively, the lambda\Nabstraction, lambda X.e,
Dialogue: 0,1:38:32.16,1:38:36.16,Default,,0,0,0,,creates infinitely many alpha\Nequivalent representations,
Dialogue: 0,1:38:36.16,1:38:39.32,Default,,0,0,0,,lambda X1 e, X1 substitutes for X, etc.
Dialogue: 0,1:38:40.00,1:38:44.52,Default,,0,0,0,,Our idea is to\Ncapture these representations.
Dialogue: 0,1:38:44.52,1:38:47.48,Default,,0,0,0,,To do that we construct\Nan argument value pair
Dialogue: 0,1:38:47.48,1:38:49.92,Default,,0,0,0,,where the first argument\Nis the variable
Dialogue: 0,1:38:49.92,1:38:53.12,Default,,0,0,0,,and the second is\Nthe substituted expression.
Dialogue: 0,1:38:53.12,1:38:56.16,Default,,0,0,0,,Then we define this\Nexistential pattern.
Dialogue: 0,1:38:56.16,1:39:00.72,Default,,0,0,0,,Recall that semantics of existing\Nmatching logic means set union.
Dialogue: 0,1:39:00.72,1:39:03.72,Default,,0,0,0,,So this pattern means\Nthe union of all pairs.
Dialogue: 0,1:39:03.72,1:39:07.24,Default,,0,0,0,,In other words this pattern\Nis the graph of the function
Dialogue: 0,1:39:07.24,1:39:10.04,Default,,0,0,0,,that maps x into e.
Dialogue: 0,1:39:10.04,1:39:14.48,Default,,0,0,0,,To wrap up the definition we take\Nthe intension of the graph set.
Dialogue: 0,1:39:14.48,1:39:17.44,Default,,0,0,0,,The intension of a set\Nequals to the set itself
Dialogue: 0,1:39:17.44,1:39:21.28,Default,,0,0,0,,but the set is no longer regarded\Nas a collection of elements
Dialogue: 0,1:39:21.28,1:39:24.64,Default,,0,0,0,,but as a single element\Nin a power set domain.
Dialogue: 0,1:39:24.64,1:39:28.24,Default,,0,0,0,,This way we can avoid\Nthe pointwise extension
Dialogue: 0,1:39:28.24,1:39:31.64,Default,,0,0,0,,when we apply the constructor\Nlambda to the set.
Dialogue: 0,1:39:31.64,1:39:36.76,Default,,0,0,0,,We introduce a notation [X]E to\Nmean the intension of the graph set
Dialogue: 0,1:39:36.76,1:39:38.20,Default,,0,0,0,,which is one element
Dialogue: 0,1:39:38.20,1:39:42.16,Default,,0,0,0,,that includes all the binding\Ninformation of x into e.
Dialogue: 0,1:39:42.16,1:39:46.60,Default,,0,0,0,,And finally, we define lambda x.e\N as the application pattern
Dialogue: 0,1:39:46.60,1:39:51.56,Default,,0,0,0,,where the constructed lambda is\Napplied to the graph set [X]E.
Dialogue: 0,1:39:51.56,1:39:54.52,Default,,0,0,0,,In short, to define\Nlambda abstraction
Dialogue: 0,1:39:54.52,1:39:58.92,Default,,0,0,0,,we first use the building binder\Nexist to define the graph set
Dialogue: 0,1:39:58.92,1:40:01.20,Default,,0,0,0,,and capture the binding behavior
Dialogue: 0,1:40:01.20,1:40:04.16,Default,,0,0,0,,then we build the lambda\Nterm using the constructor
Dialogue: 0,1:40:04.16,1:40:08.04,Default,,0,0,0,,and matching logic application.
Dialogue: 0,1:40:08.04,1:40:10.72,Default,,0,0,0,,The correctness of\Nthe definition means that
Dialogue: 0,1:40:10.72,1:40:13.64,Default,,0,0,0,,the encoding from lambda\Ncalculus to matching logic
Dialogue: 0,1:40:13.64,1:40:17.32,Default,,0,0,0,,is faithful with respect\Nto the syntax semantics
Dialogue: 0,1:40:17.32,1:40:20.00,Default,,0,0,0,,and the formal reasoning\Nof Lambda Calculus.
Dialogue: 0,1:40:20.00,1:40:21.64,Default,,0,0,0,,In terms of the syntax,
Dialogue: 0,1:40:21.64,1:40:25.40,Default,,0,0,0,,matching logic captures\Nlambda expressions verbatim.
Dialogue: 0,1:40:25.40,1:40:31.80,Default,,0,0,0,,The lambda abstraction\Nbecomes this pattern
Dialogue: 0,1:40:31.80,1:40:34.04,Default,,0,0,0,,where we use lambda to build a term
Dialogue: 0,1:40:34.04,1:40:38.84,Default,,0,0,0,,and use [X]E which is\Nthe graph set to build the binding.
Dialogue: 0,1:40:38.84,1:40:42.36,Default,,0,0,0,,In lambda calculus formal reasoning\Nmeans equational reasoning
Dialogue: 0,1:40:42.36,1:40:44.28,Default,,0,0,0,,plus the beta-reduction rule.
Dialogue: 0,1:40:44.28,1:40:46.52,Default,,0,0,0,,To capture that we\Nadd beta reduction
Dialogue: 0,1:40:46.52,1:40:49.68,Default,,0,0,0,,as an axiom schema to\Nthe theory Gamma lambda
Dialogue: 0,1:40:49.68,1:40:52.20,Default,,0,0,0,,then we can prove that Gamma lambda
Dialogue: 0,1:40:52.20,1:40:55.12,Default,,0,0,0,,indeed captures lambda\Ncalculus faithfully
Dialogue: 0,1:40:55.12,1:40:57.68,Default,,0,0,0,,in the sense that lambda\Ncalculus reasoning
Dialogue: 0,1:40:57.68,1:41:00.88,Default,,0,0,0,,is equivalent to the matching\Nlogic formal reasoning
Dialogue: 0,1:41:00.88,1:41:02.76,Default,,0,0,0,,within the theory Gamma lambda
Dialogue: 0,1:41:02.76,1:41:06.00,Default,,0,0,0,,and is also equivalent to\Nthe semantic validity
Dialogue: 0,1:41:06.00,1:41:09.12,Default,,0,0,0,,within the theory Gamma lambda.
Dialogue: 0,1:41:09.12,1:41:11.12,Default,,0,0,0,,To conclude in this paper
Dialogue: 0,1:41:11.12,1:41:15.32,Default,,0,0,0,,we gave a generic way to dealing\Nwith binding using matching logic.
Dialogue: 0,1:41:15.32,1:41:18.40,Default,,0,0,0,,Since matching logic is\Nthe logical foundation of K
Dialogue: 0,1:41:18.40,1:41:22.12,Default,,0,0,0,,our work is useful to\Nthe development of K.
Dialogue: 0,1:41:22.12,1:41:25.40,Default,,0,0,0,,In the paper we proposed\Na simple matching logic variant
Dialogue: 0,1:41:25.40,1:41:27.92,Default,,0,0,0,,that has only 7 syntactic constructs
Dialogue: 0,1:41:27.92,1:41:31.68,Default,,0,0,0,,and we fully developed\Nmodels and proof theories.
Dialogue: 0,1:41:31.68,1:41:35.12,Default,,0,0,0,,Then we defined the matching\Nlogic theory for lambda calculus
Dialogue: 0,1:41:35.12,1:41:40.20,Default,,0,0,0,,where lambda abstraction is defined\Nby applying the construct lambda
Dialogue: 0,1:41:40.20,1:41:42.20,Default,,0,0,0,,to the graph set [X]E.
Dialogue: 0,1:41:42.20,1:41:44.76,Default,,0,0,0,,We proved the correctness\Nof this definition
Dialogue: 0,1:41:44.76,1:41:47.40,Default,,0,0,0,,by showing the equivalence\Namong the validity
Dialogue: 0,1:41:47.40,1:41:52.00,Default,,0,0,0,,and the provability of lambda\Ncalculus and matching logic.
Dialogue: 0,1:41:52.00,1:41:56.60,Default,,0,0,0,,Finally, we extended our approach\Nto all binders in a systematic way
Dialogue: 0,1:41:56.60,1:41:59.32,Default,,0,0,0,,where the details can\Nbe found in the paper.
Dialogue: 0,1:41:59.32,1:42:00.72,Default,,0,0,0,,Due to the time limit,
Dialogue: 0,1:42:00.72,1:42:04.12,Default,,0,0,0,,I cannot fully cover all\Ntechnical details in this talk.
Dialogue: 0,1:42:04.12,1:42:08.40,Default,,0,0,0,,The paper and the companion technical\Nreport contain all the details.
Dialogue: 0,1:42:08.40,1:42:13.04,Default,,0,0,0,,I am happy to answer any questions\Nabout the work in the Q&A session.
Dialogue: 0,1:42:13.04,1:42:18.04,Default,,0,0,0,,Thank you for watching.
Dialogue: 0,1:42:24.56,1:42:26.44,Default,,0,0,0,,RICHARD: Thanks very much Xiaohong,
Dialogue: 0,1:42:26.44,1:42:29.72,Default,,0,0,0,,who is now available in both\Nthe New York and Asian time bands
Dialogue: 0,1:42:29.72,1:42:34.72,Default,,0,0,0,,for question and answer.
Dialogue: 0,1:43:01.96,1:43:07.28,Default,,0,0,0,,Next up we have Pierce Darragh\Npresenting Parsing with Zippers,
Dialogue: 0,1:43:07.28,1:43:12.28,Default,,0,0,0,,a Functional Pearl.
Dialogue: 0,1:43:14.92,1:43:17.24,Default,,0,0,0,,PIERCE DARRAGH: Hello, thank you\Nfor watching my talk.
Dialogue: 0,1:43:17.24,1:43:18.48,Default,,0,0,0,,My name is Pierce Darragh
Dialogue: 0,1:43:18.48,1:43:20.36,Default,,0,0,0,,and I will be walking you\Nthrough parsing with zippers,
Dialogue: 0,1:43:20.36,1:43:23.32,Default,,0,0,0,,a functional pearl written\Nby Michael D. Adams and me.
Dialogue: 0,1:43:23.32,1:43:25.20,Default,,0,0,0,,So let's get to it.
Dialogue: 0,1:43:25.20,1:43:27.40,Default,,0,0,0,,Parsing with zippers is\Nan extension of the earlier work
Dialogue: 0,1:43:27.40,1:43:31.00,Default,,0,0,0,,of parsing with derivatives\Nwhich we'll call PwD for short.
Dialogue: 0,1:43:31.00,1:43:33.72,Default,,0,0,0,,We address an underlying\Ninefficiency in PwD's algorithm
Dialogue: 0,1:43:33.72,1:43:36.28,Default,,0,0,0,,by implementing a new\Ngeneralized form of the zipper
Dialogue: 0,1:43:36.28,1:43:38.56,Default,,0,0,0,,and using it to manage derivations.
Dialogue: 0,1:43:38.56,1:43:40.48,Default,,0,0,0,,Our resulting algorithm\Nis significantly faster
Dialogue: 0,1:43:40.48,1:43:42.48,Default,,0,0,0,,than the original\NPwD implementation,
Dialogue: 0,1:43:42.48,1:43:45.08,Default,,0,0,0,,measurably faster than\Nthe optimized PwD implementation
Dialogue: 0,1:43:45.08,1:43:46.92,Default,,0,0,0,,of Adams et al in 2015
Dialogue: 0,1:43:46.92,1:43:51.72,Default,,0,0,0,,and it is only around 100 lines of\NOCaml cord when fully implemented.
Dialogue: 0,1:43:51.72,1:43:54.12,Default,,0,0,0,,The primary contribution of\Nparsing with derivatives
Dialogue: 0,1:43:54.12,1:43:55.80,Default,,0,0,0,,was the generalized\NBrzozowski's derivatives
Dialogue: 0,1:43:55.80,1:43:58.44,Default,,0,0,0,,from regular expressions\Nto context free grammars.
Dialogue: 0,1:43:58.44,1:44:00.08,Default,,0,0,0,,This is not trivial.
Dialogue: 0,1:44:00.08,1:44:02.72,Default,,0,0,0,,The Brzozowski derivative\Nuses two eager algorithms
Dialogue: 0,1:44:02.72,1:44:05.84,Default,,0,0,0,,perfectly fine for regular\Nlanguages but not so with CFGs
Dialogue: 0,1:44:05.84,1:44:07.52,Default,,0,0,0,,which have recursion.
Dialogue: 0,1:44:07.52,1:44:11.12,Default,,0,0,0,,PwD introduced laziness to fix most\Nof for one of those algorithms
Dialogue: 0,1:44:11.12,1:44:14.40,Default,,0,0,0,,and memoization\Nand fixed points for the other.
Dialogue: 0,1:44:14.40,1:44:16.44,Default,,0,0,0,,The result is\Nan algorithm that is elegant
Dialogue: 0,1:44:16.44,1:44:17.96,Default,,0,0,0,,in its theoretical simplicity
Dialogue: 0,1:44:17.96,1:44:19.72,Default,,0,0,0,,and which can also\Nproduce full parse trees
Dialogue: 0,1:44:19.72,1:44:23.40,Default,,0,0,0,,instead of only recognizing inputs\Nas Brzozowski derivatives do.
Dialogue: 0,1:44:23.40,1:44:27.28,Default,,0,0,0,,Let's see a brief example\Nof PwD in action.
Dialogue: 0,1:44:27.28,1:44:30.04,Default,,0,0,0,,We start with a grammar consisting\Nof a root concatenation node
Dialogue: 0,1:44:30.04,1:44:32.84,Default,,0,0,0,,shown with the circle-like\Nconcatenation operator
Dialogue: 0,1:44:32.84,1:44:34.76,Default,,0,0,0,,that has two children\Nconcatenation nodes
Dialogue: 0,1:44:34.76,1:44:37.12,Default,,0,0,0,,each of which has two\Nchildren token nodes.
Dialogue: 0,1:44:37.12,1:44:40.56,Default,,0,0,0,,This grammar parses only\Nthe string a,b,c,d.
Dialogue: 0,1:44:40.56,1:44:42.16,Default,,0,0,0,,We will attempt to parse that string
Dialogue: 0,1:44:42.16,1:44:46.00,Default,,0,0,0,,shown disassembled in\Nthe tokens at the top.
Dialogue: 0,1:44:46.00,1:44:49.24,Default,,0,0,0,,We take the first token from\Nthe input string labeling it current
Dialogue: 0,1:44:49.24,1:44:52.80,Default,,0,0,0,,then we derive the grammar\Nbeginning at the root node.
Dialogue: 0,1:44:52.80,1:44:54.64,Default,,0,0,0,,At each step a pattern match is run
Dialogue: 0,1:44:54.64,1:44:56.92,Default,,0,0,0,,to determine what to do\Nwith the current node.
Dialogue: 0,1:44:56.92,1:44:58.72,Default,,0,0,0,,The derivative proceeds\Ndown the left side
Dialogue: 0,1:44:58.72,1:45:00.00,Default,,0,0,0,,of each concatenation node
Dialogue: 0,1:45:00.00,1:45:01.76,Default,,0,0,0,,as it attempts to find\Na token node.
Dialogue: 0,1:45:01.76,1:45:04.84,Default,,0,0,0,,Eventually it finds\Nthe first token node, a.
Dialogue: 0,1:45:04.84,1:45:06.28,Default,,0,0,0,,When the algorithm\Ncomes to a token node
Dialogue: 0,1:45:06.28,1:45:08.68,Default,,0,0,0,,it attempts to match that\Ntoken to the current token
Dialogue: 0,1:45:08.68,1:45:11.20,Default,,0,0,0,,that we are taking the derivative\Nof the grammar with respect to,
Dialogue: 0,1:45:11.20,1:45:14.20,Default,,0,0,0,,in this case also a.
Dialogue: 0,1:45:14.20,1:45:15.52,Default,,0,0,0,,Because the tokens match
Dialogue: 0,1:45:15.52,1:45:17.48,Default,,0,0,0,,we replace the token grammar\Nexpression with a lambda
Dialogue: 0,1:45:17.48,1:45:20.04,Default,,0,0,0,,indicating a successful parse.
Dialogue: 0,1:45:20.04,1:45:22.64,Default,,0,0,0,,Since we have successfully derived\Nthe grammar with respect to a
Dialogue: 0,1:45:22.64,1:45:26.68,Default,,0,0,0,,let's proceed and attempt to derive\Nthe result with respect to b.
Dialogue: 0,1:45:26.68,1:45:29.40,Default,,0,0,0,,Again we being our search\Nat the root of the grammar
Dialogue: 0,1:45:29.40,1:45:31.36,Default,,0,0,0,,exploring each node and sequence
Dialogue: 0,1:45:31.36,1:45:33.84,Default,,0,0,0,,until we find\Nan unmatched token node.
Dialogue: 0,1:45:33.84,1:45:36.60,Default,,0,0,0,,In this case, the traversal down to\Nthe lambda will be thrown away
Dialogue: 0,1:45:36.60,1:45:39.40,Default,,0,0,0,,so I am only showing the traversal\Ndown towards the b node.
Dialogue: 0,1:45:39.40,1:45:42.32,Default,,0,0,0,,Because the current token\Nand the found token node matched
Dialogue: 0,1:45:42.32,1:45:46.12,Default,,0,0,0,,we replace the node with a lambda\Nnode and return a new grammar.
Dialogue: 0,1:45:46.12,1:45:48.36,Default,,0,0,0,,We'll stop the parsing\Nexample at this point.
Dialogue: 0,1:45:48.36,1:45:50.08,Default,,0,0,0,,The take away is that\Neach derivative
Dialogue: 0,1:45:50.08,1:45:52.96,Default,,0,0,0,,will start at the root of\Nthe previous derivative result grammar.
Dialogue: 0,1:45:52.96,1:45:56.04,Default,,0,0,0,,In this simple example, this\Nonly means one extra step
Dialogue: 0,1:45:56.04,1:45:57.96,Default,,0,0,0,,but with more complex\Ngrammar with many layers
Dialogue: 0,1:45:57.96,1:45:59.52,Default,,0,0,0,,it can be very many steps.
Dialogue: 0,1:45:59.52,1:46:01.00,Default,,0,0,0,,This is wasted effort.
Dialogue: 0,1:46:01.00,1:46:04.00,Default,,0,0,0,,Most often subsequent derivatives\Nneed to essentially resume
Dialogue: 0,1:46:04.00,1:46:06.40,Default,,0,0,0,,from where the previous\Nderivative left off.
Dialogue: 0,1:46:06.40,1:46:08.16,Default,,0,0,0,,The PwD algorithm does\Nnot account for this
Dialogue: 0,1:46:08.16,1:46:10.92,Default,,0,0,0,,and so it spends a lot of time\Non redundant traversals.
Dialogue: 0,1:46:10.92,1:46:14.24,Default,,0,0,0,,To avoid this we'll\Nemploy the zipper.
Dialogue: 0,1:46:14.24,1:46:16.76,Default,,0,0,0,,The zipper is a functional data\Nstructure for navigating trees
Dialogue: 0,1:46:16.76,1:46:19.20,Default,,0,0,0,,introduced by Huet in 1997.
Dialogue: 0,1:46:19.20,1:46:21.44,Default,,0,0,0,,We start with a simple definition\Nfor a tree data type
Dialogue: 0,1:46:21.44,1:46:23.72,Default,,0,0,0,,consisting of either\Nan item which is leaf node
Dialogue: 0,1:46:23.72,1:46:26.64,Default,,0,0,0,,or a section which is a branch.
Dialogue: 0,1:46:26.64,1:46:28.40,Default,,0,0,0,,Next we introduce the path.
Dialogue: 0,1:46:28.40,1:46:30.32,Default,,0,0,0,,A path is essentially a context.
Dialogue: 0,1:46:30.32,1:46:31.52,Default,,0,0,0,,It represents the part of the tree
Dialogue: 0,1:46:31.52,1:46:32.96,Default,,0,0,0,,which has essentially been traversed
Dialogue: 0,1:46:32.96,1:46:34.76,Default,,0,0,0,,and also keeps track of\Nsiblings of the subtree
Dialogue: 0,1:46:34.76,1:46:37.32,Default,,0,0,0,,currently being focused on.
Dialogue: 0,1:46:37.32,1:46:40.76,Default,,0,0,0,,Last we have the location which\Nis really the zipper itself.
Dialogue: 0,1:46:40.76,1:46:43.36,Default,,0,0,0,,This is a pair of a path\Nwith the focused-on subtree
Dialogue: 0,1:46:43.36,1:46:46.52,Default,,0,0,0,,which is generally referred to\Nas the focus of the zipper.
Dialogue: 0,1:46:46.52,1:46:50.48,Default,,0,0,0,,To solidify this concept let\Nus look at the visualization.
Dialogue: 0,1:46:50.48,1:46:53.24,Default,,0,0,0,,In this diagram blue\Nsquares represent paths,
Dialogue: 0,1:46:53.24,1:46:55.08,Default,,0,0,0,,yellow triangles\Nrepresent tree nodes
Dialogue: 0,1:46:55.08,1:46:57.24,Default,,0,0,0,,and the red circle is the zipper.
Dialogue: 0,1:46:57.24,1:46:59.88,Default,,0,0,0,,The red arrow going down from\Nthe zipper is the focus expression
Dialogue: 0,1:46:59.88,1:47:03.24,Default,,0,0,0,,and the black arrow going\Nup points to the path.
Dialogue: 0,1:47:03.24,1:47:04.60,Default,,0,0,0,,I'll take a few steps with the tree.
Dialogue: 0,1:47:04.60,1:47:08.72,Default,,0,0,0,,We begin by doing down\Nthrough the subtree t1.
Dialogue: 0,1:47:08.72,1:47:10.96,Default,,0,0,0,,When we go down into\Na concatenation node
Dialogue: 0,1:47:10.96,1:47:12.60,Default,,0,0,0,,a new node path will be created
Dialogue: 0,1:47:12.60,1:47:15.72,Default,,0,0,0,,representing the path back up\Nthrough that concatenation node.
Dialogue: 0,1:47:15.72,1:47:17.12,Default,,0,0,0,,This will be attached to the zipper
Dialogue: 0,1:47:17.12,1:47:19.80,Default,,0,0,0,,which will be focused on the first\Nchild of the concatenation node
Dialogue: 0,1:47:19.80,1:47:21.88,Default,,0,0,0,,t2 in this case.
Dialogue: 0,1:47:21.88,1:47:24.04,Default,,0,0,0,,The remaining children t3 and t4
Dialogue: 0,1:47:24.04,1:47:27.20,Default,,0,0,0,,are in the node paths\Nright siblings list.
Dialogue: 0,1:47:27.20,1:47:30.40,Default,,0,0,0,,We are not limited traversing\Nthe tree a specific order.
Dialogue: 0,1:47:30.40,1:47:32.04,Default,,0,0,0,,We can immediately move to right
Dialogue: 0,1:47:32.04,1:47:34.00,Default,,0,0,0,,without going at any\Nother direction.
Dialogue: 0,1:47:34.00,1:47:36.12,Default,,0,0,0,,Notice that a new node\Npath is constructed
Dialogue: 0,1:47:36.12,1:47:38.16,Default,,0,0,0,,which has t2 as the left\Nsibling of the focus
Dialogue: 0,1:47:38.16,1:47:40.92,Default,,0,0,0,,and t4 as the right sibling.
Dialogue: 0,1:47:40.92,1:47:44.44,Default,,0,0,0,,If we go down through t3 we'll\Ncreate a new node path c3
Dialogue: 0,1:47:44.44,1:47:46.68,Default,,0,0,0,,which itself points up to c2.
Dialogue: 0,1:47:46.68,1:47:48.40,Default,,0,0,0,,Because t3 had no siblings
Dialogue: 0,1:47:48.40,1:47:52.60,Default,,0,0,0,,the left and right sibling\Nlists in c3 are left empty.
Dialogue: 0,1:47:52.60,1:47:56.92,Default,,0,0,0,,Lastly, we can return up\Nthrough a path in this case c3.
Dialogue: 0,1:47:56.92,1:47:59.52,Default,,0,0,0,,When we do this we could create\Na new node to replace t3
Dialogue: 0,1:47:59.52,1:48:02.40,Default,,0,0,0,,which is why I've underlined t3\Nin the diagram at this point.
Dialogue: 0,1:48:02.40,1:48:04.48,Default,,0,0,0,,In any case, a new\Nzipper is constructed
Dialogue: 0,1:48:04.48,1:48:06.60,Default,,0,0,0,,focusing on the tree node\Nwe just traveled through
Dialogue: 0,1:48:06.60,1:48:10.24,Default,,0,0,0,,with the path back at\Nthe root as always.
Dialogue: 0,1:48:10.24,1:48:14.44,Default,,0,0,0,,This brings us to parsing with\Nzippers or PwZ for short.
Dialogue: 0,1:48:14.44,1:48:16.16,Default,,0,0,0,,We use zippers to save the location
Dialogue: 0,1:48:16.16,1:48:18.32,Default,,0,0,0,,where the derivative\Nwas successfully taken.
Dialogue: 0,1:48:18.32,1:48:21.08,Default,,0,0,0,,By doing this we eliminate\Nalmost all of the traversals
Dialogue: 0,1:48:21.08,1:48:24.20,Default,,0,0,0,,in the original parsing\Nwith derivatives algorithm.
Dialogue: 0,1:48:24.20,1:48:27.68,Default,,0,0,0,,We use a slightly modified zipper\Ndefinition compared to the original.
Dialogue: 0,1:48:27.68,1:48:29.88,Default,,0,0,0,,For one, we actually call\Nit a zipper in the code
Dialogue: 0,1:48:29.88,1:48:31.24,Default,,0,0,0,,instead of location.
Dialogue: 0,1:48:31.24,1:48:34.72,Default,,0,0,0,,We also rename tree to exp,\Nmeaning grammar expansions
Dialogue: 0,1:48:34.72,1:48:37.68,Default,,0,0,0,,and path to cxt meaning contexts.
Dialogue: 0,1:48:37.68,1:48:39.92,Default,,0,0,0,,All context constructors\Nend with a capital C
Dialogue: 0,1:48:39.92,1:48:43.08,Default,,0,0,0,,to indicate their status.
Dialogue: 0,1:48:43.08,1:48:46.40,Default,,0,0,0,,Now there is a problem with our\Nzipper implementation which is this.
Dialogue: 0,1:48:46.40,1:48:49.00,Default,,0,0,0,,It can't yet handle all\Ncontext-free grammars.
Dialogue: 0,1:48:49.00,1:48:52.20,Default,,0,0,0,,It can work fine for concatenation\Ntokens but that's it.
Dialogue: 0,1:48:52.20,1:48:54.20,Default,,0,0,0,,Many CFGs have alternates and cycles
Dialogue: 0,1:48:54.20,1:48:56.84,Default,,0,0,0,,which are part of what\Nmakes CFG so useful.
Dialogue: 0,1:48:56.84,1:48:57.92,Default,,0,0,0,,We'll have to improve our zipper
Dialogue: 0,1:48:57.92,1:49:01.16,Default,,0,0,0,,if we want to use it\Nfor parsing CFGs.
Dialogue: 0,1:49:01.16,1:49:03.40,Default,,0,0,0,,First, we look at supporting\Nalternates in the grammar.
Dialogue: 0,1:49:03.40,1:49:06.48,Default,,0,0,0,,This requires adding an alternate\Nconstructor to the exp type
Dialogue: 0,1:49:06.48,1:49:10.96,Default,,0,0,0,,and a corresponding alternate\Ncontext constructor to the cxt type.
Dialogue: 0,1:49:10.96,1:49:13.00,Default,,0,0,0,,Here we have a simple grammar.
Dialogue: 0,1:49:13.00,1:49:15.40,Default,,0,0,0,,The inverted triangle labeled\Na1 is an alternate node
Dialogue: 0,1:49:15.40,1:49:17.76,Default,,0,0,0,,and t1 and t2 are its children.
Dialogue: 0,1:49:17.76,1:49:20.72,Default,,0,0,0,,They should be processed\Nindependently of one another.
Dialogue: 0,1:49:20.72,1:49:23.88,Default,,0,0,0,,When the zipper moves through\Nthe alternate node a1 it splits.
Dialogue: 0,1:49:23.88,1:49:26.20,Default,,0,0,0,,We get two context\Nnodes and two zippers
Dialogue: 0,1:49:26.20,1:49:27.88,Default,,0,0,0,,which is exactly what we wanted.
Dialogue: 0,1:49:27.88,1:49:29.04,Default,,0,0,0,,Now the children of\Nan alternate node
Dialogue: 0,1:49:29.04,1:49:32.16,Default,,0,0,0,,are handled in\Na non-deterministic manner.
Dialogue: 0,1:49:32.16,1:49:33.68,Default,,0,0,0,,When we eventually traverse back up,
Dialogue: 0,1:49:33.68,1:49:36.84,Default,,0,0,0,,possibly modifying either or both\Nof the child nodes in the process
Dialogue: 0,1:49:36.84,1:49:39.56,Default,,0,0,0,,we create a new alternate\Nnode for each child.
Dialogue: 0,1:49:39.56,1:49:42.36,Default,,0,0,0,,These are handled independently\Nby the algorithm.
Dialogue: 0,1:49:42.36,1:49:45.28,Default,,0,0,0,,For non zipper grammars\Nthe solution is technically sufficient
Dialogue: 0,1:49:45.28,1:49:48.20,Default,,0,0,0,,however, there are\Nsome inefficiencies.
Dialogue: 0,1:49:48.20,1:49:51.60,Default,,0,0,0,,Here we have a situation where\Nthree expressions have been parsed
Dialogue: 0,1:49:51.60,1:49:54.20,Default,,0,0,0,,which all descend to\Na share expression t1.
Dialogue: 0,1:49:54.20,1:49:55.64,Default,,0,0,0,,There are three separate zippers
Dialogue: 0,1:49:55.64,1:49:58.04,Default,,0,0,0,,sitting between each of\Nthe associated context
Dialogue: 0,1:49:58.04,1:50:00.84,Default,,0,0,0,,and this t1 expression.
Dialogue: 0,1:50:00.84,1:50:03.72,Default,,0,0,0,,Parsing with the first zipper\Ncreates a new context c4
Dialogue: 0,1:50:03.72,1:50:07.04,Default,,0,0,0,,and a new zipper z4 which\Nsits between the new context
Dialogue: 0,1:50:07.04,1:50:09.96,Default,,0,0,0,,and the child expression t2.
Dialogue: 0,1:50:09.96,1:50:13.08,Default,,0,0,0,,Parsing with the second zipper\Ncreates an identical context and zipper
Dialogue: 0,1:50:13.08,1:50:14.84,Default,,0,0,0,,but they are separate\Nfrom the first ones
Dialogue: 0,1:50:14.84,1:50:17.56,Default,,0,0,0,,and the third zipper\Nwill do the same.
Dialogue: 0,1:50:17.56,1:50:20.88,Default,,0,0,0,,We now have three identical\Ncontexts all labeled c4
Dialogue: 0,1:50:20.88,1:50:23.64,Default,,0,0,0,,and three identical\Nzippers all labeled z4.
Dialogue: 0,1:50:23.64,1:50:25.28,Default,,0,0,0,,This is wasted effort.
Dialogue: 0,1:50:25.28,1:50:28.08,Default,,0,0,0,,Not only that but if we were to add\Nsupport for cycles at this point
Dialogue: 0,1:50:28.08,1:50:29.72,Default,,0,0,0,,the inefficiency could compound
Dialogue: 0,1:50:29.72,1:50:31.76,Default,,0,0,0,,and lead to the number of\Nzippers becoming exponential
Dialogue: 0,1:50:31.76,1:50:33.24,Default,,0,0,0,,with respect to\Nthe length of the input.
Dialogue: 0,1:50:33.24,1:50:35.60,Default,,0,0,0,,We can't have that.
Dialogue: 0,1:50:35.60,1:50:37.24,Default,,0,0,0,,Here is the code as\Nwe currently have it
Dialogue: 0,1:50:37.24,1:50:40.32,Default,,0,0,0,,but now we'll add memoization.
Dialogue: 0,1:50:40.32,1:50:43.68,Default,,0,0,0,,The memoization entries simply take\Nthe place of the child contexts
Dialogue: 0,1:50:43.68,1:50:47.80,Default,,0,0,0,,within each context type as\Nwell as within the zipper.
Dialogue: 0,1:50:47.80,1:50:50.68,Default,,0,0,0,,We now have a memoization\Ntable shown on the left.
Dialogue: 0,1:50:50.68,1:50:53.44,Default,,0,0,0,,Although the zipper is now actually\Npointing upwards to memoization entries
Dialogue: 0,1:50:53.44,1:50:55.52,Default,,0,0,0,,I've shown them here according\Nto the associated context
Dialogue: 0,1:50:55.52,1:50:57.60,Default,,0,0,0,,for visual simplicity.
Dialogue: 0,1:50:57.60,1:51:00.52,Default,,0,0,0,,When zipper z1 is attempts\Nto parse into expression t1
Dialogue: 0,1:51:00.52,1:51:02.24,Default,,0,0,0,,we'll add an entry to\Nthe memoization table
Dialogue: 0,1:51:02.24,1:51:05.00,Default,,0,0,0,,so subsequent derivations\Ndo not repeat work.
Dialogue: 0,1:51:05.00,1:51:07.44,Default,,0,0,0,,It is important that the table\Nentry is added before descending
Dialogue: 0,1:51:07.44,1:51:11.24,Default,,0,0,0,,or else you may still end up\Nwith redundant traversals.
Dialogue: 0,1:51:11.24,1:51:14.32,Default,,0,0,0,,When the first zipper z1 descends\Nthrough the expression t1
Dialogue: 0,1:51:14.32,1:51:16.56,Default,,0,0,0,,a new entry is added to\Nthe memoization table indexed
Dialogue: 0,1:51:16.56,1:51:19.36,Default,,0,0,0,,by a pair consisting of\Nthe current input token position
Dialogue: 0,1:51:19.36,1:51:22.44,Default,,0,0,0,,which we will call p here\Nand the expression.
Dialogue: 0,1:51:22.44,1:51:26.12,Default,,0,0,0,,The Zipper's context c1 is\Nadded to the parent's field.
Dialogue: 0,1:51:26.12,1:51:29.36,Default,,0,0,0,,When the derivative is complete\Nthe result field will be populated
Dialogue: 0,1:51:29.36,1:51:33.60,Default,,0,0,0,,and we will continue parsing\Nupwards through the parents.
Dialogue: 0,1:51:33.60,1:51:37.16,Default,,0,0,0,,Now, when zipper z2 attempts to\Nparse through expression t1
Dialogue: 0,1:51:37.16,1:51:39.24,Default,,0,0,0,,it first checks\Nthe memoization table.
Dialogue: 0,1:51:39.24,1:51:41.64,Default,,0,0,0,,If the current input\Ntoken position is still p
Dialogue: 0,1:51:41.64,1:51:43.72,Default,,0,0,0,,then the look up\Nthe table will succeed.
Dialogue: 0,1:51:43.72,1:51:45.40,Default,,0,0,0,,Instead of doing any\Nadditional processing
Dialogue: 0,1:51:45.40,1:51:49.84,Default,,0,0,0,,z2 will simply add its current\Ncontext c2 to the parent's field.
Dialogue: 0,1:51:49.84,1:51:52.56,Default,,0,0,0,,The last zipper z3 will do the same.
Dialogue: 0,1:51:52.56,1:51:53.88,Default,,0,0,0,,When the child zipper z4
Dialogue: 0,1:51:53.88,1:51:56.48,Default,,0,0,0,,eventually returns from parsing\Nthrough the t2 expression
Dialogue: 0,1:51:56.48,1:51:58.44,Default,,0,0,0,,and ascends up through\Nthe context c4
Dialogue: 0,1:51:58.44,1:52:00.48,Default,,0,0,0,,it will split again to\Nreturn the computed result
Dialogue: 0,1:52:00.48,1:52:04.36,Default,,0,0,0,,to each of the parent\Ncontexts c1, c2 and c3.
Dialogue: 0,1:52:04.36,1:52:05.72,Default,,0,0,0,,By using this memoization table
Dialogue: 0,1:52:05.72,1:52:07.32,Default,,0,0,0,,we have avoided creating\Nredundant zippers
Dialogue: 0,1:52:07.32,1:52:08.96,Default,,0,0,0,,when traversing down the grammar.
Dialogue: 0,1:52:08.96,1:52:12.68,Default,,0,0,0,,What happens when we\Ndecide to traverse up?
Dialogue: 0,1:52:12.68,1:52:14.92,Default,,0,0,0,,Here is an example where a zipper\Nis focused on an alternate
Dialogue: 0,1:52:14.92,1:52:16.48,Default,,0,0,0,,which has not been parsed yet.
Dialogue: 0,1:52:16.48,1:52:18.96,Default,,0,0,0,,So it has no entry in\Nthe memoization table.
Dialogue: 0,1:52:18.96,1:52:20.52,Default,,0,0,0,,The way the algorithm\Nworked at this point
Dialogue: 0,1:52:20.52,1:52:22.32,Default,,0,0,0,,causes two new zippers to be spanned
Dialogue: 0,1:52:22.32,1:52:25.16,Default,,0,0,0,,each pointing to a new\Nalt c context node.
Dialogue: 0,1:52:25.16,1:52:27.72,Default,,0,0,0,,Note that both contexts, c2 and c3,
Dialogue: 0,1:52:27.72,1:52:29.60,Default,,0,0,0,,point to the same memoization entry
Dialogue: 0,1:52:29.60,1:52:32.80,Default,,0,0,0,,for the a1 alternate expression\Nthat we just passed through.
Dialogue: 0,1:52:32.80,1:52:35.28,Default,,0,0,0,,Let's say zipper z2\Ndoes its work first
Dialogue: 0,1:52:35.28,1:52:38.00,Default,,0,0,0,,and returns up through context c2.
Dialogue: 0,1:52:38.00,1:52:40.44,Default,,0,0,0,,A new alt node is constructed, a2.
Dialogue: 0,1:52:40.44,1:52:42.84,Default,,0,0,0,,This is added to the result\Nfield of the old alternate node,
Dialogue: 0,1:52:42.84,1:52:46.40,Default,,0,0,0,,a1's memoization table entry.
Dialogue: 0,1:52:46.40,1:52:49.76,Default,,0,0,0,,When the second child zipper z3\Npasses up through context c3
Dialogue: 0,1:52:49.76,1:52:52.16,Default,,0,0,0,,it also creates a new alt node, a3.
Dialogue: 0,1:52:52.16,1:52:55.28,Default,,0,0,0,,This node is also added\Nto a1's result field.
Dialogue: 0,1:52:55.28,1:52:56.96,Default,,0,0,0,,Two alternate nodes\Nhave been created
Dialogue: 0,1:52:56.96,1:52:59.16,Default,,0,0,0,,and each has spawned a zipper\Nthat will navigate up
Dialogue: 0,1:52:59.16,1:53:02.08,Default,,0,0,0,,through parent context\Nc1, this is inefficient
Dialogue: 0,1:53:02.08,1:53:04.88,Default,,0,0,0,,and similar to the problem\Nwith unshared expressions
Dialogue: 0,1:53:04.88,1:53:06.88,Default,,0,0,0,,the situation can lead to\Nan exponential blow-up
Dialogue: 0,1:53:06.88,1:53:08.52,Default,,0,0,0,,in the number of zippers spawned
Dialogue: 0,1:53:08.52,1:53:11.32,Default,,0,0,0,,when deriving over a cyclic grammar.
Dialogue: 0,1:53:11.32,1:53:13.68,Default,,0,0,0,,To address this we will\Nadjust our memoization code
Dialogue: 0,1:53:13.68,1:53:17.60,Default,,0,0,0,,to also memoize contexts in\Naddition to expressions.
Dialogue: 0,1:53:17.60,1:53:19.92,Default,,0,0,0,,Because the situation only\Narises for alternate nodes
Dialogue: 0,1:53:19.92,1:53:21.56,Default,,0,0,0,,we simply extend the alt constructor
Dialogue: 0,1:53:21.56,1:53:23.88,Default,,0,0,0,,to have a mutable list\Nof child expressions.
Dialogue: 0,1:53:23.88,1:53:26.68,Default,,0,0,0,,This will allow us to incrementally\Nupdate a constructed alt nodes
Dialogue: 0,1:53:26.68,1:53:30.32,Default,,0,0,0,,list of children as new zippers\Nreturn up through the tree.
Dialogue: 0,1:53:30.32,1:53:32.08,Default,,0,0,0,,We also now only need\Na single expression
Dialogue: 0,1:53:32.08,1:53:34.92,Default,,0,0,0,,to be saved in the result field\Nof the memoization entry.
Dialogue: 0,1:53:34.92,1:53:37.72,Default,,0,0,0,,Let's see how it works.
Dialogue: 0,1:53:37.72,1:53:39.08,Default,,0,0,0,,We start back at this point
Dialogue: 0,1:53:39.08,1:53:41.92,Default,,0,0,0,,where a zipper has just passed up\Nthrough an alt c alternate context
Dialogue: 0,1:53:41.92,1:53:44.52,Default,,0,0,0,,and created a new alternate node a2.
Dialogue: 0,1:53:44.52,1:53:48.72,Default,,0,0,0,,The node is added as the lone\Nresult in the memoization table.
Dialogue: 0,1:53:48.72,1:53:50.56,Default,,0,0,0,,When the second zipper\Nmoves up in the tree
Dialogue: 0,1:53:50.56,1:53:53.12,Default,,0,0,0,,it simply modifies\Nthe existing a2 node.
Dialogue: 0,1:53:53.12,1:53:54.84,Default,,0,0,0,,Now, there is only\None zipper created
Dialogue: 0,1:53:54.84,1:53:56.88,Default,,0,0,0,,above the newly\Nconstructed alternate node
Dialogue: 0,1:53:56.88,1:53:59.52,Default,,0,0,0,,and we have avoided\Nthe potential exponential behavior
Dialogue: 0,1:53:59.52,1:54:01.88,Default,,0,0,0,,we would have had earlier.
Dialogue: 0,1:54:01.88,1:54:04.12,Default,,0,0,0,,While adding memoization to\Nreduce inefficiencies
Dialogue: 0,1:54:04.12,1:54:06.28,Default,,0,0,0,,I mentioned some concerns\Nabout a hypothetical future
Dialogue: 0,1:54:06.28,1:54:07.84,Default,,0,0,0,,when we support cyclic grammars.
Dialogue: 0,1:54:07.84,1:54:10.44,Default,,0,0,0,,Have no fear, the time\Nhas come to handle cycles
Dialogue: 0,1:54:10.44,1:54:14.08,Default,,0,0,0,,and behold, they are\Nhandled already.
Dialogue: 0,1:54:14.08,1:54:15.76,Default,,0,0,0,,Where recursive descent\Nparsers face a dilemma
Dialogue: 0,1:54:15.76,1:54:18.96,Default,,0,0,0,,in choosing how times to\Ndescend into a left recursion
Dialogue: 0,1:54:18.96,1:54:21.12,Default,,0,0,0,,we side step the issue entirely.
Dialogue: 0,1:54:21.12,1:54:24.36,Default,,0,0,0,,Our memoization strategy automatically\Nconverts cycles in the grammar
Dialogue: 0,1:54:24.36,1:54:26.40,Default,,0,0,0,,into cycles in the contexts.
Dialogue: 0,1:54:26.40,1:54:28.48,Default,,0,0,0,,This allows us to postpone\Nmaking any choices
Dialogue: 0,1:54:28.48,1:54:29.80,Default,,0,0,0,,until further parsing reveals
Dialogue: 0,1:54:29.80,1:54:32.28,Default,,0,0,0,,how many repetitions\Nare actually needed.
Dialogue: 0,1:54:32.28,1:54:33.92,Default,,0,0,0,,The diagram for this\Nis a bit complex
Dialogue: 0,1:54:33.92,1:54:35.76,Default,,0,0,0,,so I suggest reading\Nsection 7 of our paper
Dialogue: 0,1:54:35.76,1:54:38.60,Default,,0,0,0,,for more detailed explanation.
Dialogue: 0,1:54:38.60,1:54:41.88,Default,,0,0,0,,With that, the fundamental theory\Nof our algorithm is laid out
Dialogue: 0,1:54:41.88,1:54:43.56,Default,,0,0,0,,but there remains one more\Nadvancement to discuss
Dialogue: 0,1:54:43.56,1:54:46.24,Default,,0,0,0,,prior to looking at the evaluation.
Dialogue: 0,1:54:46.24,1:54:48.32,Default,,0,0,0,,We can completely eliminate\Nthe memoization tables
Dialogue: 0,1:54:48.32,1:54:50.20,Default,,0,0,0,,and I'll show why.
Dialogue: 0,1:54:50.20,1:54:52.56,Default,,0,0,0,,All our memoization are indexed\Nby the current input position
Dialogue: 0,1:54:52.56,1:54:54.40,Default,,0,0,0,,but we parse\Nthe input consequentially
Dialogue: 0,1:54:54.40,1:54:57.40,Default,,0,0,0,,so there is never a need\Nto maintain old entries.
Dialogue: 0,1:54:57.40,1:54:59.04,Default,,0,0,0,,We eliminate\Nthe position as an index
Dialogue: 0,1:54:59.04,1:55:01.04,Default,,0,0,0,,and instead make two\Nfields in the table entry
Dialogue: 0,1:55:01.04,1:55:02.72,Default,,0,0,0,,to denote the start\Nand end positions
Dialogue: 0,1:55:02.72,1:55:06.00,Default,,0,0,0,,corresponding to a successful parse.
Dialogue: 0,1:55:06.68,1:55:08.44,Default,,0,0,0,,However, since this table is now\Nindexed only by an expression
Dialogue: 0,1:55:08.44,1:55:10.40,Default,,0,0,0,,we can actually\Neliminate it entirely
Dialogue: 0,1:55:10.40,1:55:13.88,Default,,0,0,0,,and simply put a memoization entry\Ninside each expression automatically
Dialogue: 0,1:55:14.88,1:55:16.92,Default,,0,0,0,,Here is the code as it existed\Nwith the memoization table.
Dialogue: 0,1:55:18.16,1:55:20.84,Default,,0,0,0,,And here is the code which\Neliminates memoization tables.
Dialogue: 0,1:55:21.36,1:55:23.00,Default,,0,0,0,,We now have a new definition of EXP
Dialogue: 0,1:55:23.00,1:55:24.68,Default,,0,0,0,,which contains a memoization record
Dialogue: 0,1:55:25.16,1:55:27.96,Default,,0,0,0,,and an EXP prime which was\Npreviously called EXP.
Dialogue: 0,1:55:28.96,1:55:32.24,Default,,0,0,0,,The memoization entries now record\Nstart and end positions associated
Dialogue: 0,1:55:32.76,1:55:33.76,Default,,0,0,0,,with successful parses
Dialogue: 0,1:55:34.24,1:55:35.68,Default,,0,0,0,,allowing the algorithm\Nto quickly discern
Dialogue: 0,1:55:35.68,1:55:37.00,Default,,0,0,0,,whether the entry has grown stale.
Dialogue: 0,1:55:37.72,1:55:39.28,Default,,0,0,0,,And with that, the work is done.
Dialogue: 0,1:55:40.76,1:55:42.28,Default,,0,0,0,,Let's briefly look at our\Nperformance evaluation.
Dialogue: 0,1:55:43.52,1:55:47.32,Default,,0,0,0,,We ran parsing with Zippers over\Nthe Python 3.4.3 standard library
Dialogue: 0,1:55:47.32,1:55:49.16,Default,,0,0,0,,and compared the results\Nto a few other parsers.
Dialogue: 0,1:55:49.88,1:55:52.24,Default,,0,0,0,,Parse derivatives\Nfrom Mike et al, 2011.
Dialogue: 0,1:55:53.00,1:55:56.00,Default,,0,0,0,,Optimized parse derivatives\Nfrom Adams et al, 2016.
Dialogue: 0,1:55:56.48,1:55:58.92,Default,,0,0,0,,Menhir an LRK parsing\Ngenerator from Ocaml
Dialogue: 0,1:55:59.68,1:56:02.20,Default,,0,0,0,,and Deep gen a GLR partial\Ngenerator for Ocaml.
Dialogue: 0,1:56:03.68,1:56:05.20,Default,,0,0,0,,The parsing with\Nderivatives implementation
Dialogue: 0,1:56:05.20,1:56:06.80,Default,,0,0,0,,had to be ported from\NRacket to OCaml
Dialogue: 0,1:56:06.80,1:56:09.76,Default,,0,0,0,,and Menhir's LRK limitations\Nrequire that we reformulate
Dialogue: 0,1:56:09.76,1:56:12.24,Default,,0,0,0,,some of the Python grammar to\Navoid potential ambiguities
Dialogue: 0,1:56:12.24,1:56:13.64,Default,,0,0,0,,that might distort our comparisons.
Dialogue: 0,1:56:14.40,1:56:16.28,Default,,0,0,0,,We run the benchmarks on\Nthe digital ocean droplet
Dialogue: 0,1:56:16.28,1:56:17.40,Default,,0,0,0,,with a dedicated CPU
Dialogue: 0,1:56:17.40,1:56:19.80,Default,,0,0,0,,to ensure we did not introduce\Nany sources of invalidity
Dialogue: 0,1:56:19.80,1:56:20.80,Default,,0,0,0,,due to other tasks.
Dialogue: 0,1:56:22.56,1:56:25.44,Default,,0,0,0,,The results show that parsing with\Nzippers significantly outperform
Dialogue: 0,1:56:25.44,1:56:27.24,Default,,0,0,0,,the original parsing with\Nderivatives algorithm
Dialogue: 0,1:56:27.24,1:56:29.64,Default,,0,0,0,,and even outperforms\Nthe optimized version of PwD
Dialogue: 0,1:56:29.64,1:56:31.72,Default,,0,0,0,,that relies on many low level\Ntunings and adjustments
Dialogue: 0,1:56:31.72,1:56:32.72,Default,,0,0,0,,to the app algorithm.
Dialogue: 0,1:56:33.48,1:56:36.32,Default,,0,0,0,,Although PWZ does not surpass\Nthe pressure generators in our test
Dialogue: 0,1:56:36.32,1:56:37.80,Default,,0,0,0,,we believe the result\Nto be significant
Dialogue: 0,1:56:37.80,1:56:39.52,Default,,0,0,0,,because of the simplicity\Nof the algorithm.
Dialogue: 0,1:56:40.00,1:56:41.48,Default,,0,0,0,,At only around\Na hundred lines of code,
Dialogue: 0,1:56:41.48,1:56:43.68,Default,,0,0,0,,parsing with zippers is simple\Nenough to be written by hand
Dialogue: 0,1:56:43.68,1:56:45.96,Default,,0,0,0,,and yet it is fairly competitive\Nas long as performance
Dialogue: 0,1:56:45.96,1:56:47.16,Default,,0,0,0,,is not absolutely crucial.
Dialogue: 0,1:56:47.68,1:56:49.44,Default,,0,0,0,,Additionally we claim\Nparsing with zippers
Dialogue: 0,1:56:49.44,1:56:50.72,Default,,0,0,0,,can handle all context free grammars
Dialogue: 0,1:56:50.72,1:56:52.32,Default,,0,0,0,,even with recursions\Nand ambiguities
Dialogue: 0,1:56:52.32,1:56:53.60,Default,,0,0,0,,which Menhir cannot do.
Dialogue: 0,1:56:54.56,1:56:57.44,Default,,0,0,0,,So we have introduced\Nparsing with zippers,
Dialogue: 0,1:56:57.44,1:56:58.84,Default,,0,0,0,,a new general parsing algorithm
Dialogue: 0,1:56:58.84,1:56:59.84,Default,,0,0,0,,that is simple to implement,
Dialogue: 0,1:56:59.84,1:57:01.32,Default,,0,0,0,,it provides surprisingly\Ngood performance.
Dialogue: 0,1:57:02.56,1:57:04.92,Default,,0,0,0,,Parsing with derivatives generalize\Nthe Bruzewski derivative
Dialogue: 0,1:57:04.92,1:57:07.04,Default,,0,0,0,,from regular expressions to\Ncontext free grammars.
Dialogue: 0,1:57:07.56,1:57:09.84,Default,,0,0,0,,We have generalized\Nthe zipper from tree structures
Dialogue: 0,1:57:09.84,1:57:11.04,Default,,0,0,0,,to context free grammars.
Dialogue: 0,1:57:11.76,1:57:13.88,Default,,0,0,0,,We also consider\Nasymptotic complexity,
Dialogue: 0,1:57:13.88,1:57:15.28,Default,,0,0,0,,other divergences from PwD
Dialogue: 0,1:57:15.76,1:57:17.08,Default,,0,0,0,,and a few more points\Nin the discussion
Dialogue: 0,1:57:17.08,1:57:18.72,Default,,0,0,0,,and evaluation sections of the paper
Dialogue: 0,1:57:18.72,1:57:19.72,Default,,0,0,0,,which I would encourage you to read
Dialogue: 0,1:57:19.72,1:57:21.36,Default,,0,0,0,,if you have further questions\Nthat I did not address.
Dialogue: 0,1:57:22.60,1:57:24.84,Default,,0,0,0,,I hope you have enjoyed this\Npresentation of parsing with Zippers,
Dialogue: 0,1:57:24.84,1:57:27.36,Default,,0,0,0,,a Function Pearl, by\NPierce Darragh, that's me
Dialogue: 0,1:57:27.36,1:57:28.48,Default,,0,0,0,,and Michael D. Adams.
Dialogue: 0,1:57:29.24,1:57:30.36,Default,,0,0,0,,Please feel free to contact us
Dialogue: 0,1:57:30.36,1:57:32.04,Default,,0,0,0,,if you have any additional\Nquestions or comments.
Dialogue: 0,1:57:32.76,1:57:33.76,Default,,0,0,0,,Thank you.
Dialogue: 0,1:57:39.04,1:57:44.04,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:57:47.40,1:57:48.40,Default,,0,0,0,,RICHARD: Thanks very much Pierce.
Dialogue: 0,1:57:49.16,1:57:50.52,Default,,0,0,0,,In the New York time band,
Dialogue: 0,1:57:50.52,1:57:53.48,Default,,0,0,0,,the authors are now available\Nfor question and answer.
Dialogue: 0,1:57:54.72,1:57:56.16,Default,,0,0,0,,I'm afraid not in\Nthe Asia time band.
Dialogue: 0,1:58:02.40,1:58:05.52,Default,,0,0,0,,OK, last up in this session\Nwe have Timothee Haudebourg
Dialogue: 0,1:58:05.52,1:58:08.56,Default,,0,0,0,,presenting Regular Language Type\NInference with Term Rewriting.
Dialogue: 0,1:58:10.56,1:58:11.64,Default,,0,0,0,,TIMOTHEE HAUDEBOURG: Hello everyone.
Dialogue: 0,1:58:11.64,1:58:13.32,Default,,0,0,0,,My name is Timothee Haudebourg.
Dialogue: 0,1:58:13.32,1:58:16.56,Default,,0,0,0,,And in this presentation we will\Nbe talking about our latest work
Dialogue: 0,1:58:16.56,1:58:20.00,Default,,0,0,0,,on the automatic verification of\Nhigher-order functional programs
Dialogue: 0,1:58:20.72,1:58:23.96,Default,,0,0,0,,where we designed a Regular\Nlanguage Type Inference system
Dialogue: 0,1:58:23.96,1:58:25.36,Default,,0,0,0,,using term rewriting.
Dialogue: 0,1:58:26.60,1:58:29.48,Default,,0,0,0,,This is joint work with Thomas\NGenet and Thomas Jensen
Dialogue: 0,1:58:29.48,1:58:32.20,Default,,0,0,0,,at the French institute for\Nresearch and computer science.
Dialogue: 0,1:58:33.20,1:58:34.68,Default,,0,0,0,,And the things that\Nwe have developed
Dialogue: 0,1:58:34.68,1:58:37.20,Default,,0,0,0,,is dedicated to the fully\Nautomatic verification
Dialogue: 0,1:58:37.20,1:58:41.12,Default,,0,0,0,,of higher-order functional program\Nprocessing algebraic data
Dialogue: 0,1:58:42.12,1:58:44.20,Default,,0,0,0,,types. What see on this\Nslide is an example
Dialogue: 0,1:58:44.20,1:58:45.48,Default,,0,0,0,,of what we are going to achieve.
Dialogue: 0,1:58:45.96,1:58:48.04,Default,,0,0,0,,On the left side is a user input.
Dialogue: 0,1:58:48.56,1:58:50.76,Default,,0,0,0,,It is a higher-order\Nfunctional program
Dialogue: 0,1:58:50.76,1:58:54.40,Default,,0,0,0,,written for the purpose of\Nthe presentation in OCaml.
Dialogue: 0,1:58:54.40,1:58:56.64,Default,,0,0,0,,It defines a recursive function sort
Dialogue: 0,1:58:56.64,1:58:59.28,Default,,0,0,0,,that implements\Nan insertion sort algorithms
Dialogue: 0,1:58:59.28,1:59:01.40,Default,,0,0,0,,taking as parameters\Na comparison function.
Dialogue: 0,1:59:02.40,1:59:06.88,Default,,0,0,0,,And also a sorted predicate that verifies\Nthat the list is indeed sorted
Dialogue: 0,1:59:06.88,1:59:09.12,Default,,0,0,0,,according to the same\Ninput comparison function.
Dialogue: 0,1:59:09.64,1:59:13.88,Default,,0,0,0,,The right side shows that we imagine\Ncould be the user interface.
Dialogue: 0,1:59:13.88,1:59:17.20,Default,,0,0,0,,Here the user can type in the\Nproperty he wants to verify.
Dialogue: 0,1:59:17.68,1:59:21.52,Default,,0,0,0,,So here for example, we want\Nto verify that for all list l
Dialogue: 0,1:59:21.52,1:59:24.52,Default,,0,0,0,,the output of the sort\Nfunction is indeed sorted
Dialogue: 0,1:59:24.52,1:59:26.80,Default,,0,0,0,,according to the corresponding predicate.
Dialogue: 0,1:59:26.80,1:59:31.12,Default,,0,0,0,,Note that the property uses predicates\Nthat are defined in the program
Dialogue: 0,1:59:31.12,1:59:32.80,Default,,0,0,0,,and without any more information
Dialogue: 0,1:59:32.80,1:59:36.48,Default,,0,0,0,,without annotation, we are able to\Ncheck if the property is verified
Dialogue: 0,1:59:37.00,1:59:38.60,Default,,0,0,0,,or find a counterexample.
Dialogue: 0,1:59:39.60,1:59:42.60,Default,,0,0,0,,If the property cannot be verified\Nwith a regular abstraction
Dialogue: 0,1:59:42.60,1:59:44.32,Default,,0,0,0,,of the program, it will diverge.
Dialogue: 0,1:59:45.60,1:59:47.96,Default,,0,0,0,,To understand why our\Ncontribution was necessary
Dialogue: 0,1:59:48.44,1:59:51.00,Default,,0,0,0,,in how it relates to\Nother higher-order functional
Dialogue: 0,1:59:51.00,1:59:52.92,Default,,0,0,0,,program verification techniques
Dialogue: 0,1:59:52.92,1:59:55.48,Default,,0,0,0,,I'd like to place every\Ntechnique on this diagram.
Dialogue: 0,1:59:56.00,1:59:59.52,Default,,0,0,0,,Many properties can be verified\Nby simplifying or abstracting
Dialogue: 0,1:59:59.52,2:00:02.32,Default,,0,0,0,,the behavior of the input\Nprogram in a certain way
Dialogue: 0,2:00:02.80,2:00:05.00,Default,,0,0,0,,so we can classify\Nverification techniques
Dialogue: 0,2:00:05.00,2:00:08.20,Default,,0,0,0,,according to the abstraction\Nthey can generate.
Dialogue: 0,2:00:08.72,2:00:11.88,Default,,0,0,0,,On the bottom we put techniques\Nthat can verify properties
Dialogue: 0,2:00:11.88,2:00:13.72,Default,,0,0,0,,with any regular abstraction.
Dialogue: 0,2:00:14.24,2:00:16.96,Default,,0,0,0,,On the top we put techniques\Nthat can verify property
Dialogue: 0,2:00:16.96,2:00:18.20,Default,,0,0,0,,with any abstraction.
Dialogue: 0,2:00:18.96,2:00:22.96,Default,,0,0,0,,Overall, this axis measures a range\Nof properties that can be verified
Dialogue: 0,2:00:22.96,2:00:23.96,Default,,0,0,0,,by the technique.
Dialogue: 0,2:00:24.44,2:00:28.04,Default,,0,0,0,,On left to right, we measure\Nhow much a user is active
Dialogue: 0,2:00:28.04,2:00:29.28,Default,,0,0,0,,during the verification.
Dialogue: 0,2:00:30.76,2:00:33.56,Default,,0,0,0,,On the left we have fully\Nautomatic techniques
Dialogue: 0,2:00:33.56,2:00:35.52,Default,,0,0,0,,and on the right manual techniques.
Dialogue: 0,2:00:37.28,2:00:40.44,Default,,0,0,0,,Proof assistants such\Nas Coq, Isabelle HOL
Dialogue: 0,2:00:40.44,2:00:41.92,Default,,0,0,0,,can be placed in this region.
Dialogue: 0,2:00:42.44,2:00:44.56,Default,,0,0,0,,They can verify a large\Nrange of properties
Dialogue: 0,2:00:45.56,2:00:47.16,Default,,0,0,0,,but require a lot of manual work.
Dialogue: 0,2:00:47.92,2:00:49.76,Default,,0,0,0,,Refinement type inference techniques
Dialogue: 0,2:00:49.76,2:00:52.20,Default,,0,0,0,,which can be seen in\Nthe Liquid types or F star
Dialogue: 0,2:00:52.20,2:00:53.72,Default,,0,0,0,,require less manual work.
Dialogue: 0,2:00:53.72,2:00:55.88,Default,,0,0,0,,So the user only needs\Nto give some hints
Dialogue: 0,2:00:55.88,2:00:58.48,Default,,0,0,0,,usually as program type annotations
Dialogue: 0,2:00:58.48,2:01:02.24,Default,,0,0,0,,however the range of verifiable\Nproperties is reduced.
Dialogue: 0,2:01:03.24,2:01:05.36,Default,,0,0,0,,Fully automated techniques\Nhave been developed
Dialogue: 0,2:01:05.36,2:01:09.04,Default,,0,0,0,,around higher-order model checking,\Npredicate abstraction and more.
Dialogue: 0,2:01:10.04,2:01:12.76,Default,,0,0,0,,These techniques do not\Nrequire any annotations
Dialogue: 0,2:01:12.76,2:01:15.40,Default,,0,0,0,,but mainly focus on\Nrelational properties
Dialogue: 0,2:01:15.40,2:01:16.84,Default,,0,0,0,,over numerical data types.
Dialogue: 0,2:01:17.60,2:01:20.68,Default,,0,0,0,,And are generally not good at\Nverifying regular properties
Dialogue: 0,2:01:20.68,2:01:22.76,Default,,0,0,0,,over algebraic data types.
Dialogue: 0,2:01:23.52,2:01:26.68,Default,,0,0,0,,There have been some attempts to\Nfully automatic verification
Dialogue: 0,2:01:26.68,2:01:30.12,Default,,0,0,0,,of regular properties including\Nour previous work in Timbuk
Dialogue: 0,2:01:30.64,2:01:33.44,Default,,0,0,0,,although these techniques are\Nincomplete and not scalable.
Dialogue: 0,2:01:34.20,2:01:36.60,Default,,0,0,0,,In our paper, we\Npropose a new technique
Dialogue: 0,2:01:36.60,2:01:38.52,Default,,0,0,0,,that is complete on\Nregular properties
Dialogue: 0,2:01:38.52,2:01:40.84,Default,,0,0,0,,and modular to scale better.
Dialogue: 0,2:01:41.60,2:01:44.00,Default,,0,0,0,,In our work we use term\Nrewriting systems
Dialogue: 0,2:01:44.52,2:01:46.48,Default,,0,0,0,,to model programs\Nand their semantics
Dialogue: 0,2:01:46.48,2:01:49.04,Default,,0,0,0,,and we use regular language\Nof terms as types.
Dialogue: 0,2:01:49.80,2:01:52.96,Default,,0,0,0,,Which we are able to\Nautomatically infer using regular
Dialogue: 0,2:01:52.96,2:01:54.40,Default,,0,0,0,,invariant learning techniques.
Dialogue: 0,2:01:55.40,2:01:58.00,Default,,0,0,0,,Before I detail this type\Ninference technique
Dialogue: 0,2:01:58.00,2:02:02.40,Default,,0,0,0,,let's start by an introduction\Nof our theoretical frameworks.
Dialogue: 0,2:02:03.16,2:02:05.60,Default,,0,0,0,,Terms, language and rewriting systems.
Dialogue: 0,2:02:06.36,2:02:10.04,Default,,0,0,0,,The term is a labeled tree that we\Nusually represent like this.
Dialogue: 0,2:02:10.52,2:02:14.44,Default,,0,0,0,,It is composed of a symbol f\Nliving in a ranked alphabet
Dialogue: 0,2:02:14.44,2:02:17.08,Default,,0,0,0,,and n subterms t1 to tn.
Dialogue: 0,2:02:17.56,2:02:20.08,Default,,0,0,0,,Where n is the arity of the symbol f.
Dialogue: 0,2:02:21.08,2:02:24.72,Default,,0,0,0,,We call a pattern a term that\Nhas a variable in it.
Dialogue: 0,2:02:25.20,2:02:28.76,Default,,0,0,0,,Terms are useful to represent\Nfunctional language expressions.
Dialogue: 0,2:02:28.76,2:02:32.88,Default,,0,0,0,,This slide shows how OCaml expressions\Ncan be translated into terms.
Dialogue: 0,2:02:33.64,2:02:35.04,Default,,0,0,0,,Constants do not change,
Dialogue: 0,2:02:35.04,2:02:36.32,Default,,0,0,0,,they have no subterms
Dialogue: 0,2:02:37.04,2:02:40.40,Default,,0,0,0,,unless it is a number in which\Ncase we'll represent it by a tree
Dialogue: 0,2:02:40.40,2:02:42.56,Default,,0,0,0,,using Peano's number\Nrepresentation.
Dialogue: 0,2:02:43.32,2:02:45.40,Default,,0,0,0,,Functions and applications\Ncan be translated
Dialogue: 0,2:02:45.40,2:02:50.04,Default,,0,0,0,,into a term where the arity of\Nthe symbol is the arity of the function
Dialogue: 0,2:02:50.04,2:02:51.60,Default,,0,0,0,,and the subterms are parameters.
Dialogue: 0,2:02:53.12,2:02:56.48,Default,,0,0,0,,However this representation does\Nnot allow partial application of f.
Dialogue: 0,2:02:56.48,2:02:59.60,Default,,0,0,0,,So instead we use the special\N@ symbol to represent
Dialogue: 0,2:02:59.60,2:03:02.48,Default,,0,0,0,,a function application\Nwhich takes a function
Dialogue: 0,2:03:02.48,2:03:04.40,Default,,0,0,0,,and its first parameter.
Dialogue: 0,2:03:04.92,2:03:07.48,Default,,0,0,0,,Control structures such as if-then-else
Dialogue: 0,2:03:07.48,2:03:09.32,Default,,0,0,0,,are simply represented as terms.
Dialogue: 0,2:03:10.08,2:03:13.04,Default,,0,0,0,,Finally let bindings\Nand anonymous functions
Dialogue: 0,2:03:13.04,2:03:16.88,Default,,0,0,0,,are erased living only\Nthe bound body here k.
Dialogue: 0,2:03:17.64,2:03:19.20,Default,,0,0,0,,This is because the program's logic
Dialogue: 0,2:03:19.20,2:03:22.40,Default,,0,0,0,,is preserved elsewhere as\Na term writing system.
Dialogue: 0,2:03:22.88,2:03:26.52,Default,,0,0,0,,A term rewriting system defines\Na set of rewriting rules
Dialogue: 0,2:03:26.52,2:03:29.12,Default,,0,0,0,,between patterns that encode\Nthe program's logic.
Dialogue: 0,2:03:29.64,2:03:32.28,Default,,0,0,0,,Here is an example\Nof the OCaml program
Dialogue: 0,2:03:32.28,2:03:34.60,Default,,0,0,0,,defining the sorted\Npredicate function on top.
Dialogue: 0,2:03:35.84,2:03:38.92,Default,,0,0,0,,Translated it into a rewriting\Nsystem on the bottom.
Dialogue: 0,2:03:38.92,2:03:40.92,Default,,0,0,0,,Because there are a lot of\Nfunction applications
Dialogue: 0,2:03:40.92,2:03:42.52,Default,,0,0,0,,you see a lot of @ symbols
Dialogue: 0,2:03:43.24,2:03:44.40,Default,,0,0,0,,which takes a lot of room
Dialogue: 0,2:03:44.40,2:03:45.84,Default,,0,0,0,,and is hard to read.
Dialogue: 0,2:03:46.60,2:03:49.60,Default,,0,0,0,,To simplify, we will write\Nspace between the function
Dialogue: 0,2:03:49.60,2:03:52.48,Default,,0,0,0,,and it's parameters instead\Nof @ just like this.
Dialogue: 0,2:03:53.48,2:03:56.56,Default,,0,0,0,,Underlined elements are\Nthe variables of the patterns.
Dialogue: 0,2:03:57.56,2:04:00.08,Default,,0,0,0,,We see that each pattern\Nmatching rule on the top
Dialogue: 0,2:04:00.08,2:04:03.72,Default,,0,0,0,,is translated into the one or more\Nrewriting rules on the bottom.
Dialogue: 0,2:04:04.24,2:04:06.68,Default,,0,0,0,,Rewriting system can also\Nbe used to describe
Dialogue: 0,2:04:06.68,2:04:09.60,Default,,0,0,0,,a regular language of\Nterms as tree automata.
Dialogue: 0,2:04:10.32,2:04:12.64,Default,,0,0,0,,Here is for instance on the right.
Dialogue: 0,2:04:12.64,2:04:15.80,Default,,0,0,0,,The tree automaton\Nrecognizing every natural number
Dialogue: 0,2:04:15.80,2:04:19.96,Default,,0,0,0,,which can be used to partially\Nrepresent the int type in OCaml.
Dialogue: 0,2:04:20.44,2:04:25.64,Default,,0,0,0,,So rewriting rule defines\Nthat 0 rewrites into int
Dialogue: 0,2:04:25.64,2:04:27.08,Default,,0,0,0,,because it is int
Dialogue: 0,2:04:27.08,2:04:30.80,Default,,0,0,0,,and s of int as you saw is also int.
Dialogue: 0,2:04:30.80,2:04:34.88,Default,,0,0,0,,In fact true automata can model\Nany algebraic data type of OCaml.
Dialogue: 0,2:04:34.88,2:04:38.68,Default,,0,0,0,,Here is the tree automata for\Nthe following type of integer list.
Dialogue: 0,2:04:38.68,2:04:41.68,Default,,0,0,0,,It defines two more\Nrules for nil and cons
Dialogue: 0,2:04:41.68,2:04:44.56,Default,,0,0,0,,that closely match\Nthe OCaml type definition.
Dialogue: 0,2:04:44.56,2:04:47.12,Default,,0,0,0,,Tree automata can even\Nrepresent regular language
Dialogue: 0,2:04:47.12,2:04:49.60,Default,,0,0,0,,that are not possible\Nto define in OCaml.
Dialogue: 0,2:04:49.60,2:04:53.56,Default,,0,0,0,,For instance, here is tree automata\Nrecognizing even numbers.
Dialogue: 0,2:04:54.08,2:04:56.60,Default,,0,0,0,,This can be seen as\Nthe subtype of int.
Dialogue: 0,2:04:56.60,2:05:00.32,Default,,0,0,0,,In our case we call it\Na regular language type.
Dialogue: 0,2:05:00.32,2:05:03.72,Default,,0,0,0,,Now that we are familiarized\Nwith rewriting systems
Dialogue: 0,2:05:03.72,2:05:05.56,Default,,0,0,0,,and regular language types
Dialogue: 0,2:05:05.56,2:05:08.04,Default,,0,0,0,,let's dive into our\Nverification technique.
Dialogue: 0,2:05:09.04,2:05:11.76,Default,,0,0,0,,Remember that in our initial example
Dialogue: 0,2:05:11.76,2:05:16.20,Default,,0,0,0,,the user wants to verify that\Nin his program for all list l
Dialogue: 0,2:05:16.20,2:05:17.96,Default,,0,0,0,,the output of sort l
Dialogue: 0,2:05:17.96,2:05:20.64,Default,,0,0,0,,is sorted according to\Nthe corresponding predicate.
Dialogue: 0,2:05:21.64,2:05:25.16,Default,,0,0,0,,In our verification settings,\Nthis problem is first translated
Dialogue: 0,2:05:25.16,2:05:26.56,Default,,0,0,0,,into a rewriting problem.
Dialogue: 0,2:05:27.28,2:05:29.92,Default,,0,0,0,,Here it states that for all term l
Dialogue: 0,2:05:29.92,2:05:31.72,Default,,0,0,0,,in the regular language of lists
Dialogue: 0,2:05:32.20,2:05:33.72,Default,,0,0,0,,and for all term v
Dialogue: 0,2:05:34.44,2:05:36.60,Default,,0,0,0,,if the input term rewrites into v
Dialogue: 0,2:05:36.60,2:05:38.48,Default,,0,0,0,,then v must be equal to true.
Dialogue: 0,2:05:38.96,2:05:41.08,Default,,0,0,0,,In particular, it cannot be false.
Dialogue: 0,2:05:41.84,2:05:43.36,Default,,0,0,0,,So list must be sorted.
Dialogue: 0,2:05:44.60,2:05:47.96,Default,,0,0,0,,The arrow relation is defined\Nby the term writing system
Dialogue: 0,2:05:47.96,2:05:50.40,Default,,0,0,0,,translating from the input program.
Dialogue: 0,2:05:52.40,2:05:56.40,Default,,0,0,0,,As we have seen earlier, regular\Nlanguages can be seen as types.
Dialogue: 0,2:05:57.64,2:06:01.28,Default,,0,0,0,,So we then translate our problem\Ninto a type checking problem
Dialogue: 0,2:06:01.28,2:06:04.32,Default,,0,0,0,,where we need to check that\Nthe following term is well typed
Dialogue: 0,2:06:04.32,2:06:06.20,Default,,0,0,0,,using regular language types.
Dialogue: 0,2:06:07.20,2:06:11.68,Default,,0,0,0,,The overall target type is a regular\Nlanguage containing only the term true.
Dialogue: 0,2:06:12.68,2:06:14.08,Default,,0,0,0,,Note that to check that
Dialogue: 0,2:06:14.08,2:06:18.72,Default,,0,0,0,,we will need to infer the appropriate\Nintermediate type for sort L
Dialogue: 0,2:06:18.72,2:06:20.04,Default,,0,0,0,,since it is not given.
Dialogue: 0,2:06:21.80,2:06:25.36,Default,,0,0,0,,From the partially typed given\Ninput there on the right.
Dialogue: 0,2:06:25.36,2:06:28.32,Default,,0,0,0,,the type checking algorithm\Nis defined as follows.
Dialogue: 0,2:06:29.08,2:06:31.00,Default,,0,0,0,,First we extract\Nthe type signature
Dialogue: 0,2:06:31.00,2:06:33.00,Default,,0,0,0,,for the top most symbol, sorted.
Dialogue: 0,2:06:33.76,2:06:36.16,Default,,0,0,0,,We know the expected\Noutput type, true.
Dialogue: 0,2:06:36.92,2:06:40.80,Default,,0,0,0,,Constant values such as some\Ncomparison functions, CMP
Dialogue: 0,2:06:40.80,2:06:42.12,Default,,0,0,0,,are typed with themselves
Dialogue: 0,2:06:42.12,2:06:45.36,Default,,0,0,0,,and can be reported\Ndirectly on the signature.
Dialogue: 0,2:06:45.84,2:06:47.72,Default,,0,0,0,,We complete the blanks\Nin the signature
Dialogue: 0,2:06:47.72,2:06:50.12,Default,,0,0,0,,using our type inference procedure.
Dialogue: 0,2:06:50.12,2:06:52.52,Default,,0,0,0,,We find that to output true,
Dialogue: 0,2:06:52.52,2:06:56.40,Default,,0,0,0,,the list must be sorted which is\Nrepresented by the regular language
Dialogue: 0,2:06:56.40,2:06:57.40,Default,,0,0,0,,named sorted.
Dialogue: 0,2:06:57.88,2:06:59.88,Default,,0,0,0,,We propagate back what we have found
Dialogue: 0,2:06:59.88,2:07:02.84,Default,,0,0,0,,and check that it matches\Nthe initial type information
Dialogue: 0,2:07:03.36,2:07:05.04,Default,,0,0,0,,and then we repeat,\Nthe same procedure
Dialogue: 0,2:07:05.04,2:07:06.60,Default,,0,0,0,,with the subterm.
Dialogue: 0,2:07:06.60,2:07:08.44,Default,,0,0,0,,Here we need to check, sort l.
Dialogue: 0,2:07:08.96,2:07:11.20,Default,,0,0,0,,We again extract the template\Nsignature for sort.
Dialogue: 0,2:07:11.20,2:07:14.60,Default,,0,0,0,,Here we already have all\Nthe type information about sort.
Dialogue: 0,2:07:14.60,2:07:16.04,Default,,0,0,0,,We just need to check it.
Dialogue: 0,2:07:17.08,2:07:20.52,Default,,0,0,0,,The algorithm stops, when\Nall the types have been found
Dialogue: 0,2:07:20.52,2:07:23.00,Default,,0,0,0,,or when a type occur, when\Nthere is a contradiction.
Dialogue: 0,2:07:23.76,2:07:27.96,Default,,0,0,0,,Of course everything is built on\Ntop of type inference procedure
Dialogue: 0,2:07:27.96,2:07:31.24,Default,,0,0,0,,which has been able to find\Nthe regular language of sorted lists.
Dialogue: 0,2:07:32.00,2:07:33.96,Default,,0,0,0,,Let's see how this procedure works.
Dialogue: 0,2:07:33.96,2:07:35.48,Default,,0,0,0,,So the problem is as follows.
Dialogue: 0,2:07:36.24,2:07:39.60,Default,,0,0,0,,As input we have rewriting\Nsystem of symbol f
Dialogue: 0,2:07:39.60,2:07:42.36,Default,,0,0,0,,and an output regular\Nlanguage type o.
Dialogue: 0,2:07:42.36,2:07:46.00,Default,,0,0,0,,We want to find every\Ninput type A1 to An
Dialogue: 0,2:07:46.00,2:07:50.36,Default,,0,0,0,,such that every term f(t1)\Nto tn is typed with O
Dialogue: 0,2:07:50.88,2:07:53.36,Default,,0,0,0,,when each ti is typed with AI.
Dialogue: 0,2:07:53.36,2:07:56.00,Default,,0,0,0,,This can be summarized with\Nthe following abstract
Dialogue: 0,2:07:56.00,2:07:57.60,Default,,0,0,0,,writing rule for f.
Dialogue: 0,2:07:57.60,2:08:00.76,Default,,0,0,0,,For instance let's consider\Nthe following rewriting system
Dialogue: 0,2:08:00.76,2:08:02.72,Default,,0,0,0,,defining the recursive function
Dialogue: 0,2:08:02.72,2:08:06.84,Default,,0,0,0,,even deciding if\Na number is even or not.
Dialogue: 0,2:08:06.84,2:08:09.80,Default,,0,0,0,,We want to know for which\Ninput regular language type
Dialogue: 0,2:08:09.80,2:08:11.16,Default,,0,0,0,,this function returns true.
Dialogue: 0,2:08:11.88,2:08:15.48,Default,,0,0,0,,So here our target output\Ntype contains only true.
Dialogue: 0,2:08:16.24,2:08:19.36,Default,,0,0,0,,The expected output of\Nthe procedure is a partial abstraction
Dialogue: 0,2:08:19.36,2:08:21.40,Default,,0,0,0,,of the input term rewriting system.
Dialogue: 0,2:08:21.40,2:08:22.80,Default,,0,0,0,,Focusing on even.
Dialogue: 0,2:08:22.80,2:08:26.60,Default,,0,0,0,,this tells us that even returns\Ntrue for every even number.
Dialogue: 0,2:08:27.32,2:08:30.44,Default,,0,0,0,,The new type Even is computed\Nduring the analysis.
Dialogue: 0,2:08:31.20,2:08:33.32,Default,,0,0,0,,For recursive functions\Nsuch as this one
Dialogue: 0,2:08:33.32,2:08:36.64,Default,,0,0,0,,the type inference is done using\Nan invariant learning procedure.
Dialogue: 0,2:08:37.64,2:08:40.16,Default,,0,0,0,,In our paper, we defined\Na counter-example
Dialogue: 0,2:08:40.16,2:08:42.68,Default,,0,0,0,,guided regular invariant\Nlearning procedure
Dialogue: 0,2:08:42.68,2:08:45.60,Default,,0,0,0,,based on tree automata\Ncompletion and SMT solving.
Dialogue: 0,2:08:46.12,2:08:47.92,Default,,0,0,0,,It consists in repeating four steps
Dialogue: 0,2:08:48.40,2:08:50.84,Default,,0,0,0,,until it finds a solution\Nor a counter-example.
Dialogue: 0,2:08:51.32,2:08:52.96,Default,,0,0,0,,Step one we experiment.
Dialogue: 0,2:08:53.44,2:08:56.60,Default,,0,0,0,,We evaluate some terms of\Nthe form of f of t1 to tn
Dialogue: 0,2:08:56.60,2:09:01.96,Default,,0,0,0,,where f is an analyzed symbol and t1\Nto tn some random input values.
Dialogue: 0,2:09:01.96,2:09:05.36,Default,,0,0,0,,We do that efficiently using\Nthe tree automaton completion algorithm.
Dialogue: 0,2:09:05.88,2:09:08.60,Default,,0,0,0,,We then observe the result\Nof our experiments
Dialogue: 0,2:09:08.60,2:09:12.52,Default,,0,0,0,,and deduce some constraints on\Nthe language we are learning.
Dialogue: 0,2:09:12.52,2:09:16.04,Default,,0,0,0,,We then make an hypothesis\Nby using an SMT solver
Dialogue: 0,2:09:16.04,2:09:17.56,Default,,0,0,0,,and we solve the constraints
Dialogue: 0,2:09:17.56,2:09:20.12,Default,,0,0,0,,we generate an abstraction\Nof the program execution.
Dialogue: 0,2:09:20.64,2:09:22.92,Default,,0,0,0,,This gives us possible\Nregular language solution.
Dialogue: 0,2:09:23.44,2:09:25.92,Default,,0,0,0,,We check the correctness\Nof the abstraction
Dialogue: 0,2:09:25.92,2:09:27.28,Default,,0,0,0,,by checking it's completeness
Dialogue: 0,2:09:27.28,2:09:30.08,Default,,0,0,0,,with regards to the rewriting\Nsystem and the input domain.
Dialogue: 0,2:09:30.56,2:09:32.00,Default,,0,0,0,,If it is, we are done,
Dialogue: 0,2:09:32.48,2:09:35.44,Default,,0,0,0,,and if it isn't we continue\Nby doing more experiments.
Dialogue: 0,2:09:36.44,2:09:37.84,Default,,0,0,0,,To illustrate the procedure,
Dialogue: 0,2:09:37.84,2:09:40.00,Default,,0,0,0,,let's take back\Nthe even function example.
Dialogue: 0,2:09:40.76,2:09:44.12,Default,,0,0,0,,First we experiment with\Nthe values 0, 1 and 2
Dialogue: 0,2:09:44.12,2:09:49.08,Default,,0,0,0,,that are recognized in this\Nautomata by this state X0, X1, X2.
Dialogue: 0,2:09:49.08,2:09:51.20,Default,,0,0,0,,Using the tree automaton completion
Dialogue: 0,2:09:51.20,2:09:54.88,Default,,0,0,0,,we know that Even of 0\Nand Even of 2 rewrites to true.
Dialogue: 0,2:09:55.36,2:09:57.36,Default,,0,0,0,,This is encoded by\Nthe following rules.
Dialogue: 0,2:09:58.60,2:10:00.12,Default,,0,0,0,,If we only use this information,
Dialogue: 0,2:10:00.12,2:10:02.56,Default,,0,0,0,,then we cannot observe\Nthe constraints.
Dialogue: 0,2:10:02.56,2:10:05.28,Default,,0,0,0,,Every tested value\Nso far rewrites to true.
Dialogue: 0,2:10:05.76,2:10:08.68,Default,,0,0,0,,As a consequence,\Nif everything rewrites to true
Dialogue: 0,2:10:08.68,2:10:13.48,Default,,0,0,0,,then there is no point in\Nseparating X0 from X1 from X2.
Dialogue: 0,2:10:14.00,2:10:16.56,Default,,0,0,0,,The solution to our\Nanti-constraint system
Dialogue: 0,2:10:16.56,2:10:19.56,Default,,0,0,0,,is to merge them together\Ninto a new state tau zero
Dialogue: 0,2:10:20.16,2:10:22.48,Default,,0,0,0,,By applying the substitution\Nin the automaton
Dialogue: 0,2:10:22.48,2:10:25.52,Default,,0,0,0,,we get a candidate abstraction\Nfor rewriting system
Dialogue: 0,2:10:25.52,2:10:28.52,Default,,0,0,0,,where even applied to any\Nnumber returns to true.
Dialogue: 0,2:10:28.52,2:10:30.80,Default,,0,0,0,,Of course this does not pass the test.
Dialogue: 0,2:10:30.80,2:10:33.16,Default,,0,0,0,,Every input value for\NEven is represented
Dialogue: 0,2:10:33.16,2:10:36.36,Default,,0,0,0,,but some rewriting rules\Nare not used in particular
Dialogue: 0,2:10:36.36,2:10:40.48,Default,,0,0,0,,this abstraction misses the fact\Nthat even of 1 rewrites to false.
Dialogue: 0,2:10:41.20,2:10:42.96,Default,,0,0,0,,So we can not stop here.
Dialogue: 0,2:10:42.96,2:10:46.56,Default,,0,0,0,,To continue we add Even of\None in our experiment.
Dialogue: 0,2:10:46.56,2:10:48.08,Default,,0,0,0,,It rewrites to false.
Dialogue: 0,2:10:48.84,2:10:52.68,Default,,0,0,0,,This time we observe that in\Norder to separate true from false
Dialogue: 0,2:10:52.68,2:10:55.68,Default,,0,0,0,,we need to have X0 different from X2
Dialogue: 0,2:10:55.68,2:10:57.56,Default,,0,0,0,,and X1 different from X2.
Dialogue: 0,2:10:57.56,2:10:59.96,Default,,0,0,0,,By solving this new constant system
Dialogue: 0,2:10:59.96,2:11:01.44,Default,,0,0,0,,we make a new hypothesis
Dialogue: 0,2:11:01.44,2:11:04.84,Default,,0,0,0,,in which X0 are X2 are\Nequals, away from X1.
Dialogue: 0,2:11:05.36,2:11:08.92,Default,,0,0,0,,If we look closely, we can notice\Nthat this new potential abstraction
Dialogue: 0,2:11:08.92,2:11:10.80,Default,,0,0,0,,separates even and odd numbers
Dialogue: 0,2:11:10.80,2:11:12.72,Default,,0,0,0,,which is exactly what we want.
Dialogue: 0,2:11:13.24,2:11:16.12,Default,,0,0,0,,And this time every input\Nvalue is represented.
Dialogue: 0,2:11:16.12,2:11:18.88,Default,,0,0,0,,And every possible\Nrewriting rule is used.
Dialogue: 0,2:11:19.64,2:11:21.36,Default,,0,0,0,,So we can stop the analysis here.
Dialogue: 0,2:11:21.36,2:11:25.08,Default,,0,0,0,,We have found an abstraction that\Ngives us the correct input type
Dialogue: 0,2:11:25.08,2:11:26.08,Default,,0,0,0,,for the output true.
Dialogue: 0,2:11:26.84,2:11:29.92,Default,,0,0,0,,Which is new language even\Norganizing even numbers.
Dialogue: 0,2:11:30.60,2:11:32.68,Default,,0,0,0,,We have proved that this\Nprocedure is regularly
Dialogue: 0,2:11:33.36,2:11:36.60,Default,,0,0,0,,complete as it can\Nlearn any regular language
Dialogue: 0,2:11:36.60,2:11:38.76,Default,,0,0,0,,and complete in refutation.
Dialogue: 0,2:11:38.76,2:11:42.44,Default,,0,0,0,,We have implemented it in Ocaml\Nin a new version of Timbuk
Dialogue: 0,2:11:42.44,2:11:45.92,Default,,0,0,0,,and tested it on more\Nthan 80 problems.
Dialogue: 0,2:11:45.92,2:11:48.36,Default,,0,0,0,,When possible, we\Ncompared the performances
Dialogue: 0,2:11:48.36,2:11:50.96,Default,,0,0,0,,with the previous version of Timbuk.
Dialogue: 0,2:11:50.96,2:11:53.00,Default,,0,0,0,,We saw that it is on average,
Dialogue: 0,2:11:53.00,2:11:54.76,Default,,0,0,0,,a second slower than Timbuk Three
Dialogue: 0,2:11:54.76,2:11:56.48,Default,,0,0,0,,which can be explained\Nby an overhead
Dialogue: 0,2:11:56.48,2:11:59.00,Default,,0,0,0,,due to our typing facility.
Dialogue: 0,2:11:59.00,2:12:02.68,Default,,0,0,0,,However, in the subset of problems\Non which we could compare,
Dialogue: 0,2:12:02.68,2:12:07.08,Default,,0,0,0,,our implementation could\Nhandle 16% more problems
Dialogue: 0,2:12:07.08,2:12:09.72,Default,,0,0,0,,without timing out.
Dialogue: 0,2:12:09.72,2:12:13.72,Default,,0,0,0,,Surprisingly, the greatest\Nimprovement is in the memory usage
Dialogue: 0,2:12:13.72,2:12:15.32,Default,,0,0,0,,where in the worst case,
Dialogue: 0,2:12:15.32,2:12:19.00,Default,,0,0,0,,Timbuk Three would consume\Nseveral gigabytes of memory
Dialogue: 0,2:12:19.00,2:12:20.32,Default,,0,0,0,,to solve some problems
Dialogue: 0,2:12:20.32,2:12:24.24,Default,,0,0,0,,where we never got\Npassed 40 megabytes.
Dialogue: 0,2:12:24.24,2:12:27.92,Default,,0,0,0,,This is mostly due to our\Nmodular type system approach
Dialogue: 0,2:12:27.92,2:12:32.56,Default,,0,0,0,,that allows us to split\Nthe problem into smaller parts.
Dialogue: 0,2:12:32.56,2:12:35.64,Default,,0,0,0,,Thank you for listening\Nand don't hesitate to download
Dialogue: 0,2:12:35.64,2:12:38.64,Default,,0,0,0,,the source code which is\Navailable on our GitHub
Dialogue: 0,2:12:38.64,2:12:40.12,Default,,0,0,0,,at the address below.
Dialogue: 0,2:12:40.12,2:12:45.12,Default,,0,0,0,,(AUDIENCE APPLAUDS)
Dialogue: 0,2:12:47.84,2:12:50.72,Default,,0,0,0,,RICHARD: OK, thanks, Timothee,
Dialogue: 0,2:12:50.72,2:12:54.36,Default,,0,0,0,,who's available in the New York\Ntime band for question and answer.
Dialogue: 0,2:12:54.36,2:12:58.68,Default,,0,0,0,,We are now down with Technical\NSession number five of ICFP.
Dialogue: 0,2:12:58.68,2:13:02.72,Default,,0,0,0,,In the New York time band, we have\Nan ICFP coffee break coming up
Dialogue: 0,2:13:02.72,2:13:07.72,Default,,0,0,0,,and yeah, at 1:30, there's\Na virtualization feedback meeting
Dialogue: 0,2:13:08.88,2:13:10.60,Default,,0,0,0,,with Benjamin Pierce, Jonathan Bell,
Dialogue: 0,2:13:10.60,2:13:11.92,Default,,0,0,0,,and Krista Lopez coming up.
Dialogue: 0,2:13:11.92,2:13:14.16,Default,,0,0,0,,So that's an exciting thing to join.
Dialogue: 0,2:13:14.16,2:13:17.12,Default,,0,0,0,,In the Asia time band\Nin one half hour,
Dialogue: 0,2:13:17.12,2:13:18.52,Default,,0,0,0,,there will be a session on mentoring
Dialogue: 0,2:13:18.52,2:13:20.32,Default,,0,0,0,,with Mathias Felleisen.
Dialogue: 0,2:13:20.32,2:13:25.32,Default,,0,0,0,,Thanks very much and I hope\Nyou enjoy the rest of ICFP.
Dialogue: 0,2:14:30.60,2:14:35.60,Default,,0,0,0,,(UPBEAT FOLK MUSIC)
Dialogue: 0,2:17:12.36,2:17:17.36,Default,,0,0,0,,(INDIE ROCK MUSIC)
Dialogue: 0,2:20:52.84,2:20:57.84,Default,,0,0,0,,(ELECTRONIC POP MUSIC)
Dialogue: 0,2:25:38.32,2:25:43.32,Default,,0,0,0,,(ROCK MUSIC)