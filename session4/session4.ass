[Script Info]
; This is an Advanced Sub Station Alpha v4+ script.
Title: session4
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H0300FFFF,&H00000000,&H02000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:15.92,0:00:59.84,Default,,0,0,0,,
Dialogue: 0,0:00:59.84,0:01:59.84,Default,,0,0,0,,
Dialogue: 0,0:01:59.84,0:02:59.84,Default,,0,0,0,,
Dialogue: 0,0:02:59.84,0:04:00.00,Default,,0,0,0,,
Dialogue: 0,0:04:00.00,0:04:28.92,Default,,0,0,0,,
Dialogue: 0,0:04:58.64,0:05:59.48,Default,,0,0,0,,
Dialogue: 0,0:05:59.48,0:07:00.00,Default,,0,0,0,,
Dialogue: 0,0:07:00.00,0:07:59.92,Default,,0,0,0,,
Dialogue: 0,0:07:59.92,0:08:36.04,Default,,0,0,0,,
Dialogue: 0,0:09:22.12,0:09:59.84,Default,,0,0,0,,
Dialogue: 0,0:09:59.84,0:10:59.92,Default,,0,0,0,,
Dialogue: 0,0:10:59.92,0:11:59.92,Default,,0,0,0,,
Dialogue: 0,0:11:59.92,0:12:13.76,Default,,0,0,0,,
Dialogue: 0,0:13:01.76,0:13:03.24,Default,,0,0,0,,STEPHANIE WEIRICH: Hello, my name\N is Stephanie Weirich
Dialogue: 0,0:13:03.24,0:13:06.28,Default,,0,0,0,,and I'm the General\N Chair of ICFP, 2020.
Dialogue: 0,0:13:06.28,0:13:10.76,Default,,0,0,0,,And I'd like to welcome\N you to Session 4 of ICFP.
Dialogue: 0,0:13:10.76,0:13:11.88,Default,,0,0,0,,Our first talk comes from
Dialogue: 0,0:13:11.88,0:13:14.84,Default,,0,0,0,,one of my favorite\N categories of ICFP papers,
Dialogue: 0,0:13:14.84,0:13:16.32,Default,,0,0,0,,Functional Pearls.
Dialogue: 0,0:13:16.32,0:13:18.24,Default,,0,0,0,,The emphasis of papers\N in this category
Dialogue: 0,0:13:18.24,0:13:20.24,Default,,0,0,0,,is on the clarity of exposition
Dialogue: 0,0:13:20.24,0:13:23.84,Default,,0,0,0,,and I'm sure that you'll agree that\N this paper is a beautiful read.
Dialogue: 0,0:13:23.84,0:13:26.92,Default,,0,0,0,,This paper will be presented\N by Lionel Parreaux
Dialogue: 0,0:13:26.92,0:13:28.72,Default,,0,0,0,,and he will tell us about
Dialogue: 0,0:13:28.72,0:13:31.48,Default,,0,0,0,,The Simple Essence of\N Algebraic Subtyping:
Dialogue: 0,0:13:31.48,0:13:34.48,Default,,0,0,0,,Principal Type Inference with\N Subtyping Made Easy.
Dialogue: 0,0:13:35.40,0:13:36.40,Default,,0,0,0,,LIONEL PARREAUX: Hi, I'm Lionel Parreaux
Dialogue: 0,0:13:36.40,0:13:37.96,Default,,0,0,0,,and I will present\N my functional pearl
Dialogue: 0,0:13:37.96,0:13:40.36,Default,,0,0,0,,on the simple essence of\N algebraic subtyping.
Dialogue: 0,0:13:40.36,0:13:43.36,Default,,0,0,0,,But first, what exactly\N do we mean by subtyping?
Dialogue: 0,0:13:43.36,0:13:45.32,Default,,0,0,0,,Subtyping is a type\N system feature used to
Dialogue: 0,0:13:45.32,0:13:47.96,Default,,0,0,0,,model the relative\N specificity of types.
Dialogue: 0,0:13:47.96,0:13:50.40,Default,,0,0,0,,For instance, the type\N nat of natural numbers
Dialogue: 0,0:13:50.40,0:13:52.44,Default,,0,0,0,,is strictly more specific than int
Dialogue: 0,0:13:52.44,0:13:54.52,Default,,0,0,0,,because all nat values\N are also int values.
Dialogue: 0,0:13:54.52,0:13:56.16,Default,,0,0,0,,But the converse is not true.
Dialogue: 0,0:13:56.16,0:13:58.76,Default,,0,0,0,,In this work, we focus\N on inclusive subtyping,
Dialogue: 0,0:13:58.76,0:14:01.28,Default,,0,0,0,,in which the types in\N a subtyping relationship
Dialogue: 0,0:14:01.28,0:14:03.40,Default,,0,0,0,,share compatible runtime\N representations,
Dialogue: 0,0:14:03.40,0:14:05.80,Default,,0,0,0,,meaning that no runtime\N coercions are needed.
Dialogue: 0,0:14:06.36,0:14:07.84,Default,,0,0,0,,Inclusive subtyping\N is useful
Dialogue: 0,0:14:07.84,0:14:10.44,Default,,0,0,0,,because it can express relationships\N between data types
Dialogue: 0,0:14:10.44,0:14:12.12,Default,,0,0,0,,based on their variance.
Dialogue: 0,0:14:12.12,0:14:15.00,Default,,0,0,0,,For instance, since the list\N data type is covariant,
Dialogue: 0,0:14:15.00,0:14:17.08,Default,,0,0,0,,nat list is a subtype of int list.
Dialogue: 0,0:14:17.08,0:14:19.60,Default,,0,0,0,,So that a list of natural\N numbers can be used in place
Dialogue: 0,0:14:19.60,0:14:22.48,Default,,0,0,0,,where a list of\N integers is expected.
Dialogue: 0,0:14:22.96,0:14:25.40,Default,,0,0,0,,Moreover, we focus on\N implicit subtyping,
Dialogue: 0,0:14:25.40,0:14:27.56,Default,,0,0,0,,which means that expressions\N of a certain type
Dialogue: 0,0:14:27.56,0:14:29.20,Default,,0,0,0,,do not need to be annotated,
Dialogue: 0,0:14:29.20,0:14:31.44,Default,,0,0,0,,in order to be used at\N a less specific type.
Dialogue: 0,0:14:32.04,0:14:33.84,Default,,0,0,0,,So when we write 1 + 2,
Dialogue: 0,0:14:33.84,0:14:36.00,Default,,0,0,0,,we don't need to explicitly annotate
Dialogue: 0,0:14:36.00,0:14:39.28,Default,,0,0,0,,1 as being of type int, although\N it's also of type nat.
Dialogue: 0,0:14:39.92,0:14:42.00,Default,,0,0,0,,Now let us see a few\N examples of subtyping.
Dialogue: 0,0:14:42.84,0:14:46.20,Default,,0,0,0,,Singleton types are types\N which represent single values.
Dialogue: 0,0:14:46.20,0:14:48.32,Default,,0,0,0,,For instance, the type written 0
Dialogue: 0,0:14:48.32,0:14:50.48,Default,,0,0,0,,is the singleton type\N of the value 0.
Dialogue: 0,0:14:51.32,0:14:53.84,Default,,0,0,0,,Union types are used\N to type expressions
Dialogue: 0,0:14:53.84,0:14:56.36,Default,,0,0,0,,which can be either one\N of two given types.
Dialogue: 0,0:14:56.36,0:14:59.20,Default,,0,0,0,,Intersection types are\N used to type expressions
Dialogue: 0,0:14:59.20,0:15:01.08,Default,,0,0,0,,which are of both given types.
Dialogue: 0,0:15:01.88,0:15:04.88,Default,,0,0,0,,As an example subtyping\N relationship between these,
Dialogue: 0,0:15:04.88,0:15:08.56,Default,,0,0,0,,the type 0 is a subtype\N of the union of 0 and 1,
Dialogue: 0,0:15:08.56,0:15:10.44,Default,,0,0,0,,which is itself a subtype of nat.
Dialogue: 0,0:15:11.20,0:15:14.24,Default,,0,0,0,,In fact, subtyping naturally\N lets us design types,
Dialogue: 0,0:15:14.24,0:15:18.00,Default,,0,0,0,,which are as close as desired to\N corresponding operations and values.
Dialogue: 0,0:15:18.84,0:15:22.36,Default,,0,0,0,,For instance, we can define\N the singleton type of empty lists
Dialogue: 0,0:15:22.36,0:15:25.48,Default,,0,0,0,,as well as the type of\N prepending a value to a lists.
Dialogue: 0,0:15:26.68,0:15:29.16,Default,,0,0,0,,This allows us to use\N the same list syntax
Dialogue: 0,0:15:29.16,0:15:31.64,Default,,0,0,0,,and representation to\N express things like
Dialogue: 0,0:15:31.64,0:15:35.44,Default,,0,0,0,,tuple types, non-empty lists\N and everything in between.
Dialogue: 0,0:15:37.76,0:15:40.84,Default,,0,0,0,,Subtyping is not just for\N object-oriented programming.
Dialogue: 0,0:15:40.84,0:15:43.40,Default,,0,0,0,,In fact, it has found\N a host of applications
Dialogue: 0,0:15:43.40,0:15:45.36,Default,,0,0,0,,in functional programming.
Dialogue: 0,0:15:45.36,0:15:48.72,Default,,0,0,0,,It can, for example, be used\N for predicate refinement types,
Dialogue: 0,0:15:48.72,0:15:52.44,Default,,0,0,0,,first-class modules, XML\N transformations, and much more.
Dialogue: 0,0:15:54.00,0:15:55.72,Default,,0,0,0,,Now some may be under the impression
Dialogue: 0,0:15:55.72,0:15:59.32,Default,,0,0,0,,that functional languages\N usually try to avoid subtyping.
Dialogue: 0,0:15:59.32,0:16:02.32,Default,,0,0,0,,But, in fact, subtyping is present\N in many of those languages
Dialogue: 0,0:16:02.32,0:16:04.84,Default,,0,0,0,,including OCaml, Haskell and Rust.
Dialogue: 0,0:16:04.84,0:16:08.16,Default,,0,0,0,,In Rust, subtyping is used to\N relate allocation lifetimes.
Dialogue: 0,0:16:08.16,0:16:10.08,Default,,0,0,0,,In Ocaml, where\N subtyping is explicit,
Dialogue: 0,0:16:10.08,0:16:13.04,Default,,0,0,0,,it is used in many places such\N as polymorphic variants,
Dialogue: 0,0:16:13.04,0:16:15.60,Default,,0,0,0,,first-class modules,\N and the object system.
Dialogue: 0,0:16:15.60,0:16:18.28,Default,,0,0,0,,In Haskell, subtyping is\N used in the context of
Dialogue: 0,0:16:18.28,0:16:21.44,Default,,0,0,0,,first-class polymorphism to check\N inferred types against signatures.
Dialogue: 0,0:16:22.24,0:16:24.64,Default,,0,0,0,,Yet, all these languages\N use type inference engines
Dialogue: 0,0:16:24.64,0:16:25.88,Default,,0,0,0,,based on unification, which
Dialogue: 0,0:16:26.64,0:16:28.44,Default,,0,0,0,,does not\N handle subtyping well
Dialogue: 0,0:16:28.44,0:16:31.60,Default,,0,0,0,,and limits its applicability.
Dialogue: 0,0:16:31.60,0:16:34.56,Default,,0,0,0,,What we'd really like is\N a way of integrating subtyping
Dialogue: 0,0:16:34.56,0:16:40.96,Default,,0,0,0,,in ML style type inference more\N consistently and reliably.
Dialogue: 0,0:16:40.96,0:16:43.32,Default,,0,0,0,,So first, let's review\N the way ML languages
Dialogue: 0,0:16:43.32,0:16:47.00,Default,,0,0,0,,have traditionally inferred\N types based on unification.
Dialogue: 0,0:16:47.00,0:16:49.56,Default,,0,0,0,,The Hindley-Milner type\N inference algorithm relies
Dialogue: 0,0:16:49.56,0:16:51.44,Default,,0,0,0,,on introducing type variables
Dialogue: 0,0:16:51.44,0:16:53.88,Default,,0,0,0,,when the types of expressions\N are not yet known,
Dialogue: 0,0:16:53.88,0:16:57.12,Default,,0,0,0,,and type variables are later\N unified with concrete types
Dialogue: 0,0:16:57.12,0:16:58.60,Default,,0,0,0,,or with other type variables,
Dialogue: 0,0:16:58.60,0:17:02.04,Default,,0,0,0,,based on the way these\N expressions are used.
Dialogue: 0,0:17:02.04,0:17:04.44,Default,,0,0,0,,As an example, consider\N the following term,
Dialogue: 0,0:17:04.44,0:17:06.84,Default,,0,0,0,,which takes two parameters x and y,
Dialogue: 0,0:17:06.84,0:17:10.12,Default,,0,0,0,,compares them, and returns\N the smaller of the two.
Dialogue: 0,0:17:10.12,0:17:12.00,Default,,0,0,0,,We start from a context Gamma,
Dialogue: 0,0:17:12.00,0:17:15.00,Default,,0,0,0,,including only the comparison\N operation defined
Dialogue: 0,0:17:15.00,0:17:18.04,Default,,0,0,0,,to operate on integer values.
Dialogue: 0,0:17:18.04,0:17:21.80,Default,,0,0,0,,First, we consider\N the outer lambda binding x.
Dialogue: 0,0:17:21.80,0:17:23.84,Default,,0,0,0,,We assign x the\N type variable alpha,
Dialogue: 0,0:17:23.84,0:17:26.68,Default,,0,0,0,,and place it in the context.
Dialogue: 0,0:17:26.68,0:17:30.16,Default,,0,0,0,,Then, we look at\N the inner lambda binding y
Dialogue: 0,0:17:30.16,0:17:31.76,Default,,0,0,0,,and similarly extend the context
Dialogue: 0,0:17:31.76,0:17:34.60,Default,,0,0,0,,with a new type variable, beta.
Dialogue: 0,0:17:34.60,0:17:37.60,Default,,0,0,0,,Then, we consider\N the if-then-else expression,
Dialogue: 0,0:17:37.60,0:17:39.76,Default,,0,0,0,,in particular, the condition.
Dialogue: 0,0:17:39.76,0:17:42.24,Default,,0,0,0,,Variable x has type alpha
Dialogue: 0,0:17:42.24,0:17:44.00,Default,,0,0,0,,and it's used on the left hand side
Dialogue: 0,0:17:44.00,0:17:50.24,Default,,0,0,0,,of the less-than operation,\N so we unify alpha with int.
Dialogue: 0,0:17:50.24,0:17:52.48,Default,,0,0,0,,Variable y has type beta
Dialogue: 0,0:17:52.48,0:17:53.96,Default,,0,0,0,,and it's used on the right hand side
Dialogue: 0,0:17:53.96,0:17:59.80,Default,,0,0,0,,of the comparison operation,\N so we unify beta with int.
Dialogue: 0,0:17:59.80,0:18:03.48,Default,,0,0,0,,Then we consider the branches\N of the if statement.
Dialogue: 0,0:18:03.48,0:18:05.96,Default,,0,0,0,,The first branch has type alpha,
Dialogue: 0,0:18:05.96,0:18:09.20,Default,,0,0,0,,the second branch\N has type beta,
Dialogue: 0,0:18:09.20,0:18:12.56,Default,,0,0,0,,and since the if-then-else\N must return a single type,
Dialogue: 0,0:18:12.56,0:18:14.68,Default,,0,0,0,,we unify alpha and beta,
Dialogue: 0,0:18:14.68,0:18:19.52,Default,,0,0,0,,which is the same as unifying\N int with int and is trivial.
Dialogue: 0,0:18:19.52,0:18:23.20,Default,,0,0,0,,The result type of\N the if-then-else is alpha,
Dialogue: 0,0:18:23.20,0:18:25.56,Default,,0,0,0,,so the result type is int,
Dialogue: 0,0:18:25.56,0:18:28.96,Default,,0,0,0,,because we have unified\N int with alpha.
Dialogue: 0,0:18:28.96,0:18:31.80,Default,,0,0,0,,The result type of the inner\N lambda is beta to int,
Dialogue: 0,0:18:31.80,0:18:33.60,Default,,0,0,0,,which is int to int,
Dialogue: 0,0:18:33.60,0:18:36.84,Default,,0,0,0,,and the final result type\N is alpha to int to int,
Dialogue: 0,0:18:36.84,0:18:39.24,Default,,0,0,0,,which is int to int to int.
Dialogue: 0,0:18:39.24,0:18:42.32,Default,,0,0,0,,Now let's review how to adapt\N this algorithm to subtyping.
Dialogue: 0,0:18:42.32,0:18:44.76,Default,,0,0,0,,Instead of tracking\N equalities between types,
Dialogue: 0,0:18:44.76,0:18:47.60,Default,,0,0,0,,we now track inequalities\N between types.
Dialogue: 0,0:18:47.60,0:18:49.12,Default,,0,0,0,,We do not unify type variables,
Dialogue: 0,0:18:49.12,0:18:52.64,Default,,0,0,0,,but instead we keep track\N of their assumed subtypes
Dialogue: 0,0:18:52.64,0:18:57.44,Default,,0,0,0,,and supertypes — that is, we\N keep track of their bounds.
Dialogue: 0,0:18:57.44,0:18:58.52,Default,,0,0,0,,We base our approach
Dialogue: 0,0:18:58.52,0:19:00.88,Default,,0,0,0,,on a previous\N algorithm called ML-sub,
Dialogue: 0,0:19:00.88,0:19:03.04,Default,,0,0,0,,which was the first to\N infer most specific types
Dialogue: 0,0:19:03.04,0:19:05.20,Default,,0,0,0,,in the presence of subtyping,
Dialogue: 0,0:19:05.20,0:19:06.92,Default,,0,0,0,,but whose presentation was complex
Dialogue: 0,0:19:06.92,0:19:09.20,Default,,0,0,0,,and difficult to understand.
Dialogue: 0,0:19:09.20,0:19:10.24,Default,,0,0,0,,In the (our) paper,
Dialogue: 0,0:19:10.24,0:19:12.40,Default,,0,0,0,,the new Simple-sub\N algorithm is introduced,
Dialogue: 0,0:19:12.40,0:19:15.12,Default,,0,0,0,,which is closer to the traditional\N type inference algorithm
Dialogue: 0,0:19:15.12,0:19:16.12,Default,,0,0,0,,we have just seen,
Dialogue: 0,0:19:16.12,0:19:19.04,Default,,0,0,0,,and is easier to\N specify and implement.
Dialogue: 0,0:19:19.04,0:19:21.32,Default,,0,0,0,,Going back to our example,
Dialogue: 0,0:19:21.32,0:19:23.72,Default,,0,0,0,,we look at the outer lambda again.
Dialogue: 0,0:19:23.72,0:19:28.32,Default,,0,0,0,,We extend the context with\N a new type variable, as before.
Dialogue: 0,0:19:28.32,0:19:30.88,Default,,0,0,0,,Same for the second\N lambda abstraction.
Dialogue: 0,0:19:30.88,0:19:34.28,Default,,0,0,0,,We extend the context with\N the new type variable beta.
Dialogue: 0,0:19:34.28,0:19:36.68,Default,,0,0,0,,Then we look at\N the condition again;
Dialogue: 0,0:19:36.68,0:19:40.20,Default,,0,0,0,,the variable x has type\N alpha, but this time,
Dialogue: 0,0:19:40.20,0:19:42.52,Default,,0,0,0,,instead of unifying alpha with int,
Dialogue: 0,0:19:42.52,0:19:45.44,Default,,0,0,0,,we simply specify that alpha\N should be a subtype of int,
Dialogue: 0,0:19:45.44,0:19:50.12,Default,,0,0,0,,so we register int as one of\N the upper bounds of alpha.
Dialogue: 0,0:19:50.12,0:19:55.16,Default,,0,0,0,,We do the same for beta,\N and then we look at the branches.
Dialogue: 0,0:19:55.16,0:19:56.96,Default,,0,0,0,,The first branch has type alpha;
Dialogue: 0,0:19:56.96,0:19:58.92,Default,,0,0,0,,second branch has type beta;
Dialogue: 0,0:19:58.92,0:20:01.72,Default,,0,0,0,,but this time we introduced\N a new type variable
Dialogue: 0,0:20:01.72,0:20:05.72,Default,,0,0,0,,to represent the union\N of the two branches.
Dialogue: 0,0:20:05.72,0:20:08.28,Default,,0,0,0,,We constraint this type\N variable to be a super type
Dialogue: 0,0:20:08.28,0:20:12.32,Default,,0,0,0,,of the types of both\N branches, alpha and beta.
Dialogue: 0,0:20:12.32,0:20:15.96,Default,,0,0,0,,The resulting type of\N the inner lambda is beta to gamma,
Dialogue: 0,0:20:15.96,0:20:20.04,Default,,0,0,0,,and the final resulting type\N is alpha to beta to gamma,
Dialogue: 0,0:20:20.04,0:20:23.16,Default,,0,0,0,,together with\N the inferred constraints.
Dialogue: 0,0:20:23.16,0:20:26.72,Default,,0,0,0,,So we have inferred the type\N alpha to beta to gamma,
Dialogue: 0,0:20:26.72,0:20:30.20,Default,,0,0,0,,where alpha is less than\N int, beta is less than int,
Dialogue: 0,0:20:30.20,0:20:33.12,Default,,0,0,0,,and alpha union beta\N is less than gamma,
Dialogue: 0,0:20:33.12,0:20:35.32,Default,,0,0,0,,which means that\N gamma is a super type
Dialogue: 0,0:20:35.32,0:20:37.80,Default,,0,0,0,,of both alpha and beta.
Dialogue: 0,0:20:37.80,0:20:40.32,Default,,0,0,0,,Now the call f 0 1
Dialogue: 0,0:20:40.32,0:20:44.88,Default,,0,0,0,,is more precisely typed\N as nat instead of int.
Dialogue: 0,0:20:44.88,0:20:48.12,Default,,0,0,0,,But is this really a type\N we want to show users?
Dialogue: 0,0:20:48.12,0:20:50.88,Default,,0,0,0,,It looks much more confusing\N than the type we had before
Dialogue: 0,0:20:50.88,0:20:53.60,Default,,0,0,0,,we introduced\N subtyping into the mix.
Dialogue: 0,0:20:53.60,0:20:55.96,Default,,0,0,0,,In fact, we can inline, so to say,
Dialogue: 0,0:20:55.96,0:20:59.20,Default,,0,0,0,,the bounds of each type\N variable into the result type
Dialogue: 0,0:20:59.20,0:21:03.72,Default,,0,0,0,,to yield a simpler type. This\N is called bounds coalescing.
Dialogue: 0,0:21:03.72,0:21:05.80,Default,,0,0,0,,We replace each type\N variable occurrence
Dialogue: 0,0:21:05.80,0:21:08.72,Default,,0,0,0,,with the composition of\N the variable's bounds.
Dialogue: 0,0:21:08.72,0:21:13.32,Default,,0,0,0,,For occurrences in output position\N – or in positive position –
Dialogue: 0,0:21:13.32,0:21:17.16,Default,,0,0,0,,we use a union of the type\N variable with its lower bounds.
Dialogue: 0,0:21:17.16,0:21:21.68,Default,,0,0,0,,Conversely, for occurrences in\N input — or negative — positions,
Dialogue: 0,0:21:21.68,0:21:24.12,Default,,0,0,0,,we use an intersection\N of the type variable
Dialogue: 0,0:21:24.12,0:21:26.00,Default,,0,0,0,,with its upper bounds.
Dialogue: 0,0:21:26.00,0:21:28.48,Default,,0,0,0,,We can actually simplify\N this type further
Dialogue: 0,0:21:28.48,0:21:29.60,Default,,0,0,0,,by removing gamma,
Dialogue: 0,0:21:29.60,0:21:32.56,Default,,0,0,0,,which is useless,\N and merging alpha and beta,
Dialogue: 0,0:21:32.56,0:21:34.12,Default,,0,0,0,,yielding a type expression
Dialogue: 0,0:21:34.12,0:21:38.00,Default,,0,0,0,,which is much more\N compact and easy to read.
Dialogue: 0,0:21:38.00,0:21:39.92,Default,,0,0,0,,Both of these simplifications
Dialogue: 0,0:21:39.92,0:21:42.92,Default,,0,0,0,,leave us with a type that is\N equivalent to the original,
Dialogue: 0,0:21:42.92,0:21:44.44,Default,,0,0,0,,unsimplified type,
Dialogue: 0,0:21:44.44,0:21:48.84,Default,,0,0,0,,despite not featuring the same\N number of type variables.
Dialogue: 0,0:21:48.84,0:21:50.40,Default,,0,0,0,,To understand why that is correct,
Dialogue: 0,0:21:50.40,0:21:53.88,Default,,0,0,0,,let us first consider\N the first simplification.
Dialogue: 0,0:21:53.88,0:21:56.68,Default,,0,0,0,,The main insight here is\N that type intersections
Dialogue: 0,0:21:56.68,0:22:00.00,Default,,0,0,0,,can act like upper bounds\N to type variables
Dialogue: 0,0:22:00.00,0:22:02.72,Default,,0,0,0,,as long as they are added to\N all the negative occurrences
Dialogue: 0,0:22:02.72,0:22:04.52,Default,,0,0,0,,of that variable.
Dialogue: 0,0:22:04.52,0:22:07.84,Default,,0,0,0,,Indeed, using the resulting\N function in our case
Dialogue: 0,0:22:07.84,0:22:10.32,Default,,0,0,0,,requires an argument\N whose type is a subtype
Dialogue: 0,0:22:10.32,0:22:11.88,Default,,0,0,0,,of the said intersection,
Dialogue: 0,0:22:11.88,0:22:13.80,Default,,0,0,0,,which is to say that\N it must be a subtype
Dialogue: 0,0:22:13.80,0:22:18.44,Default,,0,0,0,,of the type variable and each\N of its intersected bounds
Dialogue: 0,0:22:18.44,0:22:21.92,Default,,0,0,0,,(in our case,\N the bound is just int).
Dialogue: 0,0:22:21.92,0:22:25.40,Default,,0,0,0,,In particular, while users\N of the function are free
Dialogue: 0,0:22:25.40,0:22:28.60,Default,,0,0,0,,to instantiate alpha to\N whatever type they like,
Dialogue: 0,0:22:28.60,0:22:30.28,Default,,0,0,0,,the function will not be callable
Dialogue: 0,0:22:30.28,0:22:32.08,Default,,0,0,0,,if alpha is taken to be a type
Dialogue: 0,0:22:32.08,0:22:37.20,Default,,0,0,0,,whose intersection with\N int contains no values.
Dialogue: 0,0:22:37.20,0:22:40.56,Default,,0,0,0,,Next, let us look at\N the second simplification.
Dialogue: 0,0:22:40.56,0:22:42.68,Default,,0,0,0,,Here, the insight is\N that alpha and beta
Dialogue: 0,0:22:42.68,0:22:45.24,Default,,0,0,0,,are indistinguishable\N from each other
Dialogue: 0,0:22:45.24,0:22:48.92,Default,,0,0,0,,since they always occur together\N in positive positions,
Dialogue: 0,0:22:48.92,0:22:53.08,Default,,0,0,0,,which is to say, here, in\N the result type of the function.
Dialogue: 0,0:22:53.08,0:22:55.60,Default,,0,0,0,,Formally, the subsumption relation
Dialogue: 0,0:22:55.60,0:22:57.56,Default,,0,0,0,,between two polymorphic types
Dialogue: 0,0:22:57.56,0:22:59.84,Default,,0,0,0,,can be used to reason\N about the equivalence
Dialogue: 0,0:22:59.84,0:23:03.28,Default,,0,0,0,,of simplified\N and unsimplified types.
Dialogue: 0,0:23:03.28,0:23:05.88,Default,,0,0,0,,To show that one type\N subsumes another,
Dialogue: 0,0:23:05.88,0:23:10.12,Default,,0,0,0,,that is, tau zero\Nless-than-for-all tau one,
Dialogue: 0,0:23:10.12,0:23:11.72,Default,,0,0,0,,it is sufficient to\N pick an assignment
Dialogue: 0,0:23:11.72,0:23:13.92,Default,,0,0,0,,of tau zero's type variables,
Dialogue: 0,0:23:13.92,0:23:17.60,Default,,0,0,0,,which satisfies tau zero\N less than tau one.
Dialogue: 0,0:23:17.60,0:23:19.52,Default,,0,0,0,,For the first subsumption direction,
Dialogue: 0,0:23:19.52,0:23:21.36,Default,,0,0,0,,which is to show that\N the original type
Dialogue: 0,0:23:21.36,0:23:23.64,Default,,0,0,0,,subsumes the simplified type,
Dialogue: 0,0:23:23.64,0:23:26.92,Default,,0,0,0,,we can pick the following\N variable assignments:
Dialogue: 0,0:23:26.92,0:23:30.76,Default,,0,0,0,,alpha is left as alpha,\N and beta is taken to be alpha.
Dialogue: 0,0:23:30.76,0:23:33.72,Default,,0,0,0,,This makes both types identical,\N which trivially means
Dialogue: 0,0:23:33.72,0:23:37.04,Default,,0,0,0,,that the former subsumes the latter.
Dialogue: 0,0:23:37.04,0:23:39.04,Default,,0,0,0,,For the other subsumption direction,
Dialogue: 0,0:23:39.04,0:23:43.12,Default,,0,0,0,,we pick alpha to be\N the union of alpha and beta.
Dialogue: 0,0:23:43.12,0:23:46.16,Default,,0,0,0,,Indeed, this instantiation\N is sufficient to show
Dialogue: 0,0:23:46.16,0:23:51.24,Default,,0,0,0,,that the simplified type is\N a subtype of the original type.
Dialogue: 0,0:23:51.24,0:23:53.88,Default,,0,0,0,,Let us once again go back to\N the type inference example,
Dialogue: 0,0:23:53.88,0:23:56.32,Default,,0,0,0,,but this time consider\N the same term applied
Dialogue: 0,0:23:56.32,0:23:58.32,Default,,0,0,0,,to the value zero.
Dialogue: 0,0:23:58.32,0:24:01.44,Default,,0,0,0,,We go back to the state of\N type inference as we left it,
Dialogue: 0,0:24:01.44,0:24:04.52,Default,,0,0,0,,and now consider\N the application of argument zero
Dialogue: 0,0:24:04.52,0:24:05.68,Default,,0,0,0,,of type nat.
Dialogue: 0,0:24:05.68,0:24:07.80,Default,,0,0,0,,This generates a constraint\N that nat should be
Dialogue: 0,0:24:07.80,0:24:09.08,Default,,0,0,0,,a subtype of alpha,
Dialogue: 0,0:24:09.08,0:24:11.80,Default,,0,0,0,,which is the argument\N type of the function.
Dialogue: 0,0:24:11.80,0:24:14.84,Default,,0,0,0,,So we register nat as\N a lower bound of alpha.
Dialogue: 0,0:24:14.84,0:24:16.48,Default,,0,0,0,,But we are not done yet;
Dialogue: 0,0:24:16.48,0:24:18.48,Default,,0,0,0,,we also have to propagate\N the constraint
Dialogue: 0,0:24:18.48,0:24:22.04,Default,,0,0,0,,and check that nat is\N also a subtype of int,
Dialogue: 0,0:24:22.04,0:24:23.52,Default,,0,0,0,,which works out.
Dialogue: 0,0:24:23.52,0:24:26.40,Default,,0,0,0,,This gives us the result\N type beta to gamma,
Dialogue: 0,0:24:26.40,0:24:28.20,Default,,0,0,0,,with these new constraints,
Dialogue: 0,0:24:28.20,0:24:31.40,Default,,0,0,0,,which yields the following\N simplified type:
Dialogue: 0,0:24:31.40,0:24:34.36,Default,,0,0,0,,alpha intersection int\N to alpha union nat.
Dialogue: 0,0:24:37.44,0:24:39.88,Default,,0,0,0,,But what happens if we\N have a type error?
Dialogue: 0,0:24:39.88,0:24:42.12,Default,,0,0,0,,For example, if we tried\N to apply the function
Dialogue: 0,0:24:42.12,0:24:45.24,Default,,0,0,0,,with the boolean literal false?
Dialogue: 0,0:24:45.24,0:24:49.92,Default,,0,0,0,,In this case, we use bool\N as a lower bound of alpha,
Dialogue: 0,0:24:49.92,0:24:52.24,Default,,0,0,0,,but while propagating\N the constraint,
Dialogue: 0,0:24:52.24,0:24:55.40,Default,,0,0,0,,we are left constraining bool\N to be a subtype of int,
Dialogue: 0,0:24:55.40,0:24:59.24,Default,,0,0,0,,which obviously leads to an error.
Dialogue: 0,0:24:59.24,0:25:01.76,Default,,0,0,0,,As you can imagine, there's\N a lot more to talk about.
Dialogue: 0,0:25:01.76,0:25:04.48,Default,,0,0,0,,You can read the paper to\N learn about: let polymorphism,
Dialogue: 0,0:25:04.48,0:25:06.88,Default,,0,0,0,,which complicates\N the picture quite a bit;
Dialogue: 0,0:25:06.88,0:25:09.00,Default,,0,0,0,,the handling of recursive constraints;
Dialogue: 0,0:25:09.00,0:25:11.64,Default,,0,0,0,,different approaches to\N type simplification;
Dialogue: 0,0:25:11.64,0:25:13.96,Default,,0,0,0,,the soundness and completeness\N of type inference;
Dialogue: 0,0:25:13.96,0:25:16.44,Default,,0,0,0,,and how subtyping\N enables typing terms
Dialogue: 0,0:25:16.44,0:25:19.40,Default,,0,0,0,,which were not typable before.
Dialogue: 0,0:25:19.40,0:25:22.24,Default,,0,0,0,,Finally, I'd like to correct\N some common misunderstandings
Dialogue: 0,0:25:22.24,0:25:24.16,Default,,0,0,0,,about algebraic subtyping.
Dialogue: 0,0:25:24.16,0:25:26.64,Default,,0,0,0,,First, union and intersection types
Dialogue: 0,0:25:26.64,0:25:28.52,Default,,0,0,0,,are not truly first-class.
Dialogue: 0,0:25:28.52,0:25:31.28,Default,,0,0,0,,As we have seen, they simply\N result from the printing
Dialogue: 0,0:25:31.28,0:25:33.44,Default,,0,0,0,,of compact type representations.
Dialogue: 0,0:25:33.44,0:25:35.92,Default,,0,0,0,,In fact, they cannot be used\N directly by programmers
Dialogue: 0,0:25:35.92,0:25:38.96,Default,,0,0,0,,as is done in languages like\N TypeScript or Scala 3,
Dialogue: 0,0:25:38.96,0:25:40.80,Default,,0,0,0,,because in our approach,
Dialogue: 0,0:25:40.80,0:25:43.72,Default,,0,0,0,,there are syntactic restrictions\N on the places where unions
Dialogue: 0,0:25:43.72,0:25:46.36,Default,,0,0,0,,and intersections are\N allowed to occur.
Dialogue: 0,0:25:46.36,0:25:48.36,Default,,0,0,0,,Supporting first-class\N unions and intersections
Dialogue: 0,0:25:48.36,0:25:49.92,Default,,0,0,0,,would be difficult while maintaining
Dialogue: 0,0:25:49.92,0:25:51.72,Default,,0,0,0,,the principle type property
Dialogue: 0,0:25:51.72,0:25:55.04,Default,,0,0,0,,— that is, the ability to always\N infer a most specific type.
Dialogue: 0,0:25:55.04,0:25:56.64,Default,,0,0,0,,Moreover, it would\N make simplification
Dialogue: 0,0:25:56.64,0:25:58.48,Default,,0,0,0,,and other algorithms difficult.
Dialogue: 0,0:25:58.48,0:26:01.28,Default,,0,0,0,,So the expressiveness of\N the language studied in the paper
Dialogue: 0,0:26:01.28,0:26:04.16,Default,,0,0,0,,is in fact similar to\N a structurally typed Java,
Dialogue: 0,0:26:04.16,0:26:10.08,Default,,0,0,0,,which includes its F-bounded\N quantification features.
Dialogue: 0,0:26:10.08,0:26:11.72,Default,,0,0,0,,Another aspect of\N algebraic subtyping
Dialogue: 0,0:26:11.72,0:26:13.20,Default,,0,0,0,,which I would like to clarify
Dialogue: 0,0:26:13.20,0:26:15.92,Default,,0,0,0,,is its relation with invariance.
Dialogue: 0,0:26:15.92,0:26:19.56,Default,,0,0,0,,As a typical example of invariance,\N consider the ref data type,
Dialogue: 0,0:26:19.56,0:26:22.20,Default,,0,0,0,,which is the type of\N mutable variable references
Dialogue: 0,0:26:22.20,0:26:25.40,Default,,0,0,0,,and which is invariant\N in its type argument.
Dialogue: 0,0:26:25.40,0:26:29.60,Default,,0,0,0,,When constraining one ref type\N to be a subtype of another,
Dialogue: 0,0:26:29.60,0:26:33.80,Default,,0,0,0,,it is sufficient to constrain\N the type arguments both ways.
Dialogue: 0,0:26:33.80,0:26:36.80,Default,,0,0,0,,However, we can no longer\N coalesce the type arguments
Dialogue: 0,0:26:36.80,0:26:38.60,Default,,0,0,0,,of invariant types easily,
Dialogue: 0,0:26:38.60,0:26:42.76,Default,,0,0,0,,since coalescing relies on\N the polarity of types to work.
Dialogue: 0,0:26:42.76,0:26:44.24,Default,,0,0,0,,Thankfully, there are several ways
Dialogue: 0,0:26:44.24,0:26:46.08,Default,,0,0,0,,to work around the problem.
Dialogue: 0,0:26:46.08,0:26:48.20,Default,,0,0,0,,We can simply avoid coalescing types
Dialogue: 0,0:26:48.20,0:26:50.08,Default,,0,0,0,,in invariant position,
Dialogue: 0,0:26:50.08,0:26:52.20,Default,,0,0,0,,or we could introduce new notation
Dialogue: 0,0:26:52.20,0:26:54.40,Default,,0,0,0,,to express ranges\N of allowed type arguments
Dialogue: 0,0:26:54.40,0:26:59.48,Default,,0,0,0,,in invariant position.
Dialogue: 0,0:26:59.48,0:27:03.80,Default,,0,0,0,,In conclusion, contrary to\N what many people believe,
Dialogue: 0,0:27:03.80,0:27:05.64,Default,,0,0,0,,complete type inference\N with subtyping
Dialogue: 0,0:27:05.64,0:27:07.76,Default,,0,0,0,,is not actually that hard.
Dialogue: 0,0:27:07.76,0:27:11.08,Default,,0,0,0,,As long as we restrict\N the usage of unions, intersections,
Dialogue: 0,0:27:11.08,0:27:13.72,Default,,0,0,0,,accept a little more verbosity\N around invariance,
Dialogue: 0,0:27:13.72,0:27:15.84,Default,,0,0,0,,and support recursive types.
Dialogue: 0,0:27:15.84,0:27:17.88,Default,,0,0,0,,Simple Sub is available online
Dialogue: 0,0:27:17.88,0:27:20.32,Default,,0,0,0,,and is less than 500 lines of code,
Dialogue: 0,0:27:20.32,0:27:22.64,Default,,0,0,0,,including parsing, type\N inference, simplification,
Dialogue: 0,0:27:22.64,0:27:24.48,Default,,0,0,0,,and pretty printing.
Dialogue: 0,0:27:24.48,0:27:28.20,Default,,0,0,0,,That's it for my presentation.\N Thanks for watching!
Dialogue: 0,0:27:28.20,0:27:35.84,Default,,0,0,0,,(AUDIENCE CLAPS)
Dialogue: 0,0:27:35.84,0:27:37.68,Default,,0,0,0,,STEPHANIE: Thank you Lionel.
Dialogue: 0,0:27:37.68,0:27:42.12,Default,,0,0,0,,If you're watching this talk as\N live as an ICFP participant,
Dialogue: 0,0:27:42.12,0:27:45.36,Default,,0,0,0,,please look to see if there is\N a Q&A session available
Dialogue: 0,0:27:45.36,0:27:57.36,Default,,0,0,0,,with the author in\N your time band now.
Dialogue: 0,0:28:01.40,0:28:03.08,Default,,0,0,0,,Our next talk addresses\N the challenges
Dialogue: 0,0:28:03.08,0:28:04.80,Default,,0,0,0,,of reasoning about resource usage
Dialogue: 0,0:28:04.80,0:28:07.08,Default,,0,0,0,,at compile time.
Dialogue: 0,0:28:07.08,0:28:10.08,Default,,0,0,0,,This talk will be\N presented by Di Wang
Dialogue: 0,0:28:10.08,0:28:13.08,Default,,0,0,0,,and is entitled Liquid\N Resource Types.
Dialogue: 0,0:28:13.08,0:28:17.68,Default,,0,0,0,,It is based on work developed\N by a team of researchers
Dialogue: 0,0:28:17.68,0:28:20.56,Default,,0,0,0,,at university of\N California at San Diego
Dialogue: 0,0:28:20.56,0:28:22.80,Default,,0,0,0,,and at Carnegie Mellon University.
Dialogue: 0,0:28:22.80,0:28:24.72,Default,,0,0,0,,The other authors of\N this paper include
Dialogue: 0,0:28:24.72,0:28:28.96,Default,,0,0,0,,Tristan Knoth, Adam\N Reynolds, Nadia Polikarpova,
Dialogue: 0,0:28:28.96,0:28:33.12,Default,,0,0,0,,and Jan Hoffman.
Dialogue: 0,0:28:33.12,0:28:36.24,Default,,0,0,0,,DI WANG: Hello, ICFP and\N the future viewers of this video.
Dialogue: 0,0:28:36.24,0:28:37.24,Default,,0,0,0,,My name is Di,
Dialogue: 0,0:28:37.24,0:28:39.84,Default,,0,0,0,,a PhD student at\N the Carnegie Mellon University.
Dialogue: 0,0:28:39.84,0:28:41.88,Default,,0,0,0,,And today I'm going\N to present our work
Dialogue: 0,0:28:41.88,0:28:43.64,Default,,0,0,0,,on liquid resource types,
Dialogue: 0,0:28:43.64,0:28:45.68,Default,,0,0,0,,a technique for\N automatically verifying
Dialogue: 0,0:28:45.68,0:28:48.72,Default,,0,0,0,,the resource consumption\N of functional programs.
Dialogue: 0,0:28:48.72,0:28:51.80,Default,,0,0,0,,This is a joint work with\N Tristan, Adam, Nadia,
Dialogue: 0,0:28:51.80,0:28:53.64,Default,,0,0,0,,from the university of San Diego,
Dialogue: 0,0:28:53.64,0:28:56.12,Default,,0,0,0,,and Jan from Carnegie Mellon.
Dialogue: 0,0:28:56.12,0:28:57.40,Default,,0,0,0,,Resource analysis studies
Dialogue: 0,0:28:57.40,0:29:00.72,Default,,0,0,0,,the consumption of various kinds\N of resources in a program,
Dialogue: 0,0:29:00.72,0:29:03.72,Default,,0,0,0,,such as time, memory,\N power, et cetera.
Dialogue: 0,0:29:03.72,0:29:06.00,Default,,0,0,0,,One classic scenario\N for resource analysis
Dialogue: 0,0:29:06.00,0:29:08.92,Default,,0,0,0,,to find out the time\N complexity of algorithms.
Dialogue: 0,0:29:08.92,0:29:11.52,Default,,0,0,0,,Resource analysis can also\N be applied to measure
Dialogue: 0,0:29:11.52,0:29:14.44,Default,,0,0,0,,gas usage of smart\N contract via blockchains
Dialogue: 0,0:29:14.44,0:29:16.84,Default,,0,0,0,,or detect side-channel\N vulnerabilities,
Dialogue: 0,0:29:16.84,0:29:18.92,Default,,0,0,0,,in cryptographic codes.
Dialogue: 0,0:29:18.92,0:29:21.20,Default,,0,0,0,,In this talk, let's\N focus on a scenario
Dialogue: 0,0:29:21.20,0:29:24.60,Default,,0,0,0,,about the time complexity\N of sorting algorithms.
Dialogue: 0,0:29:24.60,0:29:26.24,Default,,0,0,0,,Consider a situation\N where we want to
Dialogue: 0,0:29:26.24,0:29:29.92,Default,,0,0,0,,compare the performance of\N Quick sort and Insertion sorts.
Dialogue: 0,0:29:29.92,0:29:32.08,Default,,0,0,0,,These algorithms are\N functionally equivalent
Dialogue: 0,0:29:32.08,0:29:35.56,Default,,0,0,0,,and both of them run in\N quadratic time in the worst case.
Dialogue: 0,0:29:35.56,0:29:39.56,Default,,0,0,0,,However, if we already know\N the input is nearly sorted,
Dialogue: 0,0:29:39.56,0:29:41.32,Default,,0,0,0,,which means that most\N of the elements
Dialogue: 0,0:29:41.32,0:29:42.84,Default,,0,0,0,,are in the correct place,
Dialogue: 0,0:29:42.84,0:29:45.72,Default,,0,0,0,,which algorithm will have\N a better performance?
Dialogue: 0,0:29:45.72,0:29:49.52,Default,,0,0,0,,In fact, insertion sorts can\N achieve linear time complexity
Dialogue: 0,0:29:49.52,0:29:52.04,Default,,0,0,0,,on nearly sorted data.
Dialogue: 0,0:29:52.04,0:29:54.40,Default,,0,0,0,,So instead of\N a quadratic upper band,
Dialogue: 0,0:29:54.40,0:29:57.08,Default,,0,0,0,,how can we express\N the fine grain complexity
Dialogue: 0,0:29:57.08,0:29:58.52,Default,,0,0,0,,of insertion sorts?
Dialogue: 0,0:29:58.52,0:30:00.56,Default,,0,0,0,,Look at the animation that\N might help you recall
Dialogue: 0,0:30:00.56,0:30:01.92,Default,,0,0,0,,how insertion sort works.
Dialogue: 0,0:30:01.92,0:30:04.24,Default,,0,0,0,,It goes through the elements\N in the list iteratively,
Dialogue: 0,0:30:04.24,0:30:07.72,Default,,0,0,0,,and tries to move them to\N correct places per swaps.
Dialogue: 0,0:30:07.72,0:30:10.00,Default,,0,0,0,,Indeed, we can have\N a better estimation
Dialogue: 0,0:30:10.00,0:30:11.96,Default,,0,0,0,,than the quadratic worst case band.
Dialogue: 0,0:30:11.96,0:30:13.96,Default,,0,0,0,,The amount of swaps is proportional
Dialogue: 0,0:30:13.96,0:30:17.40,Default,,0,0,0,,to the number of out of\N order pairs in the list.
Dialogue: 0,0:30:17.40,0:30:20.72,Default,,0,0,0,,Now, here comes a challenge that\N our work wants to address.
Dialogue: 0,0:30:20.72,0:30:23.56,Default,,0,0,0,,How can a resource analysis\N formally describe
Dialogue: 0,0:30:23.56,0:30:26.24,Default,,0,0,0,,and also automatically\N verify such complex,
Dialogue: 0,0:30:26.24,0:30:28.80,Default,,0,0,0,,value-dependent resource bounds?
Dialogue: 0,0:30:28.80,0:30:30.60,Default,,0,0,0,,To achieve this, our work follows
Dialogue: 0,0:30:30.60,0:30:32.52,Default,,0,0,0,,a (INAUDIBLE) on liquid types,
Dialogue: 0,0:30:32.52,0:30:34.28,Default,,0,0,0,,which support automatic verification
Dialogue: 0,0:30:34.28,0:30:35.76,Default,,0,0,0,,of functional properties.
Dialogue: 0,0:30:35.76,0:30:38.60,Default,,0,0,0,,For example, a function\N returns the absolute value
Dialogue: 0,0:30:38.60,0:30:41.08,Default,,0,0,0,,of its input. Recent augments
Dialogue: 0,0:30:41.08,0:30:42.92,Default,,0,0,0,,of existing liquid type system.
Dialogue: 0,0:30:42.92,0:30:44.72,Default,,0,0,0,,with a simple construct,
Dialogue: 0,0:30:44.72,0:30:47.44,Default,,0,0,0,,types can be annotated\N with potentials.
Dialogue: 0,0:30:47.44,0:30:49.76,Default,,0,0,0,,For example, a list where\N each element carries
Dialogue: 0,0:30:49.76,0:30:51.76,Default,,0,0,0,,one unit of potential.
Dialogue: 0,0:30:51.76,0:30:55.48,Default,,0,0,0,,Potentials can be used to pay\N for the costs in the program.
Dialogue: 0,0:30:55.48,0:30:57.76,Default,,0,0,0,,(INAUDIBLE) function\N consumes all the potential
Dialogue: 0,0:30:57.76,0:30:58.76,Default,,0,0,0,,in the list.
Dialogue: 0,0:30:58.76,0:31:01.60,Default,,0,0,0,,The cost bound is linear in\N the length of the list.
Dialogue: 0,0:31:01.60,0:31:03.76,Default,,0,0,0,,A major limitation of\N recent type system
Dialogue: 0,0:31:03.76,0:31:06.36,Default,,0,0,0,,is that it only\N supports linear bounds.
Dialogue: 0,0:31:06.36,0:31:09.32,Default,,0,0,0,,In our work, we propose\N liquid resource types,
Dialogue: 0,0:31:09.32,0:31:10.84,Default,,0,0,0,,with the ability to express
Dialogue: 0,0:31:10.84,0:31:13.32,Default,,0,0,0,,a lot more nontrivial\N resource bounds.
Dialogue: 0,0:31:13.32,0:31:16.12,Default,,0,0,0,,A key idea is that\N the potential can be inductively
Dialogue: 0,0:31:16.12,0:31:19.88,Default,,0,0,0,,specified from the formation\N of data structure themselves,
Dialogue: 0,0:31:19.88,0:31:22.32,Default,,0,0,0,,which allows us to express\N the time complexity
Dialogue: 0,0:31:22.32,0:31:24.28,Default,,0,0,0,,of insertion sorts.
Dialogue: 0,0:31:24.28,0:31:27.60,Default,,0,0,0,,In general, liquid resource\N types provide a mechanism
Dialogue: 0,0:31:27.60,0:31:30.28,Default,,0,0,0,,for expressing\N and verifying super-linear,
Dialogue: 0,0:31:30.28,0:31:32.24,Default,,0,0,0,,value-dependent resource bounds.
Dialogue: 0,0:31:32.24,0:31:34.48,Default,,0,0,0,,We formalize and prove\N the type soundness
Dialogue: 0,0:31:34.48,0:31:36.92,Default,,0,0,0,,with respect to our cost semantics.
Dialogue: 0,0:31:36.92,0:31:39.56,Default,,0,0,0,,We also implement\N an automatic type checker
Dialogue: 0,0:31:39.56,0:31:40.96,Default,,0,0,0,,for liquid resource types.
Dialogue: 0,0:31:40.96,0:31:44.24,Default,,0,0,0,,And we validate on a suite\N of challenging examples.
Dialogue: 0,0:31:44.24,0:31:47.48,Default,,0,0,0,,Now I have talked about\N motivations for resource analysis
Dialogue: 0,0:31:47.48,0:31:50.08,Default,,0,0,0,,and the main contribution\N of our work.
Dialogue: 0,0:31:50.08,0:31:52.48,Default,,0,0,0,,Before diving into\N the technical details,
Dialogue: 0,0:31:52.48,0:31:54.80,Default,,0,0,0,,I want to first introduce\N two important concepts
Dialogue: 0,0:31:54.80,0:31:56.76,Default,,0,0,0,,that our system is built upon:
Dialogue: 0,0:31:56.76,0:31:59.68,Default,,0,0,0,,Liquid types and\N the potential methods.
Dialogue: 0,0:31:59.68,0:32:02.36,Default,,0,0,0,,Liquid types can be seen as\N a refinement type system
Dialogue: 0,0:32:02.36,0:32:05.04,Default,,0,0,0,,where types are annotated\N with logical predicates
Dialogue: 0,0:32:05.04,0:32:07.28,Default,,0,0,0,,that can constrain the values.
Dialogue: 0,0:32:07.28,0:32:09.72,Default,,0,0,0,,A refined type can be\N written as a subset.
Dialogue: 0,0:32:09.72,0:32:11.40,Default,,0,0,0,,B is a base type of the value
Dialogue: 0,0:32:11.40,0:32:13.44,Default,,0,0,0,,and psi is the logical predicate.
Dialogue: 0,0:32:13.44,0:32:15.72,Default,,0,0,0,,For example,\N natural numbers can be defined
Dialogue: 0,0:32:15.72,0:32:19.04,Default,,0,0,0,,as a refined type with integers.
Dialogue: 0,0:32:19.04,0:32:21.28,Default,,0,0,0,,The predicate can measure\N special variable v,
Dialogue: 0,0:32:21.28,0:32:23.68,Default,,0,0,0,,which reflects the value\N of its inhabitants.
Dialogue: 0,0:32:23.68,0:32:26.08,Default,,0,0,0,,In addition, arrow types\N can be dependent
Dialogue: 0,0:32:26.08,0:32:28.12,Default,,0,0,0,,and result type can be annotated
Dialogue: 0,0:32:28.12,0:32:31.44,Default,,0,0,0,,with the predicate that\N references the arguments.
Dialogue: 0,0:32:31.44,0:32:33.48,Default,,0,0,0,,For example, the type\N shown on the slide,
Dialogue: 0,0:32:33.48,0:32:34.84,Default,,0,0,0,,specifies that function
Dialogue: 0,0:32:34.84,0:32:37.52,Default,,0,0,0,,that returns a list\N whose length is one plus
Dialogue: 0,0:32:37.52,0:32:40.04,Default,,0,0,0,,the length of the input list.
Dialogue: 0,0:32:40.04,0:32:42.68,Default,,0,0,0,,The potential method\N for amortized analysis
Dialogue: 0,0:32:42.68,0:32:45.80,Default,,0,0,0,,is a classic approach\N for algorithm analysis,
Dialogue: 0,0:32:45.80,0:32:48.08,Default,,0,0,0,,which can be dated back to 1985.
Dialogue: 0,0:32:48.08,0:32:50.80,Default,,0,0,0,,The highlight idea is to\N treat a program execution
Dialogue: 0,0:32:50.80,0:32:52.64,Default,,0,0,0,,as a transition graph\N on program states.
Dialogue: 0,0:32:53.32,0:32:54.68,Default,,0,0,0,,And each edge\N of the graph
Dialogue: 0,0:32:54.68,0:32:56.76,Default,,0,0,0,,contains the actual\N transition cost
Dialogue: 0,0:32:56.76,0:32:59.76,Default,,0,0,0,,between two states. To analyze\N the resource consumption,
Dialogue: 0,0:32:59.76,0:33:01.68,Default,,0,0,0,,we devise a potential\N function phi
Dialogue: 0,0:33:01.68,0:33:05.36,Default,,0,0,0,,that maps program state\N to a non-negative number,
Dialogue: 0,0:33:05.36,0:33:07.16,Default,,0,0,0,,such that the potential\N of the state
Dialogue: 0,0:33:07.16,0:33:09.48,Default,,0,0,0,,is enough to pay\N for the extra cost
Dialogue: 0,0:33:09.48,0:33:11.60,Default,,0,0,0,,of the current transition\N and the potential
Dialogue: 0,0:33:11.60,0:33:13.60,Default,,0,0,0,,of the next state\N in this way,
Dialogue: 0,0:33:13.60,0:33:16.64,Default,,0,0,0,,the potential of the initial state\N provide an upper bound
Dialogue: 0,0:33:16.64,0:33:19.24,Default,,0,0,0,,or the actual\N resource consumption.
Dialogue: 0,0:33:19.24,0:33:22.16,Default,,0,0,0,,A prior work, RESYN,\N has combined liquid types
Dialogue: 0,0:33:22.16,0:33:24.16,Default,,0,0,0,,with the potential methods\N to automatically
Dialogue: 0,0:33:24.16,0:33:26.68,Default,,0,0,0,,verify resource bonds\N of functional programs.
Dialogue: 0,0:33:26.68,0:33:29.84,Default,,0,0,0,,The idea is to annotate\N types with potentials.
Dialogue: 0,0:33:29.84,0:33:31.44,Default,,0,0,0,,The potential annotation\N and the logical
Dialogue: 0,0:33:31.44,0:33:34.04,Default,,0,0,0,,predicates are in\N there same refinement language.
Dialogue: 0,0:33:34.04,0:33:36.16,Default,,0,0,0,,The difference is that\N potentials are numeric
Dialogue: 0,0:33:36.16,0:33:39.28,Default,,0,0,0,,while predicates are Boolean.\N The potential annotations
Dialogue: 0,0:33:39.28,0:33:43.00,Default,,0,0,0,,then defines a potential function\N or the value of the annotated type.
Dialogue: 0,0:33:43.00,0:33:46.60,Default,,0,0,0,,For example, the type on the slide\N describes a natural number,
Dialogue: 0,0:33:46.60,0:33:49.80,Default,,0,0,0,,countering potential\N equal to five times of its value.
Dialogue: 0,0:33:49.80,0:33:52.28,Default,,0,0,0,,Potential annotations\N can also be conditional.
Dialogue: 0,0:33:52.28,0:33:55.56,Default,,0,0,0,,The type gesture on the slide\N describes a list of numbers
Dialogue: 0,0:33:55.56,0:33:59.16,Default,,0,0,0,,where each non-negative element\N carries one unit of potential.
Dialogue: 0,0:33:59.16,0:34:01.80,Default,,0,0,0,,With this construct,\N RESYN is able to express
Dialogue: 0,0:34:01.80,0:34:05.08,Default,,0,0,0,,and verify value dependent\N linear resource bounds.
Dialogue: 0,0:34:05.08,0:34:07.88,Default,,0,0,0,,Take a look at\N the functional program on the slide.
Dialogue: 0,0:34:07.88,0:34:10.76,Default,,0,0,0,,The insertion function\N as a subroutine of insertion sort
Dialogue: 0,0:34:10.76,0:34:13.40,Default,,0,0,0,,inserting element X\N to a proper place
Dialogue: 0,0:34:13.40,0:34:16.80,Default,,0,0,0,,in the list Xs.\N We use tick expressions,
Dialogue: 0,0:34:16.80,0:34:20.00,Default,,0,0,0,,marked in blue to\N specify a resource metric.
Dialogue: 0,0:34:20.00,0:34:22.20,Default,,0,0,0,,In this program,\N we use ticks to count the number
Dialogue: 0,0:34:22.20,0:34:24.72,Default,,0,0,0,,of recursive calls.\N RESYN can verify
Dialogue: 0,0:34:24.72,0:34:26.80,Default,,0,0,0,,a value dependent\N linear resource bound
Dialogue: 0,0:34:26.80,0:34:29.08,Default,,0,0,0,,showed on this list,\N however, they can
Dialogue: 0,0:34:29.08,0:34:31.36,Default,,0,0,0,,not express a type\N for insertion sort
Dialogue: 0,0:34:31.36,0:34:35.60,Default,,0,0,0,,because it can only distribute\N potential uniformly within a list.
Dialogue: 0,0:34:35.60,0:34:37.84,Default,,0,0,0,,But insertion sorts\N request a mechanism
Dialogue: 0,0:34:37.84,0:34:41.24,Default,,0,0,0,,to describe pairs\N of elements in the list.
Dialogue: 0,0:34:41.24,0:34:43.80,Default,,0,0,0,,OK, now I have introduced\N two important
Dialogue: 0,0:34:43.80,0:34:47.72,Default,,0,0,0,,building blocks of our work\N liquid types as the potential method.
Dialogue: 0,0:34:47.72,0:34:50.32,Default,,0,0,0,,Now, we have show\N how our work extends prior work,
Dialogue: 0,0:34:50.32,0:34:53.56,Default,,0,0,0,,which two powerful mechanisms\N and how to reduce
Dialogue: 0,0:34:53.56,0:34:56.16,Default,,0,0,0,,type verification\N to constraint solving
Dialogue: 0,0:34:56.16,0:34:59.44,Default,,0,0,0,,Our first mechanism\N is inductive potentials.
Dialogue: 0,0:34:59.44,0:35:01.60,Default,,0,0,0,,Rather than only put\N potential to elements
Dialogue: 0,0:35:01.60,0:35:03.84,Default,,0,0,0,,in a data structure.\N We can specify potentials
Dialogue: 0,0:35:03.84,0:35:07.88,Default,,0,0,0,,inductively from the formation\N of the data structure itself.
Dialogue: 0,0:35:07.88,0:35:10.80,Default,,0,0,0,,The code on the slide\N shows that definition of Q list
Dialogue: 0,0:35:10.80,0:35:14.52,Default,,0,0,0,,a variant of list types\N with quadratic potentials.
Dialogue: 0,0:35:14.52,0:35:18.16,Default,,0,0,0,,Here, the QCons constructor\N maintains that the tail of the list
Dialogue: 0,0:35:18.16,0:35:22.28,Default,,0,0,0,,carries one more unit of potential\N in each element than the head
Dialogue: 0,0:35:22.28,0:35:25.48,Default,,0,0,0,,and the tail itself is\N again a Q list.
Dialogue: 0,0:35:25.48,0:35:28.64,Default,,0,0,0,,How does such a simple\N constant potential annotation
Dialogue: 0,0:35:28.64,0:35:31.60,Default,,0,0,0,,leads to an overall\N quadratic potential function?
Dialogue: 0,0:35:31.60,0:35:35.12,Default,,0,0,0,,Well, let's do a calculation,\N supposed a list of elements
Dialogue: 0,0:35:35.12,0:35:38.68,Default,,0,0,0,,v1, v2, through Vn\N is of type Q list T
Dialogue: 0,0:35:38.68,0:35:43.00,Default,,0,0,0,,While the value of type T\N has P units of potential
Dialogue: 0,0:35:43.00,0:35:45.64,Default,,0,0,0,,Then for every element\N of BI in your list,
Dialogue: 0,0:35:45.64,0:35:49.92,Default,,0,0,0,,it carries P units of potential\N and by definition of QCons.
Dialogue: 0,0:35:49.92,0:35:53.60,Default,,0,0,0,,It also indicates extra potential\N equal to the number of elements
Dialogue: 0,0:35:53.60,0:35:56.64,Default,,0,0,0,,to the right of Vi.\N Therefore, the
Dialogue: 0,0:35:56.64,0:36:00.72,Default,,0,0,0,,potential function is quadratic\N in the length of the list.
Dialogue: 0,0:36:00.72,0:36:02.52,Default,,0,0,0,,More interestingly,\N we can use a value
Dialogue: 0,0:36:02.52,0:36:06.28,Default,,0,0,0,,dependent inductive potential\N to express fine grained bounds.
Dialogue: 0,0:36:06.28,0:36:08.68,Default,,0,0,0,,The type of ISList\N showed on the slide
Dialogue: 0,0:36:08.68,0:36:11.12,Default,,0,0,0,,is almost identical\N to the type QList
Dialogue: 0,0:36:11.12,0:36:15.08,Default,,0,0,0,,except that extra potential required by\N the ISCons constructor
Dialogue: 0,0:36:15.08,0:36:18.24,Default,,0,0,0,,is not the constant one,\N but a conditioner expression
Dialogue: 0,0:36:18.24,0:36:21.04,Default,,0,0,0,,that evaluates to one.\N if and only if the element
Dialogue: 0,0:36:21.04,0:36:23.72,Default,,0,0,0,,in the tail is less than\N the head element,
Dialogue: 0,0:36:23.72,0:36:25.60,Default,,0,0,0,,In other words,\N the potential specified
Dialogue: 0,0:36:25.60,0:36:30.56,Default,,0,0,0,,by ISList is exactly the number\N of out of order pairs in the list.
Dialogue: 0,0:36:30.56,0:36:33.00,Default,,0,0,0,,In this way, we formally express\N the fine-grained
Dialogue: 0,0:36:33.00,0:36:36.60,Default,,0,0,0,,time complexity of insertion sort\N in our type system.
Dialogue: 0,0:36:37.24,0:36:41.64,Default,,0,0,0,,However, inductive potentials\N on their own, are difficult to use.
Dialogue: 0,0:36:41.64,0:36:45.16,Default,,0,0,0,,The potential annotations are built\N into the data type definitions.
Dialogue: 0,0:36:45.16,0:36:47.12,Default,,0,0,0,,So any slight change\N in the analysis
Dialogue: 0,0:36:47.12,0:36:49.76,Default,,0,0,0,,or the resource metric,\N requires defining
Dialogue: 0,0:36:49.76,0:36:52.44,Default,,0,0,0,,a new data type.\N To address this issues,
Dialogue: 0,0:36:52.44,0:36:55.60,Default,,0,0,0,,We have proposed\N a second mechanism,
Dialogue: 0,0:36:55.60,0:36:58.28,Default,,0,0,0,,abstract potentials\N in liquid resource types.
Dialogue: 0,0:36:58.28,0:37:00.08,Default,,0,0,0,,We allow data types\N to be parameterized
Dialogue: 0,0:37:00.08,0:37:04.52,Default,,0,0,0,,by a numeric potential extractor.\N Thus both QList and ISList
Dialogue: 0,0:37:04.52,0:37:08.92,Default,,0,0,0,,can be seen as an extension\N of a more general list type.
Dialogue: 0,0:37:08.92,0:37:12.04,Default,,0,0,0,,The list type is parameterized\N by numerical function Q,
Dialogue: 0,0:37:12.04,0:37:14.92,Default,,0,0,0,,which takes two\N elements as arguments.
Dialogue: 0,0:37:14.92,0:37:17.80,Default,,0,0,0,,Then the Cons constructor\N will use the function Q
Dialogue: 0,0:37:17.80,0:37:20.28,Default,,0,0,0,,to define the amount\N of extra potential
Dialogue: 0,0:37:20.28,0:37:23.28,Default,,0,0,0,,added to the tail.\N What's this abstract type?
Dialogue: 0,0:37:23.28,0:37:26.04,Default,,0,0,0,,QList can be defined\N as List with Q
Dialogue: 0,0:37:26.04,0:37:28.72,Default,,0,0,0,,instantiated with\N a constant one function
Dialogue: 0,0:37:28.72,0:37:32.36,Default,,0,0,0,,while ISList can be defined as List\N with Q instantiated
Dialogue: 0,0:37:32.36,0:37:36.24,Default,,0,0,0,,with the conditional expression\N that compares two elements.
Dialogue: 0,0:37:36.24,0:37:38.76,Default,,0,0,0,,Now you may wonder\N with this new construct,
Dialogue: 0,0:37:38.76,0:37:40.48,Default,,0,0,0,,how can type checking\N your type system
Dialogue: 0,0:37:40.48,0:37:42.84,Default,,0,0,0,,be automated?\N Let's use the insertion
Dialogue: 0,0:37:42.84,0:37:45.52,Default,,0,0,0,,sort program as an example,\N to illustrate a reduction
Dialogue: 0,0:37:45.52,0:37:48.28,Default,,0,0,0,,from type checking\N to constraint solving.
Dialogue: 0,0:37:48.28,0:37:52.92,Default,,0,0,0,,The program uses insert to iteratively\N add elements to the right place.
Dialogue: 0,0:37:52.92,0:37:55.56,Default,,0,0,0,,Our system does not infer types.\N So assume that
Dialogue: 0,0:37:55.56,0:37:58.16,Default,,0,0,0,,we have a type signature\N for recursive functions
Dialogue: 0,0:37:58.16,0:38:00.32,Default,,0,0,0,,insert and sort.\N Our type checker
Dialogue: 0,0:38:00.32,0:38:02.52,Default,,0,0,0,,goes through the program,\N in a top down manner
Dialogue: 0,0:38:02.52,0:38:04.48,Default,,0,0,0,,and generates\N constraints on the fly.
Dialogue: 0,0:38:04.48,0:38:06.44,Default,,0,0,0,,For a sort function\N initially, the constraint
Dialogue: 0,0:38:06.44,0:38:08.88,Default,,0,0,0,,only contains\N the argument Xs.
Dialogue: 0,0:38:08.88,0:38:11.60,Default,,0,0,0,,After the pattern match\N if Xs is an empty list,
Dialogue: 0,0:38:11.60,0:38:14.96,Default,,0,0,0,,then it carries zero potential.\N But because it is also free
Dialogue: 0,0:38:14.96,0:38:18.36,Default,,0,0,0,,to create a new empty list,\N the nil case is verified.
Dialogue: 0,0:38:18.36,0:38:21.72,Default,,0,0,0,,Otherwise, if Xs is not empty,\N then the potential of Xs
Dialogue: 0,0:38:21.72,0:38:23.60,Default,,0,0,0,,is transferred\N to the variables,
Dialogue: 0,0:38:23.60,0:38:27.20,Default,,0,0,0,,head and tail.\N The component of Cons constructor.
Dialogue: 0,0:38:27.20,0:38:30.96,Default,,0,0,0,,Using the definition of Cons,\N we can unfold the type signature
Dialogue: 0,0:38:30.96,0:38:34.80,Default,,0,0,0,,and obtain the potential\N stored in head and in tail.
Dialogue: 0,0:38:34.80,0:38:36.56,Default,,0,0,0,,Then there is the rest\N of the program.
Dialogue: 0,0:38:36.56,0:38:39.36,Default,,0,0,0,,There are two function calls.\N At this point, we need
Dialogue: 0,0:38:39.36,0:38:42.28,Default,,0,0,0,,to split the potential\N in the context into two parts.
Dialogue: 0,0:38:42.28,0:38:44.48,Default,,0,0,0,,And each part is used\N to pay for the cost
Dialogue: 0,0:38:44.48,0:38:47.20,Default,,0,0,0,,of one function call.\N In the top down phase
Dialogue: 0,0:38:47.20,0:38:50.28,Default,,0,0,0,,we don't really know\N how to split the potential.
Dialogue: 0,0:38:50.28,0:38:51.80,Default,,0,0,0,,So it creates\N symbolic potential,
Dialogue: 0,0:38:51.80,0:38:55.00,Default,,0,0,0,,annotations, and generates\N constraints among the symbols.
Dialogue: 0,0:38:55.00,0:38:59.60,Default,,0,0,0,,(INAUDIBLE) for the call to sort,\N it's wrapped by a tick expression.
Dialogue: 0,0:38:59.60,0:39:02.56,Default,,0,0,0,,So it needs to use the potential\N to pay for the tick.
Dialogue: 0,0:39:02.56,0:39:04.28,Default,,0,0,0,,For simplicity,\N let's assume that
Dialogue: 0,0:39:04.28,0:39:06.12,Default,,0,0,0,,the type checker\N uses the potential
Dialogue: 0,0:39:06.12,0:39:08.92,Default,,0,0,0,,stored in head to pay for the tick,\N stored in the context
Dialogue: 0,0:39:08.92,0:39:11.00,Default,,0,0,0,,for type checking\N the call to sort,
Dialogue: 0,0:39:11.00,0:39:14.84,Default,,0,0,0,,the annotation of head\N becomes P2 minus one.
Dialogue: 0,0:39:14.84,0:39:16.08,Default,,0,0,0,,Now let's take a look\N at the constraints
Dialogue: 0,0:39:16.08,0:39:18.64,Default,,0,0,0,,generated by our type checker.\N These constraints (INAUDIBLE)
Dialogue: 0,0:39:18.64,0:39:23.28,Default,,0,0,0,,(INAUDIBLE) P1, P2, Q1, Q2.\N First of all, there are constraints
Dialogue: 0,0:39:23.28,0:39:26.96,Default,,0,0,0,,specifying the potential split.\N The potential in different parts
Dialogue: 0,0:39:26.96,0:39:30.68,Default,,0,0,0,,should sum up to the original potential\N in the context, then for the tick,
Dialogue: 0,0:39:30.68,0:39:32.52,Default,,0,0,0,,we need to ensure\N that the potential
Dialogue: 0,0:39:32.52,0:39:34.52,Default,,0,0,0,,is enough to pay\N for the cost,
Dialogue: 0,0:39:34.52,0:39:36.84,Default,,0,0,0,,which means that\N the potential after the tick
Dialogue: 0,0:39:36.84,0:39:39.88,Default,,0,0,0,,is still non-negative.\N Finally the type checker
Dialogue: 0,0:39:39.88,0:39:42.32,Default,,0,0,0,,generates the constraints\N for function calls
Dialogue: 0,0:39:42.32,0:39:44.48,Default,,0,0,0,,for the call to sort\N which assume that
Dialogue: 0,0:39:44.48,0:39:47.00,Default,,0,0,0,,the type parameter a\N is instantiated away
Dialogue: 0,0:39:47.00,0:39:49.64,Default,,0,0,0,,with some unknown potential\N annotation S
Dialogue: 0,0:39:49.64,0:39:51.52,Default,,0,0,0,,which is used\N to (INAUDIBLE) on potential
Dialogue: 0,0:39:51.52,0:39:54.80,Default,,0,0,0,,to be used by the later\N call to insert.
Dialogue: 0,0:39:54.80,0:39:56.64,Default,,0,0,0,,Similarly, we use\N the signature of insert
Dialogue: 0,0:39:56.64,0:40:01.00,Default,,0,0,0,,to generate that constraint on S.\N Now, after the type checker
Dialogue: 0,0:40:01.00,0:40:03.40,Default,,0,0,0,,generates all its constraints,\N it tries to solve
Dialogue: 0,0:40:03.40,0:40:05.92,Default,,0,0,0,,the constraints by finding\N proper instances
Dialogue: 0,0:40:05.92,0:40:09.48,Default,,0,0,0,,of P1, P2 and Q1, Q2.\N These (INAUDIBLE)
Dialogue: 0,0:40:09.48,0:40:12.32,Default,,0,0,0,,Second-Order Conditional\N Linear Arithmetic constraints.
Dialogue: 0,0:40:12.32,0:40:14.32,Default,,0,0,0,,And solving such constraints\N automatically is
Dialogue: 0,0:40:14.32,0:40:17.32,Default,,0,0,0,,a well-studied problem.\N So in this way,
Dialogue: 0,0:40:17.32,0:40:22.12,Default,,0,0,0,,we built an automatic type checker\N for the liquid resource types.
Dialogue: 0,0:40:22.12,0:40:24.56,Default,,0,0,0,,As for theoretical aspects,\N we've formalized
Dialogue: 0,0:40:24.56,0:40:26.96,Default,,0,0,0,,and proved the soundness of\N liquid resource types,
Dialogue: 0,0:40:26.96,0:40:30.00,Default,,0,0,0,,with respect to a cost-\N aware small step
Dialogue: 0,0:40:30.00,0:40:33.68,Default,,0,0,0,,operational semantics.\N Our soundness theorem
Dialogue: 0,0:40:33.68,0:40:35.08,Default,,0,0,0,,ensures that a well-typed\N closed program
Dialogue: 0,0:40:35.08,0:40:38.20,Default,,0,0,0,,will never run out of resources\N if it starts with
Dialogue: 0,0:40:38.20,0:40:41.08,Default,,0,0,0,,the amount of resources\N equal to the initial potential
Dialogue: 0,0:40:41.08,0:40:44.56,Default,,0,0,0,,specified by the types.\N Details of the theoretical results
Dialogue: 0,0:40:44.56,0:40:47.64,Default,,0,0,0,,can be found in our paper,\N and the technical reports.
Dialogue: 0,0:40:47.64,0:40:49.84,Default,,0,0,0,,As I explained\N how our type system
Dialogue: 0,0:40:49.84,0:40:52.16,Default,,0,0,0,,formally expresses\N and automatically
Dialogue: 0,0:40:52.16,0:40:54.88,Default,,0,0,0,,verifies resource bounds\N with liquid resource types.
Dialogue: 0,0:40:54.88,0:40:58.56,Default,,0,0,0,,You may wonder whether the system\N is effective in practice or not.
Dialogue: 0,0:40:58.56,0:41:00.88,Default,,0,0,0,,Let's first take a look at some\N reusable support resource
Dialogue: 0,0:41:00.88,0:41:03.56,Default,,0,0,0,,annotated data types,\N which we'll use to specify
Dialogue: 0,0:41:03.56,0:41:06.52,Default,,0,0,0,,the type signature\N for benchmark programs.
Dialogue: 0,0:41:06.52,0:41:09.00,Default,,0,0,0,,The first one for\N quadratic potential over lists.
Dialogue: 0,0:41:09.00,0:41:11.56,Default,,0,0,0,,We have already shown\N during the presentation.
Dialogue: 0,0:41:11.56,0:41:15.08,Default,,0,0,0,,The second, one for\N exponential potential over list,
Dialogue: 0,0:41:15.08,0:41:17.88,Default,,0,0,0,,by doubling the potential\N in each element of the tail
Dialogue: 0,0:41:17.88,0:41:20.96,Default,,0,0,0,,in the ECons constructor.\N The third one defines
Dialogue: 0,0:41:20.96,0:41:24.16,Default,,0,0,0,,binary trees, to capture\N tree height in the potential.
Dialogue: 0,0:41:24.16,0:41:26.96,Default,,0,0,0,,The node constructor\N adds Q more units of potential
Dialogue: 0,0:41:26.96,0:41:30.28,Default,,0,0,0,,to the element in the subtree.\N So basically an element
Dialogue: 0,0:41:30.28,0:41:33.64,Default,,0,0,0,,at a leaf carries Q times H,\N units of potential
Dialogue: 0,0:41:33.64,0:41:37.12,Default,,0,0,0,,where H is the depth of the leaf.\N In this way, we can express
Dialogue: 0,0:41:37.12,0:41:39.16,Default,,0,0,0,,our resource bound\N like O(n log n).
Dialogue: 0,0:41:39.16,0:41:41.20,Default,,0,0,0,,when the binary tree\N is balanced.
Dialogue: 0,0:41:41.20,0:41:44.08,Default,,0,0,0,,The fourth one\N also defines binary trees.
Dialogue: 0,0:41:44.08,0:41:46.64,Default,,0,0,0,,(INAUDIBLE)\N specific root to
Dialogue: 0,0:41:46.64,0:41:49.48,Default,,0,0,0,,leaf pass on a tree.\N This is achieved
Dialogue: 0,0:41:49.48,0:41:51.20,Default,,0,0,0,,by parameterizing\N the type
Dialogue: 0,0:41:51.20,0:41:55.20,Default,,0,0,0,,by  logical predicate,\N as a guide to a specific leaf.
Dialogue: 0,0:41:55.20,0:41:56.44,Default,,0,0,0,,With these data types
Dialogue: 0,0:41:56.44,0:41:59.08,Default,,0,0,0,,we are able to extract\N and verify the time complexities
Dialogue: 0,0:41:59.08,0:42:01.72,Default,,0,0,0,,of 12 challenging\N benchmark programs.
Dialogue: 0,0:42:01.72,0:42:03.76,Default,,0,0,0,,As the table shows\N the resource bounds
Dialogue: 0,0:42:03.76,0:42:07.04,Default,,0,0,0,,can be polynomial\N non-polynomial or value dependent,
Dialogue: 0,0:42:07.04,0:42:10.48,Default,,0,0,0,,our prototype implementation\N is reasonably globally efficient,
Dialogue: 0,0:42:10.48,0:42:13.20,Default,,0,0,0,,and (INAUDIBLE)\N resource analysis system
Dialogue: 0,0:42:13.20,0:42:15.88,Default,,0,0,0,,can verify all\N of our benchmarks,
Dialogue: 0,0:42:15.88,0:42:18.92,Default,,0,0,0,,details of the benchmark programs\N can be found in our paper
Dialogue: 0,0:42:18.92,0:42:22.16,Default,,0,0,0,,and the technical reports.\N In summary we propose
Dialogue: 0,0:42:22.16,0:42:24.28,Default,,0,0,0,,liquid resource types\N as an extension
Dialogue: 0,0:42:24.28,0:42:26.48,Default,,0,0,0,,of liquid types to express\N and automatically
Dialogue: 0,0:42:26.48,0:42:29.84,Default,,0,0,0,,verify value-dependent\N super-linear resource bounds
Dialogue: 0,0:42:29.84,0:42:32.04,Default,,0,0,0,,of functional programs.\N We formally prove
Dialogue: 0,0:42:32.04,0:42:34.52,Default,,0,0,0,,the soundness of our\N type system and implement
Dialogue: 0,0:42:34.52,0:42:37.28,Default,,0,0,0,,a prototype type checker\N that is shown to be
Dialogue: 0,0:42:37.28,0:42:40.32,Default,,0,0,0,,effective in our experiments.\N Our work still has
Dialogue: 0,0:42:40.32,0:42:43.12,Default,,0,0,0,,a bunch of limitations.\N For example, our system
Dialogue: 0,0:42:43.12,0:42:45.96,Default,,0,0,0,,only supports\N inductively defined potentials.
Dialogue: 0,0:42:45.96,0:42:49.76,Default,,0,0,0,,Does not allow multi-variant\N bounds like n times m.
Dialogue: 0,0:42:49.76,0:42:52.36,Default,,0,0,0,,And we don't have\N type inference algorithms yet.
Dialogue: 0,0:42:52.36,0:42:55.44,Default,,0,0,0,,These limitations\N are interesting research directions.
Dialogue: 0,0:42:55.44,0:42:57.48,Default,,0,0,0,,And we hope\N to explore some of them
Dialogue: 0,0:42:57.48,0:43:00.56,Default,,0,0,0,,in the future.\N Thanks for your attention.
Dialogue: 0,0:43:00.56,0:43:07.68,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,0:43:08.64,0:43:11.60,Default,,0,0,0,,STEPHANIE Thank you Dee,\N at this point,
Dialogue: 0,0:43:11.60,0:43:15.68,Default,,0,0,0,,if you're watching this stream\N live as an ICP participant,
Dialogue: 0,0:43:15.68,0:43:17.28,Default,,0,0,0,,please remember\N to look to see if
Dialogue: 0,0:43:17.28,0:43:21.40,Default,,0,0,0,,there's a Q&A session\N available in your time band
Dialogue: 0,0:43:21.40,0:43:24.96,Default,,0,0,0,,so that you can discuss\N this work with the author.
Dialogue: 0,0:43:30.40,0:43:31.92,Default,,0,0,0,,Our next talk\N will be presented
Dialogue: 0,0:43:31.92,0:43:34.28,Default,,0,0,0,,by Glen Mével,\N who will be presenting
Dialogue: 0,0:43:34.28,0:43:38.60,Default,,0,0,0,,a concurrent separation logic\N for Multicore OCaml.
Dialogue: 0,0:43:39.80,0:43:42.00,Default,,0,0,0,,GLEN MÉVEL: Welcome to this talk,\N I'm Glen Mével, and with
Dialogue: 0,0:43:42.00,0:43:43.48,Default,,0,0,0,,Jacques-Henri Jourdan\N and François Pottier,
Dialogue: 0,0:43:43.48,0:43:46.32,Default,,0,0,0,,we've been working on\N a concurrent separation logic
Dialogue: 0,0:43:46.32,0:43:48.72,Default,,0,0,0,,for Multicore OCaml\N What does that mean?
Dialogue: 0,0:43:48.72,0:43:51.84,Default,,0,0,0,,Our aim is to verify,\N fine-grained concurrent programs
Dialogue: 0,0:43:51.84,0:43:53.24,Default,,0,0,0,,in the setting\N of the Multicore
Dialogue: 0,0:43:53.24,0:43:57.16,Default,,0,0,0,,OCaml memory model,\N which is a weak memory model.
Dialogue: 0,0:43:57.16,0:43:59.52,Default,,0,0,0,,In this talk,\N I present a concurrent
Dialogue: 0,0:43:59.52,0:44:02.44,Default,,0,0,0,,separation logic\N with a notion of views.
Dialogue: 0,0:44:04.08,0:44:06.60,Default,,0,0,0,,So a few words about\N Multicore Ocaml:
Dialogue: 0,0:44:06.60,0:44:08.88,Default,,0,0,0,,as the name suggests,\N it is an extension
Dialogue: 0,0:44:08.88,0:44:10.44,Default,,0,0,0,,of the OCaml\N programming language
Dialogue: 0,0:44:10.44,0:44:13.12,Default,,0,0,0,,with support\N for multicore programming.
Dialogue: 0,0:44:13.12,0:44:16.32,Default,,0,0,0,,It comes with a weak memory model\N which has been formalized
Dialogue: 0,0:44:16.32,0:44:19.52,Default,,0,0,0,,in a paper at PLDI '18,\N and it features
Dialogue: 0,0:44:19.52,0:44:24.52,Default,,0,0,0,,two flavors of locations\N which are dubbed "atomic" and "non-atomic".
Dialogue: 0,0:44:25.12,0:44:27.52,Default,,0,0,0,,By the way if you're interested\N in the garbage collector
Dialogue: 0,0:44:27.52,0:44:29.92,Default,,0,0,0,,of Multicore OCaml,\N please have a look
Dialogue: 0,0:44:29.92,0:44:32.16,Default,,0,0,0,,at this other ICFP paper, whose title is
Dialogue: 0,0:44:32.16,0:44:35.52,Default,,0,0,0,,"Retrofitting\N Parallelism onto OCaml."
Dialogue: 0,0:44:36.40,0:44:38.20,Default,,0,0,0,,So what is the challenge here?
Dialogue: 0,0:44:38.20,0:44:40.36,Default,,0,0,0,,Essentially, the challenge\N is dealing with
Dialogue: 0,0:44:40.36,0:44:43.28,Default,,0,0,0,,the weak memory.\N Under sequential consistency,
Dialogue: 0,0:44:43.28,0:44:46.08,Default,,0,0,0,,traditional concurrent\N separation logic
Dialogue: 0,0:44:46.08,0:44:49.52,Default,,0,0,0,,gives you a points-to assertion,\N "x points to V"
Dialogue: 0,0:44:49.52,0:44:51.92,Default,,0,0,0,,which expresses your\N unique ownership
Dialogue: 0,0:44:51.92,0:44:55.12,Default,,0,0,0,,of the memory location x\N and which also
Dialogue: 0,0:44:55.12,0:44:58.44,Default,,0,0,0,,says which value\N is stored in x.
Dialogue: 0,0:44:58.44,0:45:01.88,Default,,0,0,0,,Then you have the usual\N Hoare-style reasoning rules.
Dialogue: 0,0:45:01.88,0:45:04.88,Default,,0,0,0,,This assertion\N gives you ownership of x
Dialogue: 0,0:45:04.88,0:45:06.12,Default,,0,0,0,,but you may\N want to share
Dialogue: 0,0:45:06.12,0:45:08.68,Default,,0,0,0,,this ownership\N among all threads.
Dialogue: 0,0:45:08.68,0:45:12.12,Default,,0,0,0,,To do so, an usual solution\N is to put the assertion
Dialogue: 0,0:45:12.12,0:45:14.28,Default,,0,0,0,,in an invariant.
Dialogue: 0,0:45:14.28,0:45:16.88,Default,,0,0,0,,Intuitively an invariant\N holds at all times,
Dialogue: 0,0:45:16.88,0:45:19.52,Default,,0,0,0,,and its contents\N can be accessed equally
Dialogue: 0,0:45:19.52,0:45:21.32,Default,,0,0,0,,by all threads.
Dialogue: 0,0:45:21.84,0:45:24.64,Default,,0,0,0,,Here, we can put\N "x points to something"
Dialogue: 0,0:45:24.64,0:45:26.92,Default,,0,0,0,,in an invariant\N (which we denote
Dialogue: 0,0:45:26.92,0:45:29.96,Default,,0,0,0,,by boxing the assertion),\N then any thread
Dialogue: 0,0:45:29.96,0:45:35.36,Default,,0,0,0,,can access x as long as\N it preserves the invariant.
Dialogue: 0,0:45:35.36,0:45:38.68,Default,,0,0,0,,Now, what breaks\N under a weak memory model
Dialogue: 0,0:45:38.68,0:45:41.24,Default,,0,0,0,,is that each thread\N now has a different
Dialogue: 0,0:45:41.24,0:45:43.96,Default,,0,0,0,,view of memory.\N This notion of view
Dialogue: 0,0:45:43.96,0:45:47.36,Default,,0,0,0,,is crucial, because it means\N that some assertions
Dialogue: 0,0:45:47.36,0:45:50.56,Default,,0,0,0,,like the points-to assertion\N are only valid
Dialogue: 0,0:45:50.56,0:45:53.64,Default,,0,0,0,,with respect\N to the current view of a thread.
Dialogue: 0,0:45:53.64,0:45:56.24,Default,,0,0,0,,We call these kinds\N of assertions
Dialogue: 0,0:45:56.24,0:46:00.64,Default,,0,0,0,,subjective assertions.\N But on the other hand,
Dialogue: 0,0:46:00.64,0:46:03.32,Default,,0,0,0,,invariants hold\N equally for all threads,
Dialogue: 0,0:46:03.32,0:46:05.96,Default,,0,0,0,,so they can only contain\N objective assertions
Dialogue: 0,0:46:05.96,0:46:11.08,Default,,0,0,0,,where by objective\N we mean non-subjective.
Dialogue: 0,0:46:11.08,0:46:14.20,Default,,0,0,0,,Then the challenge\N is to keep a program logic
Dialogue: 0,0:46:14.20,0:46:16.88,Default,,0,0,0,,which feels simple\N and natural enough
Dialogue: 0,0:46:16.88,0:46:18.96,Default,,0,0,0,,but at the same time\N is able to deal
Dialogue: 0,0:46:18.96,0:46:21.16,Default,,0,0,0,,with subjectivity,\N and allows
Dialogue: 0,0:46:21.16,0:46:24.32,Default,,0,0,0,,subjective assertions\N to be shared between threads.
Dialogue: 0,0:46:26.80,0:46:30.04,Default,,0,0,0,,I just spoke about the view\N of a thread and how it is
Dialogue: 0,0:46:30.04,0:46:33.08,Default,,0,0,0,,central to the challenge\N of weak memory,
Dialogue: 0,0:46:33.08,0:46:34.96,Default,,0,0,0,,but I haven't defined\N this concept yet,
Dialogue: 0,0:46:34.96,0:46:38.36,Default,,0,0,0,,so let me do that now.\N Because of weak memory
Dialogue: 0,0:46:38.36,0:46:41.20,Default,,0,0,0,,each thread only knows\N a subset of all writes
Dialogue: 0,0:46:41.20,0:46:44.00,Default,,0,0,0,,that have happened\N to the shared memory.
Dialogue: 0,0:46:44.00,0:46:48.12,Default,,0,0,0,,This affects how\N a thread reads
Dialogue: 0,0:46:48.12,0:46:50.44,Default,,0,0,0,,and writes the memory.\N For example,
Dialogue: 0,0:46:50.44,0:46:53.12,Default,,0,0,0,,once it has learned\N about a write,
Dialogue: 0,0:46:53.12,0:46:56.44,Default,,0,0,0,,it cannot read\N from earlier writes anymore.
Dialogue: 0,0:46:56.44,0:46:58.36,Default,,0,0,0,,This is an example\N of what a weak
Dialogue: 0,0:46:58.36,0:47:03.88,Default,,0,0,0,,memory model would say you.\N And this subset of write events,
Dialogue: 0,0:47:03.88,0:47:06.12,Default,,0,0,0,,we will call it a view.\N So the view of a thread
Dialogue: 0,0:47:06.12,0:47:09.44,Default,,0,0,0,,is the set of\N write events it knows about.
Dialogue: 0,0:47:09.44,0:47:12.48,Default,,0,0,0,,is the set of\N write events it knows about.
Dialogue: 0,0:47:13.36,0:47:17.04,Default,,0,0,0,,Now, we want to manipulate\N these views from the logic.
Dialogue: 0,0:47:17.04,0:47:20.80,Default,,0,0,0,,For that, we add new\N kinds of assertions.
Dialogue: 0,0:47:20.80,0:47:22.88,Default,,0,0,0,,The first new kind\N of assertions is
Dialogue: 0,0:47:22.88,0:47:25.88,Default,,0,0,0,,this "up-arrow U"\N where U is a view,
Dialogue: 0,0:47:25.88,0:47:28.96,Default,,0,0,0,,we pronounce it\N as "we have seen U",
Dialogue: 0,0:47:28.96,0:47:30.84,Default,,0,0,0,,and it means that\N the current thread
Dialogue: 0,0:47:30.84,0:47:32.96,Default,,0,0,0,,knows all writes in U.\N So it is an assertion
Dialogue: 0,0:47:32.96,0:47:36.44,Default,,0,0,0,,about the current view\N of the thread.
Dialogue: 0,0:47:37.00,0:47:39.80,Default,,0,0,0,,The second\N new assertion is "P at U",
Dialogue: 0,0:47:39.80,0:47:42.08,Default,,0,0,0,,where P\N is an assertion
Dialogue: 0,0:47:42.08,0:47:46.04,Default,,0,0,0,,and U is a view.\N It means that P holds in the eyes
Dialogue: 0,0:47:46.04,0:47:48.92,Default,,0,0,0,,of any thread\N which has seen U.
Dialogue: 0,0:47:48.92,0:47:52.28,Default,,0,0,0,,For example, let's say\N that P relies
Dialogue: 0,0:47:52.28,0:47:54.52,Default,,0,0,0,,on knowing\N a given write event.
Dialogue: 0,0:47:54.52,0:47:58.20,Default,,0,0,0,,Then it requires the current view\N to contain that write event.
Dialogue: 0,0:47:58.20,0:48:01.80,Default,,0,0,0,,So asserting P is subjective.
Dialogue: 0,0:48:01.80,0:48:04.24,Default,,0,0,0,,But instead we're going to\N say that whatever
Dialogue: 0,0:48:04.24,0:48:06.76,Default,,0,0,0,,the current view is,\N if it contains
Dialogue: 0,0:48:06.76,0:48:10.16,Default,,0,0,0,,that write event,\N then P holds.
Dialogue: 0,0:48:10.16,0:48:14.24,Default,,0,0,0,,And by saying this, we do not\N depend anymore on the current view.
Dialogue: 0,0:48:14.24,0:48:18.32,Default,,0,0,0,,So saying this is objective,\N even though P
Dialogue: 0,0:48:18.32,0:48:21.24,Default,,0,0,0,,may be subjective.\N And that's what
Dialogue: 0,0:48:21.24,0:48:26.24,Default,,0,0,0,,"P at U" means when\N U contains the given write event.
Dialogue: 0,0:48:28.84,0:48:30.84,Default,,0,0,0,,So we can make\N a subjective assertion objective
Dialogue: 0,0:48:30.84,0:48:35.84,Default,,0,0,0,,by specifying the view\N at which we see it.
Dialogue: 0,0:48:37.56,0:48:39.72,Default,,0,0,0,,And why is it\N interesting?
Dialogue: 0,0:48:39.72,0:48:43.08,Default,,0,0,0,,Because these new\N assertions are complementary.
Dialogue: 0,0:48:43.08,0:48:47.08,Default,,0,0,0,,More precisely, in our logic,\N any assertion P
Dialogue: 0,0:48:47.08,0:48:49.16,Default,,0,0,0,,is equivalent
Dialogue: 0,0:48:49.16,0:48:51.96,Default,,0,0,0,,to an objective assertion\N of the form "P at U",
Dialogue: 0,0:48:51.96,0:48:55.32,Default,,0,0,0,,to an objective assertion\N of the form "P at U",
Dialogue: 0,0:48:55.32,0:48:58.48,Default,,0,0,0,,and a assertion of the form,\N "up-arrow U",
Dialogue: 0,0:48:58.48,0:49:02.64,Default,,0,0,0,,for some view U.\N This shows in particular
Dialogue: 0,0:49:02.64,0:49:06.32,Default,,0,0,0,,that view assertions\N of the form "up-arrow U"
Dialogue: 0,0:49:06.32,0:49:08.76,Default,,0,0,0,,capture all the\N subjectivity of the
Dialogue: 0,0:49:08.76,0:49:12.24,Default,,0,0,0,,weak memory.
Dialogue: 0,0:49:12.76,0:49:16.96,Default,,0,0,0,,And this decomposition will allow us\N to share subjective assertions
Dialogue: 0,0:49:16.96,0:49:19.32,Default,,0,0,0,,between threads, by using\N a different mechanism for each part.
Dialogue: 0,0:49:22.44,0:49:24.48,Default,,0,0,0,,The first part, "P at U",
Dialogue: 0,0:49:24.48,0:49:25.32,Default,,0,0,0,,is objective
Dialogue: 0,0:49:25.32,0:49:27.72,Default,,0,0,0,,so it can be shared via an invariant,
Dialogue: 0,0:49:27.72,0:49:29.44,Default,,0,0,0,,so it can be shared via an invariant,
Dialogue: 0,0:49:29.44,0:49:33.60,Default,,0,0,0,,just as in usual\N concurrent separation logics.
Dialogue: 0,0:49:33.60,0:49:35.08,Default,,0,0,0,,Regarding the second part,
Dialogue: 0,0:49:35.08,0:49:37.08,Default,,0,0,0,,sharing "up-arrow U"
Dialogue: 0,0:49:37.08,0:49:38.96,Default,,0,0,0,,means exchanging information
Dialogue: 0,0:49:38.96,0:49:41.20,Default,,0,0,0,,about write events between threads.
Dialogue: 0,0:49:41.20,0:49:42.04,Default,,0,0,0,,So in other words,
Dialogue: 0,0:49:42.04,0:49:44.32,Default,,0,0,0,,it means synchronizing.
Dialogue: 0,0:49:44.32,0:49:48.20,Default,,0,0,0,,So we will rely on some form\N of thread synchronization
Dialogue: 0,0:49:48.20,0:49:50.72,Default,,0,0,0,,that is provided by the memory model.
Dialogue: 0,0:49:53.32,0:49:55.64,Default,,0,0,0,,That was the main idea of this talk.
Dialogue: 0,0:49:55.64,0:49:59.56,Default,,0,0,0,,Now I show you what is\N in our program logic,
Dialogue: 0,0:49:59.56,0:50:01.44,Default,,0,0,0,,to reason about programs and memory,
Dialogue: 0,0:50:01.44,0:50:03.20,Default,,0,0,0,,and I'll start with the simplest thing,
Dialogue: 0,0:50:03.20,0:50:05.52,Default,,0,0,0,,which are atomic locations.
Dialogue: 0,0:50:06.68,0:50:07.88,Default,,0,0,0,,For atomic locations,
Dialogue: 0,0:50:07.88,0:50:10.52,Default,,0,0,0,,we have an usual-looking\N points-to assertion,
Dialogue: 0,0:50:11.92,0:50:13.68,Default,,0,0,0,,"atomic x points to v",
Dialogue: 0,0:50:13.68,0:50:15.16,Default,,0,0,0,,which means that we own the
Dialogue: 0,0:50:15.16,0:50:17.08,Default,,0,0,0,,atomic location x,
Dialogue: 0,0:50:17.08,0:50:18.60,Default,,0,0,0,,and x stores the value v.
Dialogue: 0,0:50:20.40,0:50:22.68,Default,,0,0,0,,We are able to say such a thing,
Dialogue: 0,0:50:22.68,0:50:25.68,Default,,0,0,0,,because atomic locations\N in Multicore OCaml
Dialogue: 0,0:50:25.68,0:50:28.04,Default,,0,0,0,,behave in a sequentially consistent way.
Dialogue: 0,0:50:28.04,0:50:29.12,Default,,0,0,0,,At any given time,
Dialogue: 0,0:50:29.12,0:50:31.92,Default,,0,0,0,,all threads see the same value for x.
Dialogue: 0,0:50:33.48,0:50:34.84,Default,,0,0,0,,In particular,
Dialogue: 0,0:50:34.84,0:50:36.52,Default,,0,0,0,,this assertion is objective,
Dialogue: 0,0:50:37.48,0:50:39.32,Default,,0,0,0,,then it should come as no surprise
Dialogue: 0,0:50:39.32,0:50:42.00,Default,,0,0,0,,that atomic accesses obey the usual
Dialogue: 0,0:50:42.00,0:50:45.36,Default,,0,0,0,,Hoare triples, both reads and writes.
Dialogue: 0,0:50:48.28,0:50:49.76,Default,,0,0,0,,Where things become interesting,
Dialogue: 0,0:50:49.76,0:50:51.80,Default,,0,0,0,,is for non-atomic locations.
Dialogue: 0,0:50:51.80,0:50:53.52,Default,,0,0,0,,The non-atomic locations of Multicore
Dialogue: 0,0:50:53.52,0:50:55.96,Default,,0,0,0,,OCaml have a relaxed behavior.
Dialogue: 0,0:50:57.04,0:51:00.28,Default,,0,0,0,,In our logic we still have\N an assertion "x points to v",
Dialogue: 0,0:51:00.28,0:51:02.44,Default,,0,0,0,,with its meaning differ slightly.
Dialogue: 0,0:51:02.44,0:51:04.20,Default,,0,0,0,,It still asserts the ownership of x,
Dialogue: 0,0:51:04.20,0:51:05.80,Default,,0,0,0,,but instead of saying that
Dialogue: 0,0:51:06.64,0:51:08.16,Default,,0,0,0,,the value of x is v,
Dialogue: 0,0:51:08.16,0:51:11.36,Default,,0,0,0,,it says that we have seen\N the latest write to x,
Dialogue: 0,0:51:11.36,0:51:13.04,Default,,0,0,0,,and this write bears the value v.
Dialogue: 0,0:51:14.32,0:51:17.88,Default,,0,0,0,,And this is the typical\N subjective assertion.
Dialogue: 0,0:51:17.88,0:51:19.36,Default,,0,0,0,,There is no such a thing as
Dialogue: 0,0:51:19.36,0:51:21.24,Default,,0,0,0,,the global value of x,
Dialogue: 0,0:51:21.24,0:51:24.36,Default,,0,0,0,,because different threads\N do not necessarily know
Dialogue: 0,0:51:24.36,0:51:25.80,Default,,0,0,0,,about the same writes to x.
Dialogue: 0,0:51:28.84,0:51:31.72,Default,,0,0,0,,What is really nice with\N this points-to assertion,
Dialogue: 0,0:51:31.72,0:51:34.24,Default,,0,0,0,,is that it also obeys the standard rules.
Dialogue: 0,0:51:34.24,0:51:37.92,Default,,0,0,0,,So we have a simple looking assertion
Dialogue: 0,0:51:37.92,0:51:39.72,Default,,0,0,0,,that behaves in a natural way,
Dialogue: 0,0:51:39.72,0:51:42.76,Default,,0,0,0,,but the price for it\N is that the assertion
Dialogue: 0,0:51:42.76,0:51:47.04,Default,,0,0,0,,hides more behind the scenes\N and it is subjective.
Dialogue: 0,0:51:47.04,0:51:48.24,Default,,0,0,0,,So we cannot share it
Dialogue: 0,0:51:48.24,0:51:50.48,Default,,0,0,0,,only by using an invariant.
Dialogue: 0,0:51:52.48,0:51:54.44,Default,,0,0,0,,So let's see how\N we can share it nonetheless,
Dialogue: 0,0:51:54.44,0:51:56.32,Default,,0,0,0,,and for that,
Dialogue: 0,0:51:56.32,0:51:58.52,Default,,0,0,0,,let's consider that typical code pattern
Dialogue: 0,0:51:58.52,0:51:59.92,Default,,0,0,0,,which is called a spin lock.
Dialogue: 0,0:52:01.60,0:52:03.32,Default,,0,0,0,,Let's say we have several threads,
Dialogue: 0,0:52:03.32,0:52:05.20,Default,,0,0,0,,that want to access the same resource,
Dialogue: 0,0:52:05.20,0:52:08.44,Default,,0,0,0,,such as a single non-atomic location.
Dialogue: 0,0:52:08.44,0:52:11.00,Default,,0,0,0,,Then we can use an atomic\N flag to guard that resource:
Dialogue: 0,0:52:11.00,0:52:12.20,Default,,0,0,0,,when the flag is true,
Dialogue: 0,0:52:12.20,0:52:13.36,Default,,0,0,0,,the resource is taken,
Dialogue: 0,0:52:13.36,0:52:14.92,Default,,0,0,0,,and if you want to acquire it,
Dialogue: 0,0:52:14.92,0:52:17.64,Default,,0,0,0,,you need to wait for\N it to become available.
Dialogue: 0,0:52:17.64,0:52:19.52,Default,,0,0,0,,Now from a logical point of view,
Dialogue: 0,0:52:19.52,0:52:22.92,Default,,0,0,0,,the lock can be seen as\N guarding an assertion P,
Dialogue: 0,0:52:22.92,0:52:24.08,Default,,0,0,0,,which may be subjective,
Dialogue: 0,0:52:24.08,0:52:24.92,Default,,0,0,0,,for example,
Dialogue: 0,0:52:24.92,0:52:26.72,Default,,0,0,0,,it may be a non-atomic\N points-to assertion,
Dialogue: 0,0:52:26.72,0:52:28.68,Default,,0,0,0,,as evoked just before.
Dialogue: 0,0:52:28.68,0:52:30.76,Default,,0,0,0,,The first thread has P
Dialogue: 0,0:52:30.76,0:52:32.52,Default,,0,0,0,,before releasing the lock.
Dialogue: 0,0:52:32.52,0:52:36.40,Default,,0,0,0,,The second thread will get P\N after it has acquired the lock.
Dialogue: 0,0:52:36.40,0:52:38.92,Default,,0,0,0,,So we want P to be transferred
Dialogue: 0,0:52:38.92,0:52:41.76,Default,,0,0,0,,from the first thread to the second one.
Dialogue: 0,0:52:43.12,0:52:44.48,Default,,0,0,0,,To see how that works,
Dialogue: 0,0:52:44.48,0:52:45.92,Default,,0,0,0,,let's consider
Dialogue: 0,0:52:45.92,0:52:48.64,Default,,0,0,0,,only the compare-and-set\N operation that succeeds,
Dialogue: 0,0:52:48.64,0:52:51.84,Default,,0,0,0,,because that's when the transfer happens.
Dialogue: 0,0:52:53.40,0:52:56.28,Default,,0,0,0,,As we've seen we decompose\N P into an objective part
Dialogue: 0,0:52:56.28,0:52:57.60,Default,,0,0,0,,and a subjective part,
Dialogue: 0,0:52:57.60,0:52:59.36,Default,,0,0,0,,so that we can transfer each part.
Dialogue: 0,0:53:00.28,0:53:03.68,Default,,0,0,0,,The first part, "P at U", is objective.
Dialogue: 0,0:53:03.68,0:53:06.44,Default,,0,0,0,,So it can be transferred\N using an invariant as usual.
Dialogue: 0,0:53:06.44,0:53:08.04,Default,,0,0,0,,So we get rid of it.
Dialogue: 0,0:53:08.04,0:53:10.12,Default,,0,0,0,,So now we are down to the problem
Dialogue: 0,0:53:10.12,0:53:12.20,Default,,0,0,0,,of transferring a view assertion.
Dialogue: 0,0:53:14.16,0:53:15.04,Default,,0,0,0,,As I said before,
Dialogue: 0,0:53:15.04,0:53:17.64,Default,,0,0,0,,we need some form of\N synchronization and, here,
Dialogue: 0,0:53:17.64,0:53:19.00,Default,,0,0,0,,What Multicore OCaml gives us
Dialogue: 0,0:53:19.00,0:53:21.16,Default,,0,0,0,,is a happens-before relationship
Dialogue: 0,0:53:21.16,0:53:24.52,Default,,0,0,0,,from the release write\N to the acquire read.
Dialogue: 0,0:53:24.52,0:53:27.44,Default,,0,0,0,,So instead of adding\N new primitives to the language,
Dialogue: 0,0:53:27.44,0:53:29.08,Default,,0,0,0,,Multicore OCaml made the choice
Dialogue: 0,0:53:29.08,0:53:32.36,Default,,0,0,0,,of performing release/acquire\N synchronization on atomic access.
Dialogue: 0,0:53:34.32,0:53:37.04,Default,,0,0,0,,We need to reflect\N this in our program logic,
Dialogue: 0,0:53:37.04,0:53:38.72,Default,,0,0,0,,and we do so
Dialogue: 0,0:53:38.72,0:53:40.92,Default,,0,0,0,,by extending the atomic\N points-to predicate.
Dialogue: 0,0:53:43.28,0:53:46.76,Default,,0,0,0,,So recall that "atomic points to v"
Dialogue: 0,0:53:46.76,0:53:48.76,Default,,0,0,0,,means that x stores the value v.
Dialogue: 0,0:53:50.56,0:53:52.20,Default,,0,0,0,,We now extend this assertion,
Dialogue: 0,0:53:52.20,0:53:55.08,Default,,0,0,0,,so that an atomic location stores the pair
Dialogue: 0,0:53:55.96,0:53:57.16,Default,,0,0,0,,of a value and a view.
Dialogue: 0,0:53:59.60,0:54:02.00,Default,,0,0,0,,So accesses still behave the same
Dialogue: 0,0:54:02.00,0:54:04.04,Default,,0,0,0,,with respect to the value,
Dialogue: 0,0:54:04.96,0:54:08.92,Default,,0,0,0,,but they also perform a\N release/acquire synchronization
Dialogue: 0,0:54:08.92,0:54:09.76,Default,,0,0,0,,on the view.
Dialogue: 0,0:54:11.40,0:54:12.92,Default,,0,0,0,,So when writing,
Dialogue: 0,0:54:12.92,0:54:15.20,Default,,0,0,0,,we push into the shared location,
Dialogue: 0,0:54:15.20,0:54:17.96,Default,,0,0,0,,any information we have in the local view.
Dialogue: 0,0:54:17.96,0:54:20.20,Default,,0,0,0,,So that's a release write.
Dialogue: 0,0:54:20.20,0:54:21.40,Default,,0,0,0,,And conversely,
Dialogue: 0,0:54:21.40,0:54:25.44,Default,,0,0,0,,when reading, we pull into our local view
Dialogue: 0,0:54:25.44,0:54:28.48,Default,,0,0,0,,any information stored\N in the shared location.
Dialogue: 0,0:54:28.48,0:54:29.72,Default,,0,0,0,,So that's an acquire read.
Dialogue: 0,0:54:32.00,0:54:33.04,Default,,0,0,0,,And with this in mind,
Dialogue: 0,0:54:33.04,0:54:34.68,Default,,0,0,0,,let's come back to our spin lock.
Dialogue: 0,0:54:36.32,0:54:37.64,Default,,0,0,0,,As we have seen before,
Dialogue: 0,0:54:37.64,0:54:40.08,Default,,0,0,0,,the spin lock has two operations,
Dialogue: 0,0:54:40.08,0:54:41.96,Default,,0,0,0,,release and acquire.
Dialogue: 0,0:54:41.96,0:54:44.88,Default,,0,0,0,,In the interface it guards an assertion P.
Dialogue: 0,0:54:44.88,0:54:47.20,Default,,0,0,0,,We give the spin lock a specification,
Dialogue: 0,0:54:47.20,0:54:49.80,Default,,0,0,0,,which holds under some invariant.
Dialogue: 0,0:54:49.80,0:54:50.88,Default,,0,0,0,,And now,
Dialogue: 0,0:54:50.88,0:54:55.08,Default,,0,0,0,,to prove this specification in\N the usual separation logic,
Dialogue: 0,0:54:56.16,0:54:57.64,Default,,0,0,0,,with sequential consistency,
Dialogue: 0,0:54:58.64,0:55:00.44,Default,,0,0,0,,we state an invariant like this:
Dialogue: 0,0:55:01.40,0:55:04.56,Default,,0,0,0,,we are either locked or unlocked,
Dialogue: 0,0:55:04.56,0:55:05.84,Default,,0,0,0,,and in the latter case
Dialogue: 0,0:55:05.84,0:55:08.76,Default,,0,0,0,,the invariant itself holds the assertion P.
Dialogue: 0,0:55:11.40,0:55:14.92,Default,,0,0,0,,Now in our program\N logic with weak memory,
Dialogue: 0,0:55:14.92,0:55:16.56,Default,,0,0,0,,P may be subjective,
Dialogue: 0,0:55:16.56,0:55:20.00,Default,,0,0,0,,but everything in the\N invariant has to be objective.
Dialogue: 0,0:55:20.00,0:55:24.84,Default,,0,0,0,,So the invariant we\N state instead is that one.
Dialogue: 0,0:55:27.28,0:55:28.52,Default,,0,0,0,,In fact,
Dialogue: 0,0:55:28.52,0:55:31.60,Default,,0,0,0,,it is the same as in\N usual separation logic,
Dialogue: 0,0:55:31.60,0:55:33.00,Default,,0,0,0,,but we add views.
Dialogue: 0,0:55:33.00,0:55:34.92,Default,,0,0,0,,To remain objective,
Dialogue: 0,0:55:34.92,0:55:36.24,Default,,0,0,0,,we make it explicit
Dialogue: 0,0:55:36.24,0:55:39.12,Default,,0,0,0,,at which view we have P,
Dialogue: 0,0:55:39.12,0:55:41.28,Default,,0,0,0,,and we say that it is the same view
Dialogue: 0,0:55:41.28,0:55:43.00,Default,,0,0,0,,as is stored in lk.
Dialogue: 0,0:55:43.92,0:55:45.24,Default,,0,0,0,,In other words,
Dialogue: 0,0:55:45.24,0:55:48.56,Default,,0,0,0,,P holds in the eyes of whoever
Dialogue: 0,0:55:48.56,0:55:50.12,Default,,0,0,0,,last released the lock.
Dialogue: 0,0:55:52.44,0:55:55.56,Default,,0,0,0,,So that "P at U" in the invariant
Dialogue: 0,0:55:55.56,0:55:57.36,Default,,0,0,0,,obviously allows to transfer
Dialogue: 0,0:55:57.36,0:55:59.80,Default,,0,0,0,,the objective part of P,
Dialogue: 0,0:55:59.80,0:56:01.52,Default,,0,0,0,,while the atomic location itself
Dialogue: 0,0:56:01.52,0:56:05.36,Default,,0,0,0,,allows to transfer the\N subjective part of P.
Dialogue: 0,0:56:10.48,0:56:13.52,Default,,0,0,0,,So that was the proof of the spin lock.
Dialogue: 0,0:56:13.52,0:56:14.96,Default,,0,0,0,,And in addition to this example,
Dialogue: 0,0:56:14.96,0:56:17.44,Default,,0,0,0,,we did more case studies with\N different kinds of locks
Dialogue: 0,0:56:17.44,0:56:20.60,Default,,0,0,0,,and algorithms for mutual exclusion,
Dialogue: 0,0:56:20.60,0:56:21.96,Default,,0,0,0,,and in all of these examples,
Dialogue: 0,0:56:21.96,0:56:25.28,Default,,0,0,0,,we have been experiencing the same pattern
Dialogue: 0,0:56:25.28,0:56:30.40,Default,,0,0,0,,of sprinkling views over our invariants.
Dialogue: 0,0:56:30.40,0:56:33.72,Default,,0,0,0,,So a general method\N for proving correctness
Dialogue: 0,0:56:33.72,0:56:36.00,Default,,0,0,0,,of a concurrent data structure,
Dialogue: 0,0:56:36.00,0:56:37.88,Default,,0,0,0,,is to start by reasoning
Dialogue: 0,0:56:37.88,0:56:40.56,Default,,0,0,0,,as if we had a sequentially\N consistent model,
Dialogue: 0,0:56:40.56,0:56:43.24,Default,,0,0,0,,express the invariant in the usual
Dialogue: 0,0:56:43.24,0:56:45.04,Default,,0,0,0,,concurrent separation logic.
Dialogue: 0,0:56:45.04,0:56:49.00,Default,,0,0,0,,Then identify where\N synchronization happens,
Dialogue: 0,0:56:49.00,0:56:51.08,Default,,0,0,0,,and make it explicit by adding views.
Dialogue: 0,0:56:55.08,0:56:57.08,Default,,0,0,0,,To sum up I have presented\N a program logic
Dialogue: 0,0:56:57.08,0:56:58.88,Default,,0,0,0,,for Multicore OCaml,
Dialogue: 0,0:56:58.88,0:57:01.72,Default,,0,0,0,,based on isolating\N subjectivity into views.
Dialogue: 0,0:57:01.72,0:57:04.64,Default,,0,0,0,,I argued that this logic enables concise
Dialogue: 0,0:57:04.64,0:57:08.12,Default,,0,0,0,,and natural reasoning on\N how threads synchronize.
Dialogue: 0,0:57:09.12,0:57:10.36,Default,,0,0,0,,There is more in the paper,
Dialogue: 0,0:57:10.36,0:57:13.72,Default,,0,0,0,,namely how the logic is realized,
Dialogue: 0,0:57:13.72,0:57:15.92,Default,,0,0,0,,by building on top of a lower-level logic.
Dialogue: 0,0:57:17.76,0:57:19.88,Default,,0,0,0,,And we also have more case studies.
Dialogue: 0,0:57:21.48,0:57:24.24,Default,,0,0,0,,This entire work is mechanized\N in the Coq proof assistant,
Dialogue: 0,0:57:24.24,0:57:27.12,Default,,0,0,0,,using the Iris separation logic framework.
Dialogue: 0,0:57:27.12,0:57:29.68,Default,,0,0,0,,So we have a verified proof of soundness,
Dialogue: 0,0:57:29.68,0:57:32.76,Default,,0,0,0,,and a toy language with\N which we can write programs
Dialogue: 0,0:57:32.76,0:57:36.12,Default,,0,0,0,,and prove them correct using\N our program logic.
Dialogue: 0,0:57:37.64,0:57:38.80,Default,,0,0,0,,And in the future,
Dialogue: 0,0:57:38.80,0:57:41.68,Default,,0,0,0,,we would like to verify\N even more data structures.
Dialogue: 0,0:57:41.68,0:57:45.08,Default,,0,0,0,,Also we would like to\N investigate data races,
Dialogue: 0,0:57:45.08,0:57:47.88,Default,,0,0,0,,because data races are currently\N not supported in logic,
Dialogue: 0,0:57:49.24,0:57:52.48,Default,,0,0,0,,even though the underlying memory model
Dialogue: 0,0:57:52.48,0:57:54.64,Default,,0,0,0,,gives a few guarantees about them.
Dialogue: 0,0:57:56.00,0:57:57.28,Default,,0,0,0,,Thank you for your attention,
Dialogue: 0,0:57:57.28,0:57:59.24,Default,,0,0,0,,and if you have seen all previous slides,
Dialogue: 0,0:57:59.24,0:58:01.84,Default,,0,0,0,,you hold the right to\N ask questions now.
Dialogue: 0,0:58:03.24,0:58:05.48,Default,,0,0,0,,(clapping)
Dialogue: 0,0:58:12.04,0:58:14.16,Default,,0,0,0,,STEPHANIE: Thank you Glen.
Dialogue: 0,0:58:14.16,0:58:16.04,Default,,0,0,0,,If you are watching this talk live,
Dialogue: 0,0:58:16.04,0:58:17.92,Default,,0,0,0,,as an ICFP participant,
Dialogue: 0,0:58:17.92,0:58:20.96,Default,,0,0,0,,please look to see if there\N is a Q&A session available,
Dialogue: 0,0:58:20.96,0:58:23.28,Default,,0,0,0,,so that you may discuss this work
Dialogue: 0,0:58:23.28,0:58:25.16,Default,,0,0,0,,with the authors of this paper.
Dialogue: 0,0:58:31.88,0:58:33.76,Default,,0,0,0,,The fourth talk of this session,
Dialogue: 0,0:58:33.76,0:58:38.52,Default,,0,0,0,,is entitled Composing and\N Decomposing Op-Based CRDTs
Dialogue: 0,0:58:38.52,0:58:40.64,Default,,0,0,0,,with Semidirect Products.
Dialogue: 0,0:58:40.64,0:58:44.16,Default,,0,0,0,,This paper has been\N written by Matthew Weidner,
Dialogue: 0,0:58:44.16,0:58:46.96,Default,,0,0,0,,Christopher Meiklejohn, Heather Miller,
Dialogue: 0,0:58:46.96,0:58:49.56,Default,,0,0,0,,all from Carnegie Mellon University.
Dialogue: 0,0:58:49.56,0:58:51.48,Default,,0,0,0,,Matthew will be presenting the talk.
Dialogue: 0,0:58:54.32,0:58:55.52,Default,,0,0,0,,MATTHEW WEIDNER: Hello, I'm Matthew.
Dialogue: 0,0:58:55.52,0:58:57.12,Default,,0,0,0,,And I'm going to be\N talking about our paper,
Dialogue: 0,0:58:57.12,0:58:59.60,Default,,0,0,0,,Composing and Decomposing Op-Based\N CRDTs
Dialogue: 0,0:58:59.60,0:59:00.92,Default,,0,0,0,,with Semidirect Products.
Dialogue: 0,0:59:00.92,0:59:02.24,Default,,0,0,0,,And this was worked with Heather Miller,
Dialogue: 0,0:59:02.24,0:59:03.60,Default,,0,0,0,,and Christopher Meiklejohn.
Dialogue: 0,0:59:04.64,0:59:05.48,Default,,0,0,0,,So you'll start off,
Dialogue: 0,0:59:05.48,0:59:06.76,Default,,0,0,0,,let's say you're building a web app,
Dialogue: 0,0:59:06.76,0:59:08.44,Default,,0,0,0,,where you have some kind of storage state,
Dialogue: 0,0:59:08.44,0:59:10.40,Default,,0,0,0,,that can be shared\N between different users.
Dialogue: 0,0:59:10.40,0:59:12.40,Default,,0,0,0,,So this is basically any website nowadays,
Dialogue: 0,0:59:12.40,0:59:14.28,Default,,0,0,0,,and some specific examples I have in mind
Dialogue: 0,0:59:14.28,0:59:16.84,Default,,0,0,0,,are things like Slack or Facebook groups,
Dialogue: 0,0:59:16.84,0:59:19.44,Default,,0,0,0,,maybe a conference management website.
Dialogue: 0,0:59:19.44,0:59:21.12,Default,,0,0,0,,So the usual way you'd build this,
Dialogue: 0,0:59:21.12,0:59:22.96,Default,,0,0,0,,is you have a server.
Dialogue: 0,0:59:22.96,0:59:24.32,Default,,0,0,0,,And when a client wants\N to change their state,
Dialogue: 0,0:59:24.32,0:59:26.48,Default,,0,0,0,,they send a message to the server.
Dialogue: 0,0:59:26.48,0:59:27.40,Default,,0,0,0,,The server responds,
Dialogue: 0,0:59:27.40,0:59:30.08,Default,,0,0,0,,and then the client updates\N their own view of the state.
Dialogue: 0,0:59:30.08,0:59:31.04,Default,,0,0,0,,Okay.
Dialogue: 0,0:59:31.04,0:59:32.48,Default,,0,0,0,,But we know that actually the server
Dialogue: 0,0:59:32.48,0:59:33.68,Default,,0,0,0,,is probably not a single machine,
Dialogue: 0,0:59:33.68,0:59:36.04,Default,,0,0,0,,but a bunch of machines\N working together in the cloud
Dialogue: 0,0:59:36.04,0:59:37.20,Default,,0,0,0,,using message passing.
Dialogue: 0,0:59:38.08,0:59:39.08,Default,,0,0,0,,Now a lot of work has gone
Dialogue: 0,0:59:39.08,0:59:40.52,Default,,0,0,0,,into making these systems efficient
Dialogue: 0,0:59:40.52,0:59:41.84,Default,,0,0,0,,and easier to use,
Dialogue: 0,0:59:41.84,0:59:43.40,Default,,0,0,0,,but it still can get pretty complicated.
Dialogue: 0,0:59:43.40,0:59:45.04,Default,,0,0,0,,It's easy to introduce subtle bugs,
Dialogue: 0,0:59:45.04,0:59:46.64,Default,,0,0,0,,and you need a lot of\N specialized knowledge
Dialogue: 0,0:59:46.64,0:59:48.16,Default,,0,0,0,,to write the server-side code.
Dialogue: 0,0:59:50.32,0:59:52.40,Default,,0,0,0,,So CRDTs is provide an alternative way
Dialogue: 0,0:59:52.40,0:59:56.44,Default,,0,0,0,,to build applications\N that use shared state.
Dialogue: 0,0:59:56.44,0:59:59.40,Default,,0,0,0,,CRDTs stand for Conflict-free\N Replicated Data Types.
Dialogue: 0,0:59:59.40,1:00:01.64,Default,,0,0,0,,And basically they're\N like ordinary datatypes,
Dialogue: 0,1:00:01.64,1:00:04.04,Default,,0,0,0,,except that they're shared\N between a group of users,
Dialogue: 0,1:00:04.04,1:00:05.44,Default,,0,0,0,,and they intelligently sync up
Dialogue: 0,1:00:05.44,1:00:07.44,Default,,0,0,0,,with each other in the background.
Dialogue: 0,1:00:07.44,1:00:09.48,Default,,0,0,0,,So as an example of how you might use this
Dialogue: 0,1:00:09.48,1:00:10.68,Default,,0,0,0,,on the client side,
Dialogue: 0,1:00:10.68,1:00:14.48,Default,,0,0,0,,you can use this snippet\N from the Legion CRDT library.
Dialogue: 0,1:00:14.48,1:00:15.64,Default,,0,0,0,,So the first two lines here
Dialogue: 0,1:00:15.64,1:00:17.80,Default,,0,0,0,,set up the group state basically,
Dialogue: 0,1:00:17.80,1:00:19.44,Default,,0,0,0,,and connect to each other.
Dialogue: 0,1:00:19.44,1:00:20.48,Default,,0,0,0,,And then after that,
Dialogue: 0,1:00:20.48,1:00:22.28,Default,,0,0,0,,if you want to have a shared set,
Dialogue: 0,1:00:22.28,1:00:23.68,Default,,0,0,0,,like maybe a shopping list,
Dialogue: 0,1:00:23.68,1:00:26.24,Default,,0,0,0,,all you do is instead of\N making an ordinary set,
Dialogue: 0,1:00:26.24,1:00:27.96,Default,,0,0,0,,you make a legion set,
Dialogue: 0,1:00:27.96,1:00:30.28,Default,,0,0,0,,and then you can just use this\N like an ordinary data type.
Dialogue: 0,1:00:30.28,1:00:31.12,Default,,0,0,0,,So for instance,
Dialogue: 0,1:00:31.12,1:00:34.44,Default,,0,0,0,,you're can say shopping.addmilk\N to add milk to the set.
Dialogue: 0,1:00:34.44,1:00:36.68,Default,,0,0,0,,And what this will do under the hood
Dialogue: 0,1:00:36.68,1:00:38.80,Default,,0,0,0,,is it updates to some\N local state immediately.
Dialogue: 0,1:00:38.80,1:00:41.00,Default,,0,0,0,,And it also loosely\N broadcasts the operation
Dialogue: 0,1:00:41.00,1:00:42.28,Default,,0,0,0,,to other users and replicas,
Dialogue: 0,1:00:42.28,1:00:43.56,Default,,0,0,0,,who will then apply the operation
Dialogue: 0,1:00:43.56,1:00:45.12,Default,,0,0,0,,to their own copy of the state.
Dialogue: 0,1:00:46.96,1:00:48.28,Default,,0,0,0,,And CRDTs are neat
Dialogue: 0,1:00:48.28,1:00:49.60,Default,,0,0,0,,because they're programming languages
Dialogue: 0,1:00:49.60,1:00:51.12,Default,,0,0,0,,way of solving a systems problem
Dialogue: 0,1:00:51.12,1:00:53.64,Default,,0,0,0,,of how to build these\N applications with shared state.
Dialogue: 0,1:00:53.64,1:00:54.48,Default,,0,0,0,,And in particular,
Dialogue: 0,1:00:54.48,1:00:56.68,Default,,0,0,0,,the way you design them is\N principled and mathematical.
Dialogue: 0,1:00:56.68,1:00:57.52,Default,,0,0,0,,So at least in theory,
Dialogue: 0,1:00:57.52,1:01:00.12,Default,,0,0,0,,it should be hard to introduce\N bugs when you use it.
Dialogue: 0,1:01:01.76,1:01:02.64,Default,,0,0,0,,So some pros.
Dialogue: 0,1:01:02.64,1:01:04.80,Default,,0,0,0,,You have this simple\N client-side programming model,
Dialogue: 0,1:01:04.80,1:01:05.64,Default,,0,0,0,,like I described,
Dialogue: 0,1:01:05.64,1:01:07.00,Default,,0,0,0,,where you basically just switch out your
Dialogue: 0,1:01:07.00,1:01:09.16,Default,,0,0,0,,ordinary data types for CRDTs.
Dialogue: 0,1:01:09.16,1:01:11.88,Default,,0,0,0,,And then they run on\N top of a generic server.
Dialogue: 0,1:01:11.88,1:01:13.04,Default,,0,0,0,,They have minimal latency.
Dialogue: 0,1:01:13.04,1:01:13.96,Default,,0,0,0,,They work offline,
Dialogue: 0,1:01:13.96,1:01:16.08,Default,,0,0,0,,can support end-to-end encryption.
Dialogue: 0,1:01:16.08,1:01:18.04,Default,,0,0,0,,Some cons is that they're targeted
Dialogue: 0,1:01:18.04,1:01:20.44,Default,,0,0,0,,for data that's shared\N in small groups only,
Dialogue: 0,1:01:20.44,1:01:22.60,Default,,0,0,0,,it's because everyone\N has to share the state
Dialogue: 0,1:01:22.60,1:01:23.64,Default,,0,0,0,,with each other and sync up.
Dialogue: 0,1:01:23.64,1:01:25.72,Default,,0,0,0,,So you don't want the group to be too big.
Dialogue: 0,1:01:26.68,1:01:29.00,Default,,0,0,0,,Also they have automatic\N conflict resolution,
Dialogue: 0,1:01:29.00,1:01:31.20,Default,,0,0,0,,but this algorithm will\N make some specific choices,
Dialogue: 0,1:01:31.20,1:01:34.00,Default,,0,0,0,,which won't be appropriate for every app.
Dialogue: 0,1:01:34.00,1:01:35.52,Default,,0,0,0,,They're not for data that needs locking.
Dialogue: 0,1:01:35.52,1:01:37.36,Default,,0,0,0,,But the biggest thing\N that I want to talk about,
Dialogue: 0,1:01:37.36,1:01:38.92,Default,,0,0,0,,is the fact that you have to design
Dialogue: 0,1:01:38.92,1:01:41.60,Default,,0,0,0,,the conflict resolution\N algorithm for each data type.
Dialogue: 0,1:01:41.60,1:01:43.92,Default,,0,0,0,,Which is a difficult and ad hoc process.
Dialogue: 0,1:01:43.92,1:01:44.76,Default,,0,0,0,,So in practice,
Dialogue: 0,1:01:44.76,1:01:46.04,Default,,0,0,0,,what this means is that you're restricted
Dialogue: 0,1:01:46.04,1:01:49.00,Default,,0,0,0,,to using a few common data types\N with restricted interfaces.
Dialogue: 0,1:01:49.00,1:01:50.84,Default,,0,0,0,,Basically whatever CRDT researchers
Dialogue: 0,1:01:50.84,1:01:52.92,Default,,0,0,0,,have figured out within the past 10 years.
Dialogue: 0,1:01:54.96,1:01:55.80,Default,,0,0,0,,In this work,
Dialogue: 0,1:01:55.80,1:01:57.32,Default,,0,0,0,,we present a compositional\N design technique
Dialogue: 0,1:01:57.32,1:01:58.76,Default,,0,0,0,,for op-based CRDTs,
Dialogue: 0,1:01:58.76,1:02:00.28,Default,,0,0,0,,which we call a semidirect product.
Dialogue: 0,1:02:00.28,1:02:02.04,Default,,0,0,0,,It is supposed to address the difficulty
Dialogue: 0,1:02:02.04,1:02:03.20,Default,,0,0,0,,of designing CRDTs.
Dialogue: 0,1:02:04.20,1:02:05.20,Default,,0,0,0,,What it lets you do,
Dialogue: 0,1:02:05.20,1:02:07.00,Default,,0,0,0,,is you take two inputs CRDTs,
Dialogue: 0,1:02:07.00,1:02:08.96,Default,,0,0,0,,here's C1 and C2,
Dialogue: 0,1:02:08.96,1:02:11.92,Default,,0,0,0,,oh and they have to operate\N on the same state type.
Dialogue: 0,1:02:11.92,1:02:13.60,Default,,0,0,0,,You take a bit of extra information
Dialogue: 0,1:02:13.60,1:02:16.20,Default,,0,0,0,,in the form of this function\N that we call the action.
Dialogue: 0,1:02:16.20,1:02:17.36,Default,,0,0,0,,And then what you get out,
Dialogue: 0,1:02:17.36,1:02:21.24,Default,,0,0,0,,is this CRDT that supports the operations
Dialogue: 0,1:02:21.24,1:02:22.76,Default,,0,0,0,,of both of your inputs CRDTs,
Dialogue: 0,1:02:22.76,1:02:25.64,Default,,0,0,0,,and also resolves conflicts\N between them in a natural way.
Dialogue: 0,1:02:27.28,1:02:30.08,Default,,0,0,0,,You can use this for a\N composition of CRDTs directly.
Dialogue: 0,1:02:30.08,1:02:31.64,Default,,0,0,0,,This is where you take two existing CRDTs
Dialogue: 0,1:02:31.64,1:02:33.76,Default,,0,0,0,,and you combine them to get a CRDT
Dialogue: 0,1:02:33.76,1:02:35.76,Default,,0,0,0,,with both of the operations.
Dialogue: 0,1:02:35.76,1:02:36.80,Default,,0,0,0,,In practice usually,
Dialogue: 0,1:02:36.80,1:02:40.68,Default,,0,0,0,,you can use this to add\N operations to an existing CRDT.
Dialogue: 0,1:02:40.68,1:02:41.52,Default,,0,0,0,,So for instance,
Dialogue: 0,1:02:41.52,1:02:43.68,Default,,0,0,0,,we show how to take an\N integer counter CRDT
Dialogue: 0,1:02:43.68,1:02:45.92,Default,,0,0,0,,and add multiplication operations.
Dialogue: 0,1:02:45.92,1:02:48.92,Default,,0,0,0,,or take a list CRDT\N add a reverse operation,
Dialogue: 0,1:02:48.92,1:02:52.44,Default,,0,0,0,,or take a dictionary CRDT\N that maps keys to values
Dialogue: 0,1:02:52.44,1:02:54.44,Default,,0,0,0,,and add a functional mapping operation,
Dialogue: 0,1:02:54.44,1:02:55.76,Default,,0,0,0,,which applies some operation
Dialogue: 0,1:02:55.76,1:02:57.40,Default,,0,0,0,,to every value in the dictionary.
Dialogue: 0,1:02:58.76,1:03:01.28,Default,,0,0,0,,You can also use our semidirect\N product for decomposition,
Dialogue: 0,1:03:01.28,1:03:03.96,Default,,0,0,0,,by which I mean taking\N the existing CRDT design,
Dialogue: 0,1:03:03.96,1:03:06.00,Default,,0,0,0,,and exhibiting it as a semidirect product,
Dialogue: 0,1:03:06.00,1:03:07.64,Default,,0,0,0,,of two simpler CRDTs.
Dialogue: 0,1:03:07.64,1:03:09.24,Default,,0,0,0,,Often, commutative data types,
Dialogue: 0,1:03:09.24,1:03:11.88,Default,,0,0,0,,just sort of the simplest type of CRDTs.
Dialogue: 0,1:03:11.88,1:03:12.72,Default,,0,0,0,,So for instance,
Dialogue: 0,1:03:12.72,1:03:14.24,Default,,0,0,0,,if you have a set CRDT,
Dialogue: 0,1:03:14.24,1:03:15.92,Default,,0,0,0,,we show how to decompose it
Dialogue: 0,1:03:15.92,1:03:18.84,Default,,0,0,0,,into two simpler commutative data types.
Dialogue: 0,1:03:18.84,1:03:20.52,Default,,0,0,0,,One that only has add operations,
Dialogue: 0,1:03:20.52,1:03:22.28,Default,,0,0,0,,and one the only has removes.
Dialogue: 0,1:03:22.28,1:03:25.12,Default,,0,0,0,,Likewise with some generic\N resettable CRDT designs,
Dialogue: 0,1:03:25.12,1:03:27.72,Default,,0,0,0,,we decompose them into the non-resettable,
Dialogue: 0,1:03:27.72,1:03:29.00,Default,,0,0,0,,and the resettable parts.
Dialogue: 0,1:03:31.48,1:03:32.60,Default,,0,0,0,,So to explain our construction,
Dialogue: 0,1:03:32.60,1:03:34.36,Default,,0,0,0,,I first want to give\N a bit more background,
Dialogue: 0,1:03:34.36,1:03:36.12,Default,,0,0,0,,on how CRDTs work.
Dialogue: 0,1:03:36.12,1:03:37.36,Default,,0,0,0,,So recall our system model,
Dialogue: 0,1:03:37.36,1:03:38.76,Default,,0,0,0,,when one user updates the state,
Dialogue: 0,1:03:38.76,1:03:40.60,Default,,0,0,0,,they update their local state immediately,
Dialogue: 0,1:03:40.60,1:03:42.12,Default,,0,0,0,,and also broadcast the operation
Dialogue: 0,1:03:42.12,1:03:44.56,Default,,0,0,0,,to other users in the background.
Dialogue: 0,1:03:44.56,1:03:49.32,Default,,0,0,0,,So the problem can come if you\N have conflicting operations,
Dialogue: 0,1:03:49.32,1:03:50.16,Default,,0,0,0,,for instance,
Dialogue: 0,1:03:50.16,1:03:51.88,Default,,0,0,0,,let's say Alice and Bob share an integer,
Dialogue: 0,1:03:51.88,1:03:53.56,Default,,0,0,0,,and Alice sets the value to three,
Dialogue: 0,1:03:53.56,1:03:56.32,Default,,0,0,0,,while at the same time Bob\N sets the value to five.
Dialogue: 0,1:03:56.32,1:03:58.04,Default,,0,0,0,,So then later they'll\N sync up with each other,
Dialogue: 0,1:03:58.04,1:04:00.44,Default,,0,0,0,,and they see that they have a conflict.
Dialogue: 0,1:04:00.44,1:04:01.92,Default,,0,0,0,,So they have to decide what to do,
Dialogue: 0,1:04:01.92,1:04:03.52,Default,,0,0,0,,in order to get the same answer.
Dialogue: 0,1:04:04.40,1:04:06.72,Default,,0,0,0,,So one main conflict resolution technique,
Dialogue: 0,1:04:06.72,1:04:08.40,Default,,0,0,0,,that's used in CRDT design,
Dialogue: 0,1:04:08.40,1:04:10.48,Default,,0,0,0,,is to make operations commute.
Dialogue: 0,1:04:10.48,1:04:11.64,Default,,0,0,0,,So for instance,
Dialogue: 0,1:04:11.64,1:04:13.60,Default,,0,0,0,,in Alice and Bob example,
Dialogue: 0,1:04:13.60,1:04:15.20,Default,,0,0,0,,let's say that they're\N actually counting something,
Dialogue: 0,1:04:15.20,1:04:17.04,Default,,0,0,0,,like the number of clicks on an ad.
Dialogue: 0,1:04:17.04,1:04:19.08,Default,,0,0,0,,In that case, when Alice\N sets the value to three,
Dialogue: 0,1:04:19.08,1:04:20.04,Default,,0,0,0,,what she actually wants to do
Dialogue: 0,1:04:20.04,1:04:21.96,Default,,0,0,0,,is add three to the current value.
Dialogue: 0,1:04:21.96,1:04:23.76,Default,,0,0,0,,Likewise when Bob sets the value to five,
Dialogue: 0,1:04:23.76,1:04:25.36,Default,,0,0,0,,he actually wants to add five.
Dialogue: 0,1:04:25.36,1:04:26.96,Default,,0,0,0,,But these addition operations
Dialogue: 0,1:04:26.96,1:04:29.84,Default,,0,0,0,,will both get answered eight\N once they exchange operations.
Dialogue: 0,1:04:29.84,1:04:30.68,Default,,0,0,0,,So that's fine.
Dialogue: 0,1:04:30.68,1:04:32.20,Default,,0,0,0,,We avoided the conflict.
Dialogue: 0,1:04:32.20,1:04:33.80,Default,,0,0,0,,You can also use commutatively
Dialogue: 0,1:04:33.80,1:04:34.96,Default,,0,0,0,,to design a clever sequence types
Dialogue: 0,1:04:34.96,1:04:36.28,Default,,0,0,0,,that don't have conflicts.
Dialogue: 0,1:04:37.64,1:04:40.12,Default,,0,0,0,,Another thing you can do is\N to reason about causality.
Dialogue: 0,1:04:40.12,1:04:41.16,Default,,0,0,0,,So I'll go into more detail
Dialogue: 0,1:04:41.16,1:04:43.40,Default,,0,0,0,,about what I mean by\N causality on the next slide.
Dialogue: 0,1:04:43.40,1:04:44.24,Default,,0,0,0,,But a simple example,
Dialogue: 0,1:04:44.24,1:04:46.76,Default,,0,0,0,,is if Alice and Bob share a shopping list,
Dialogue: 0,1:04:46.76,1:04:49.08,Default,,0,0,0,,say Alice adds milk to the shopping list,
Dialogue: 0,1:04:49.08,1:04:51.08,Default,,0,0,0,,later Bob sees this operation,
Dialogue: 0,1:04:51.08,1:04:52.72,Default,,0,0,0,,but he's already bought milk at the store.
Dialogue: 0,1:04:52.72,1:04:55.16,Default,,0,0,0,,So he's going to remove\N milk from the shopping list.
Dialogue: 0,1:04:55.16,1:04:56.52,Default,,0,0,0,,And what a CRDT will do,
Dialogue: 0,1:04:56.52,1:04:59.44,Default,,0,0,0,,is it'll send out a message\N to the other users saying,
Dialogue: 0,1:04:59.44,1:05:00.88,Default,,0,0,0,,remove milk from the shopping list,
Dialogue: 0,1:05:00.88,1:05:03.88,Default,,0,0,0,,but only after applying Alice's operation.
Dialogue: 0,1:05:03.88,1:05:05.84,Default,,0,0,0,,So we notice that anyone else will apply,
Dialogue: 0,1:05:05.84,1:05:07.96,Default,,0,0,0,,add then milk, in that order.
Dialogue: 0,1:05:07.96,1:05:08.80,Default,,0,0,0,,So they'll end up in the state
Dialogue: 0,1:05:08.80,1:05:10.80,Default,,0,0,0,,where they don't have\N milk on the shopping list.
Dialogue: 0,1:05:10.80,1:05:12.64,Default,,0,0,0,,Thus everyone will end\N up in the same state,
Dialogue: 0,1:05:12.64,1:05:15.72,Default,,0,0,0,,there's no conflict anymore.
Dialogue: 0,1:05:15.72,1:05:16.56,Default,,0,0,0,,So in general,
Dialogue: 0,1:05:16.56,1:05:18.00,Default,,0,0,0,,when I say reasoning about causality,
Dialogue: 0,1:05:18.00,1:05:18.84,Default,,0,0,0,,I mean,
Dialogue: 0,1:05:18.84,1:05:22.64,Default,,0,0,0,,reasoning about the causal\N order on operations.
Dialogue: 0,1:05:22.64,1:05:24.12,Default,,0,0,0,,This is the partial order defined
Dialogue: 0,1:05:24.12,1:05:25.72,Default,,0,0,0,,according to three rules,
Dialogue: 0,1:05:25.72,1:05:27.44,Default,,0,0,0,,which I'll illustrate using this diagram.
Dialogue: 0,1:05:27.44,1:05:29.04,Default,,0,0,0,,So here time goes to the right,
Dialogue: 0,1:05:29.04,1:05:32.04,Default,,0,0,0,,and I add more arrows to\N indicate message sending.
Dialogue: 0,1:05:32.04,1:05:32.88,Default,,0,0,0,,Okay.
Dialogue: 0,1:05:32.88,1:05:34.08,Default,,0,0,0,,So the first rule is that,
Dialogue: 0,1:05:34.08,1:05:37.24,Default,,0,0,0,,if some user like Alice sends\N two operations in a row,
Dialogue: 0,1:05:37.24,1:05:39.08,Default,,0,0,0,,and the first operation is\N less than the second one,
Dialogue: 0,1:05:39.08,1:05:40.96,Default,,0,0,0,,we have a partial order,
Dialogue: 0,1:05:40.96,1:05:44.20,Default,,0,0,0,,for instance here adding milk\N is less than adding bread.
Dialogue: 0,1:05:44.20,1:05:46.64,Default,,0,0,0,,The second rule is that if say Alice.
Dialogue: 0,1:05:46.64,1:05:48.44,Default,,0,0,0,,The message,\N Bob receives it,
Dialogue: 0,1:05:48.44,1:05:50.68,Default,,0,0,0,,indicated by the first\N diagonal orange arrow.
Dialogue: 0,1:05:50.68,1:05:52.72,Default,,0,0,0,,And then, Bob sends\N his own operation,
Dialogue: 0,1:05:52.72,1:05:54.24,Default,,0,0,0,,like "Remove milk," here.
Dialogue: 0,1:05:54.24,1:05:56.12,Default,,0,0,0,,Then, the first one\N is less than the second one.
Dialogue: 0,1:05:56.12,1:05:58.20,Default,,0,0,0,,So, here, "Add milk" is\N less than "Remove milk,"
Dialogue: 0,1:05:58.20,1:06:00.32,Default,,0,0,0,,in the causal order.
Dialogue: 0,1:06:00.32,1:06:01.96,Default,,0,0,0,,And the third rule is transitivity.
Dialogue: 0,1:06:01.96,1:06:02.96,Default,,0,0,0,,So, by what I just said,
Dialogue: 0,1:06:02.96,1:06:04.56,Default,,0,0,0,,"Add milk" is less\N than "Remove milk,"
Dialogue: 0,1:06:04.56,1:06:05.88,Default,,0,0,0,,and by the first rule, again,
Dialogue: 0,1:06:05.88,1:06:08.08,Default,,0,0,0,,"Remove milk" is less\N than "Add eggs."
Dialogue: 0,1:06:08.08,1:06:09.92,Default,,0,0,0,,So then, we detect  that, also,
Dialogue: 0,1:06:09.92,1:06:11.36,Default,,0,0,0,,"Add milk" is less than "Add eggs."
Dialogue: 0,1:06:11.36,1:06:13.52,Default,,0,0,0,,A transitivity. OK?
Dialogue: 0,1:06:14.32,1:06:16.00,Default,,0,0,0,,So, note that this\N is a partial order,
Dialogue: 0,1:06:16.00,1:06:18.08,Default,,0,0,0,,and it's possible to have\N a situation like this,
Dialogue: 0,1:06:18.08,1:06:20.12,Default,,0,0,0,,where these two "Add\N milk" operations
Dialogue: 0,1:06:20.12,1:06:22.44,Default,,0,0,0,,are neither less than, nor\N greater than each other.
Dialogue: 0,1:06:22.44,1:06:25.40,Default,,0,0,0,,In this case, we say that\N they're concurrent.
Dialogue: 0,1:06:25.40,1:06:26.60,Default,,0,0,0,,And the good thing about causality
Dialogue: 0,1:06:26.60,1:06:29.16,Default,,0,0,0,,is that CRDTs can query\N the causal order.
Dialogue: 0,1:06:29.16,1:06:31.76,Default,,0,0,0,,Basically, you can attach\N metadata to operations,
Dialogue: 0,1:06:31.76,1:06:33.12,Default,,0,0,0,,when you send them over the network,
Dialogue: 0,1:06:33.12,1:06:35.80,Default,,0,0,0,,so that everyone agrees on\N what the causal order is.
Dialogue: 0,1:06:35.80,1:06:37.16,Default,,0,0,0,,And then, this lets\N you make definitions,
Dialogue: 0,1:06:37.16,1:06:38.84,Default,,0,0,0,,like, for a set CRDT,
Dialogue: 0,1:06:38.84,1:06:40.60,Default,,0,0,0,,you could say X is in the set,
Dialogue: 0,1:06:40.60,1:06:42.48,Default,,0,0,0,,if there is an add x operation
Dialogue: 0,1:06:42.48,1:06:46.16,Default,,0,0,0,,that is not less than\N any remove X operation. OK?
Dialogue: 0,1:06:46.16,1:06:49.28,Default,,0,0,0,,Because this will respect\N the reasoning about causality,
Dialogue: 0,1:06:49.28,1:06:50.88,Default,,0,0,0,,there's no possibility of conflict.
Dialogue: 0,1:06:50.88,1:06:53.00,Default,,0,0,0,,Even if people get operations\N in different orders,
Dialogue: 0,1:06:53.00,1:06:57.16,Default,,0,0,0,,they'll come with the same result.
Dialogue: 0,1:06:57.16,1:06:58.64,Default,,0,0,0,,And you can see, in\N the example I have here,
Dialogue: 0,1:06:58.64,1:07:00.12,Default,,0,0,0,,milk is going to stay\N on the shopping list,
Dialogue: 0,1:07:00.12,1:07:01.52,Default,,0,0,0,,according to this rule,
Dialogue: 0,1:07:01.52,1:07:03.48,Default,,0,0,0,,because Charlie's\N "Add milk" operation
Dialogue: 0,1:07:03.48,1:07:08.48,Default,,0,0,0,,is not constantly less than\N any "Remove milk" operation. OK.
Dialogue: 0,1:07:10.36,1:07:12.28,Default,,0,0,0,,So, again, here are\N the conflict resolution techniques
Dialogue: 0,1:07:12.28,1:07:13.56,Default,,0,0,0,,for building CRDTs:
Dialogue: 0,1:07:13.56,1:07:16.00,Default,,0,0,0,,commutativity\N and reasoning about causality.
Dialogue: 0,1:07:16.00,1:07:17.40,Default,,0,0,0,,There's- then, what\N direct product does
Dialogue: 0,1:07:17.40,1:07:19.80,Default,,0,0,0,,is it provides a uniform\N and reasonable way
Dialogue: 0,1:07:19.80,1:07:21.32,Default,,0,0,0,,of reasoning about causality,
Dialogue: 0,1:07:21.32,1:07:22.36,Default,,0,0,0,,so that CRDT designers
Dialogue: 0,1:07:22.36,1:07:24.96,Default,,0,0,0,,don't have to do it from\N scratch, each time.
Dialogue: 0,1:07:24.96,1:07:26.60,Default,,0,0,0,,This is a good rule for\N coming up with rules,
Dialogue: 0,1:07:26.60,1:07:29.20,Default,,0,0,0,,like this rule that I've\N specified here, for a set,
Dialogue: 0,1:07:29.20,1:07:30.72,Default,,0,0,0,,and it's also good for\N implementing them.
Dialogue: 0,1:07:30.72,1:07:32.00,Default,,0,0,0,,So, if you just look\N at this definition,
Dialogue: 0,1:07:32.00,1:07:33.08,Default,,0,0,0,,it's not entirely clear
Dialogue: 0,1:07:33.08,1:07:35.08,Default,,0,0,0,,how you would implement\N this efficiently,
Dialogue: 0,1:07:35.08,1:07:37.20,Default,,0,0,0,,without just looping over\N the full history of operations,
Dialogue: 0,1:07:37.20,1:07:40.36,Default,,0,0,0,,every time you get a new one. OK?
Dialogue: 0,1:07:40.36,1:07:41.96,Default,,0,0,0,,So, what our semi-direct\N product enables
Dialogue: 0,1:07:41.96,1:07:44.00,Default,,0,0,0,,is a new CRDT-designed workflow.
Dialogue: 0,1:07:44.00,1:07:45.56,Default,,0,0,0,,So, starting from\N an ordinary data type
Dialogue: 0,1:07:45.56,1:07:47.76,Default,,0,0,0,,that you want to turn into a CRDT,
Dialogue: 0,1:07:47.76,1:07:49.80,Default,,0,0,0,,you first design\N commutative data types,
Dialogue: 0,1:07:49.80,1:07:51.48,Default,,0,0,0,,for simple subsets of operations,
Dialogue: 0,1:07:51.48,1:07:53.16,Default,,0,0,0,,and then, you glue\N together those subsets,
Dialogue: 0,1:07:53.16,1:07:54.60,Default,,0,0,0,,the semi-direct products,
Dialogue: 0,1:07:54.60,1:07:56.56,Default,,0,0,0,,and it'll handle conflicts\N between the operations
Dialogue: 0,1:07:56.56,1:07:59.76,Default,,0,0,0,,that don't commute\N in the natural way.
Dialogue: 0,1:07:59.76,1:08:01.32,Default,,0,0,0,,In our experience,\N this design workflow
Dialogue: 0,1:08:01.32,1:08:03.56,Default,,0,0,0,,works for most existing CRDT design,
Dialogue: 0,1:08:03.56,1:08:06.56,Default,,0,0,0,,for existing CRDT types,\N plus novel ones.
Dialogue: 0,1:08:08.24,1:08:09.48,Default,,0,0,0,,OK. Now, for the rest of the talk,
Dialogue: 0,1:08:09.48,1:08:10.96,Default,,0,0,0,,I want to give an example
Dialogue: 0,1:08:10.96,1:08:12.76,Default,,0,0,0,,of how our semi-direct\N product works,
Dialogue: 0,1:08:12.76,1:08:14.40,Default,,0,0,0,,particularly, a simple example.
Dialogue: 0,1:08:14.40,1:08:16.96,Default,,0,0,0,,We're going to just start with\N two commutative data types,
Dialogue: 0,1:08:16.96,1:08:19.44,Default,,0,0,0,,an integer register that\N has add operations,
Dialogue: 0,1:08:19.44,1:08:22.72,Default,,0,0,0,,and an integer register that\N has multiplication operations.
Dialogue: 0,1:08:22.72,1:08:24.00,Default,,0,0,0,,And we went to compose them
Dialogue: 0,1:08:24.00,1:08:25.00,Default,,0,0,0,,into an integer register
Dialogue: 0,1:08:25.00,1:08:28.56,Default,,0,0,0,,that supports both kinds\N of operations at once. OK?
Dialogue: 0,1:08:28.56,1:08:31.32,Default,,0,0,0,,So, an example of something\N you can do with this data type
Dialogue: 0,1:08:31.32,1:08:32.76,Default,,0,0,0,,is, you start in state one,
Dialogue: 0,1:08:32.76,1:08:34.96,Default,,0,0,0,,multiply by three, and add one.
Dialogue: 0,1:08:34.96,1:08:36.60,Default,,0,0,0,,But, of course, the tricky\N part is that multiple users
Dialogue: 0,1:08:36.60,1:08:39.00,Default,,0,0,0,,might be making these\N operations concurrently,
Dialogue: 0,1:08:39.00,1:08:41.60,Default,,0,0,0,,and we have to resolve\N conflict between them.
Dialogue: 0,1:08:41.60,1:08:42.68,Default,,0,0,0,,So, add operations are
Dialogue: 0,1:08:42.68,1:08:43.72,Default,,0,0,0,,alone, are easy.
Dialogue: 0,1:08:43.72,1:08:45.80,Default,,0,0,0,,They already commute,\N so there's no conflicts.
Dialogue: 0,1:08:45.80,1:08:48.32,Default,,0,0,0,,Similarly, for\N multiplication operations,
Dialogue: 0,1:08:48.32,1:08:50.44,Default,,0,0,0,,but they conflict with each other.
Dialogue: 0,1:08:50.44,1:08:52.96,Default,,0,0,0,,For instance, if Dave\N and Mary are sharing a counter,
Dialogue: 0,1:08:52.96,1:08:55.88,Default,,0,0,0,,and then, Dave says to\N multiply his state by three,
Dialogue: 0,1:08:55.88,1:08:58.04,Default,,0,0,0,,while concurrently- so,\N without coordination,
Dialogue: 0,1:08:58.04,1:09:00.00,Default,,0,0,0,,Mary says to add one to her state.
Dialogue: 0,1:09:00.00,1:09:01.92,Default,,0,0,0,,Then, after they\N exchanged these messages,
Dialogue: 0,1:09:01.92,1:09:03.56,Default,,0,0,0,,if we just apply them literally,
Dialogue: 0,1:09:03.56,1:09:04.72,Default,,0,0,0,,they'll end up different States.
Dialogue: 0,1:09:04.72,1:09:07.08,Default,,0,0,0,,Mary's going to be six\N and David's going to get four.
Dialogue: 0,1:09:07.08,1:09:10.32,Default,,0,0,0,,So, this is a conflict. OK.
Dialogue: 0,1:09:10.32,1:09:12.04,Default,,0,0,0,,So now to resolve this conflict,
Dialogue: 0,1:09:12.04,1:09:13.44,Default,,0,0,0,,you're going to make the choice that,
Dialogue: 0,1:09:13.44,1:09:14.68,Default,,0,0,0,,in the face of a conflict,
Dialogue: 0,1:09:14.68,1:09:16.52,Default,,0,0,0,,add should go before mult.
Dialogue: 0,1:09:16.52,1:09:18.24,Default,,0,0,0,,So basically here,\N Mary is in the right
Dialogue: 0,1:09:18.24,1:09:19.24,Default,,0,0,0,,and Dave is in the wrong.
Dialogue: 0,1:09:19.24,1:09:22.12,Default,,0,0,0,,We want to get the answer six.
Dialogue: 0,1:09:22.12,1:09:24.64,Default,,0,0,0,,And our observation is\N that to make this happen,
Dialogue: 0,1:09:24.64,1:09:25.88,Default,,0,0,0,,if you're like Dave here,
Dialogue: 0,1:09:25.88,1:09:28.28,Default,,0,0,0,,and you get the add and\N the mult in the wrong order,
Dialogue: 0,1:09:28.28,1:09:31.00,Default,,0,0,0,,you can fix it up by\N acting on the addition
Dialogue: 0,1:09:31.00,1:09:33.64,Default,,0,0,0,,with the multiplication. OK.
Dialogue: 0,1:09:33.64,1:09:35.16,Default,,0,0,0,,So here, what we say is when Dave
Dialogue: 0,1:09:35.16,1:09:37.44,Default,,0,0,0,,receives Mary's add one message,
Dialogue: 0,1:09:37.44,1:09:38.60,Default,,0,0,0,,instead of applying it literally,
Dialogue: 0,1:09:38.60,1:09:40.48,Default,,0,0,0,,he's going to act on it
Dialogue: 0,1:09:40.48,1:09:42.92,Default,,0,0,0,,with this multiply by three message
Dialogue: 0,1:09:42.92,1:09:44.96,Default,,0,0,0,,and add three instead,
Dialogue: 0,1:09:44.96,1:09:46.88,Default,,0,0,0,,'cause then he gets in\N the state six as well,
Dialogue: 0,1:09:46.88,1:09:48.56,Default,,0,0,0,,and we've solved the conflict.
Dialogue: 0,1:09:48.56,1:09:50.08,Default,,0,0,0,,And this works by\N the Distributive Law
Dialogue: 0,1:09:50.08,1:09:54.28,Default,,0,0,0,,of multiplication over addition. OK.
Dialogue: 0,1:09:54.28,1:09:56.16,Default,,0,0,0,,So more generally, we have\N a more complicated situation
Dialogue: 0,1:09:56.16,1:09:57.20,Default,,0,0,0,,like this one,
Dialogue: 0,1:09:57.20,1:10:00.00,Default,,0,0,0,,we make the rule that when\N you receive an add operation,
Dialogue: 0,1:10:00.00,1:10:02.00,Default,,0,0,0,,before applying it,\N you first act on it
Dialogue: 0,1:10:02.00,1:10:04.08,Default,,0,0,0,,by all concurrent\N multiplication operations
Dialogue: 0,1:10:04.08,1:10:06.72,Default,,0,0,0,,that you've already received. OK.
Dialogue: 0,1:10:06.72,1:10:10.52,Default,,0,0,0,,So in this example,
Dialogue: 0,1:10:10.52,1:10:13.64,Default,,0,0,0,,Dave has multiplied his state\N by two, and then added one,
Dialogue: 0,1:10:13.64,1:10:15.84,Default,,0,0,0,,while concurrently,\N so without coordination,
Dialogue: 0,1:10:15.84,1:10:18.68,Default,,0,0,0,,Mary multiplied by three\N and then added four. OK.
Dialogue: 0,1:10:18.68,1:10:19.68,Default,,0,0,0,,And now they sync up.
Dialogue: 0,1:10:19.68,1:10:22.60,Default,,0,0,0,,So, they exchange these operations.
Dialogue: 0,1:10:22.60,1:10:25.08,Default,,0,0,0,,So Dave gets the multiply by\N three operation for Mary.
Dialogue: 0,1:10:25.08,1:10:26.88,Default,,0,0,0,,We'll just apply that literally
Dialogue: 0,1:10:26.88,1:10:29.08,Default,,0,0,0,,And then, when he gets\N this add four operation,
Dialogue: 0,1:10:29.08,1:10:30.72,Default,,0,0,0,,he first looks in\N his history and sees that
Dialogue: 0,1:10:30.72,1:10:33.68,Default,,0,0,0,,he's already applied\N the multiply by two operation
Dialogue: 0,1:10:33.68,1:10:35.68,Default,,0,0,0,,that is concurrent to the add four.
Dialogue: 0,1:10:35.68,1:10:37.48,Default,,0,0,0,,He's going to use that\N as a transformation
Dialogue: 0,1:10:37.48,1:10:41.12,Default,,0,0,0,,and add two times four\N instead to get 17.
Dialogue: 0,1:10:41.12,1:10:44.12,Default,,0,0,0,,Likewise, Mary receives the multiply\N by two operation from Dave.
Dialogue: 0,1:10:44.12,1:10:45.28,Default,,0,0,0,,She applies it literally.
Dialogue: 0,1:10:45.28,1:10:48.04,Default,,0,0,0,,And then, when she receives\N the add one operation,
Dialogue: 0,1:10:48.04,1:10:50.88,Default,,0,0,0,,she's going to transform it\N by her mult three operation
Dialogue: 0,1:10:50.88,1:10:52.12,Default,,0,0,0,,because that's\N the concurrent message
Dialogue: 0,1:10:52.12,1:10:53.88,Default,,0,0,0,,that she's already applied.
Dialogue: 0,1:10:53.88,1:10:55.60,Default,,0,0,0,,So she adds three instead of one,
Dialogue: 0,1:10:55.60,1:10:58.44,Default,,0,0,0,,And then, they both\N end up in stage 17.
Dialogue: 0,1:10:58.44,1:11:00.44,Default,,0,0,0,,So the fact that they both\N end up in the same state,
Dialogue: 0,1:11:00.44,1:11:05.20,Default,,0,0,0,,was again, just the consequences\N of distributivity.
Dialogue: 0,1:11:05.20,1:11:06.56,Default,,0,0,0,,Well, I know a way of\N stating this rule
Dialogue: 0,1:11:06.56,1:11:10.88,Default,,0,0,0,,is that if you receive an add\N N message from another user,
Dialogue: 0,1:11:10.88,1:11:14.48,Default,,0,0,0,,then you turn it into\N add of N one times N K,
Dialogue: 0,1:11:14.48,1:11:16.16,Default,,0,0,0,,et cetera, times M,
Dialogue: 0,1:11:16.16,1:11:18.08,Default,,0,0,0,,or mult N long through mult N K,
Dialogue: 0,1:11:18.08,1:11:19.64,Default,,0,0,0,,or all the multiply operations
Dialogue: 0,1:11:19.64,1:11:21.16,Default,,0,0,0,,that you've previously received
Dialogue: 0,1:11:21.16,1:11:25.44,Default,,0,0,0,,that are concurrent\N to the one you've just received, OK?
Dialogue: 0,1:11:25.44,1:11:27.52,Default,,0,0,0,,And this rule is\N the same general rule
Dialogue: 0,1:11:27.52,1:11:30.52,Default,,0,0,0,,that we use in the full\N semiproduct construction.
Dialogue: 0,1:11:30.52,1:11:32.28,Default,,0,0,0,,Basically, you give some action,
Dialogue: 0,1:11:32.28,1:11:34.84,Default,,0,0,0,,which says, "If\N I receive one operation
Dialogue: 0,1:11:34.84,1:11:37.72,Default,,0,0,0,,"after a concurrent\N operation of another one,
Dialogue: 0,1:11:37.72,1:11:40.24,Default,,0,0,0,,"I'm going to act on it\N with this action."
Dialogue: 0,1:11:40.24,1:11:41.24,Default,,0,0,0,,And this works in general,
Dialogue: 0,1:11:41.24,1:11:43.72,Default,,0,0,0,,subject to algebraic\N constraints on the input CUDT
Dialogue: 0,1:11:43.72,1:11:46.96,Default,,0,0,0,,and on the action.
Dialogue: 0,1:11:46.96,1:11:50.40,Default,,0,0,0,,OK, so that's all I wanted to\N say about our constructions.
Dialogue: 0,1:11:50.40,1:11:51.56,Default,,0,0,0,,Just a quick recap.
Dialogue: 0,1:11:51.56,1:11:53.68,Default,,0,0,0,,CRDTs are a neat\N programming languages,
Dialogue: 0,1:11:53.68,1:11:55.24,Default,,0,0,0,,way of building systems that act
Dialogue: 0,1:11:55.24,1:11:57.48,Default,,0,0,0,,on a shared state, like web apps.
Dialogue: 0,1:11:57.48,1:11:58.56,Default,,0,0,0,,The way you use them is that
Dialogue: 0,1:11:58.56,1:12:00.40,Default,,0,0,0,,program will just replaced\N ordinary data types
Dialogue: 0,1:12:00.40,1:12:02.64,Default,,0,0,0,,with CRDT versions\N on the client side,
Dialogue: 0,1:12:02.64,1:12:06.48,Default,,0,0,0,,then server is just\N a messaging server.
Dialogue: 0,1:12:06.48,1:12:07.48,Default,,0,0,0,,You want more\N information about these,
Dialogue: 0,1:12:07.48,1:12:10.16,Default,,0,0,0,,I encourage you to check\N out the website, CRDT.tech,
Dialogue: 0,1:12:10.16,1:12:13.40,Default,,0,0,0,,which has a collection\N of nice resources.
Dialogue: 0,1:12:13.40,1:12:16.12,Default,,0,0,0,,So our work present\N the semidirect product,
Dialogue: 0,1:12:16.12,1:12:19.12,Default,,0,0,0,,which is a compositional\N design technique for CRDTs.
Dialogue: 0,1:12:19.12,1:12:22.52,Default,,0,0,0,,These resolve conflicts between operations by\N reasoning about causality,
Dialogue: 0,1:12:22.52,1:12:25.72,Default,,0,0,0,,in a uniform way,\N so that you don't have to.
Dialogue: 0,1:12:25.72,1:12:28.08,Default,,0,0,0,,And it enables a new\N CRDT design workflow,
Dialogue: 0,1:12:28.08,1:12:30.64,Default,,0,0,0,,where you start with a data type\N that you want to replicate,
Dialogue: 0,1:12:31.28,1:12:32.68,Default,,0,0,0,,you design communicative data types,
Dialogue: 0,1:12:32.68,1:12:34.12,Default,,0,0,0,,for subsets of operations,
Dialogue: 0,1:12:34.12,1:12:37.56,Default,,0,0,0,,and then you group these together\N with semidirect products.
Dialogue: 0,1:12:37.56,1:12:39.84,Default,,0,0,0,,OK, that's all I have to say,\N so thanks for watching,
Dialogue: 0,1:12:39.84,1:12:44.84,Default,,0,0,0,,and I hope there'll\N be some questions.
Dialogue: 0,1:12:46.92,1:12:51.92,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:12:54.80,1:12:57.12,Default,,0,0,0,,STEPHANIE: Thank you, Matthew.
Dialogue: 0,1:12:57.12,1:12:59.40,Default,,0,0,0,,If you are watching this talk live,
Dialogue: 0,1:13:00.08,1:13:02.12,Default,,0,0,0,,as an ICFP participant,
Dialogue: 0,1:13:02.12,1:13:05.28,Default,,0,0,0,,please remember to\N join the Q&A session,
Dialogue: 0,1:13:05.28,1:13:10.36,Default,,0,0,0,,if it is available\N in your time zone.
Dialogue: 0,1:13:13.76,1:13:18.16,Default,,0,0,0,,Our next talk is a new approach to\N impredicative polymorphism,
Dialogue: 0,1:13:18.16,1:13:20.56,Default,,0,0,0,,in the Glasgow Haskell Compiler.
Dialogue: 0,1:13:20.56,1:13:25.56,Default,,0,0,0,,This work has been developed by\N Alejandro Serrano, Jurriaan Hage,
Dialogue: 0,1:13:27.08,1:13:30.92,Default,,0,0,0,,Simon Peyton Jones,\N and Dimitrios Vytiniotis.
Dialogue: 0,1:13:30.92,1:13:36.32,Default,,0,0,0,,Alejandro Serrano will be\N giving the presentation.
Dialogue: 0,1:13:36.32,1:13:38.48,Default,,0,0,0,,ALEJANDRO SERRANO: Hi.\N I'm Alejandro.
Dialogue: 0,1:13:38.48,1:13:39.72,Default,,0,0,0,,I'm going to talk to you about
Dialogue: 0,1:13:39.72,1:13:44.24,Default,,0,0,0,,a bit how we brought\N impredicativity into GHC.
Dialogue: 0,1:13:44.24,1:13:48.24,Default,,0,0,0,,But, first of all, what\N is impredicativity?
Dialogue: 0,1:13:48.24,1:13:49.88,Default,,0,0,0,,Take a function like map.
Dialogue: 0,1:13:49.88,1:13:51.76,Default,,0,0,0,,It has two type arguments,
Dialogue: 0,1:13:51.76,1:13:53.84,Default,,0,0,0,,and it takes a function, a list,
Dialogue: 0,1:13:53.84,1:13:56.32,Default,,0,0,0,,and returns a list.
Dialogue: 0,1:13:56.32,1:13:58.92,Default,,0,0,0,,Because, this function\N is polymorphic,
Dialogue: 0,1:13:58.92,1:14:01.20,Default,,0,0,0,,we can use map with\N a wide range of types,
Dialogue: 0,1:14:01.20,1:14:02.52,Default,,0,0,0,,we can use map even,
Dialogue: 0,1:14:02.52,1:14:04.68,Default,,0,0,0,,and then get a function\N from list of ints
Dialogue: 0,1:14:04.68,1:14:05.68,Default,,0,0,0,,to list of bools,
Dialogue: 0,1:14:05.68,1:14:07.96,Default,,0,0,0,,or we can have map, of greater than,
Dialogue: 0,1:14:07.96,1:14:12.16,Default,,0,0,0,,and then we have a list of\N ints to a list of functions.
Dialogue: 0,1:14:12.16,1:14:14.08,Default,,0,0,0,,But, if now we want to use map
Dialogue: 0,1:14:14.08,1:14:17.88,Default,,0,0,0,,with this function, which takes
Dialogue: 0,1:14:17.88,1:14:20.36,Default,,0,0,0,,an argument which itself\N has a polymorphic type,
Dialogue: 0,1:14:21.88,1:14:24.92,Default,,0,0,0,,in many cases we cannot\N really use this.
Dialogue: 0,1:14:24.92,1:14:27.96,Default,,0,0,0,,Polymorphic types, those\N types headed with for all,
Dialogue: 0,1:14:27.96,1:14:32.00,Default,,0,0,0,,are not first-class in\N many programming languages.
Dialogue: 0,1:14:32.00,1:14:34.56,Default,,0,0,0,,Impredicativity is\N exactly the feature
Dialogue: 0,1:14:34.56,1:14:37.32,Default,,0,0,0,,that allows you to\N instantiate a type variable,
Dialogue: 0,1:14:37.32,1:14:38.96,Default,,0,0,0,,like A or B in map,
Dialogue: 0,1:14:38.96,1:14:40.52,Default,,0,0,0,,with a polymorphic type.
Dialogue: 0,1:14:40.52,1:14:44.32,Default,,0,0,0,,A type which has a for all in front.
Dialogue: 0,1:14:44.32,1:14:48.48,Default,,0,0,0,,System F, which is\N the basis for GHC Core,
Dialogue: 0,1:14:48.48,1:14:50.00,Default,,0,0,0,,is itself impredicative.
Dialogue: 0,1:14:50.00,1:14:53.96,Default,,0,0,0,,You can always instantiate\N with a for all type.
Dialogue: 0,1:14:53.96,1:14:57.00,Default,,0,0,0,,But, you have to be very\N explicit about it.
Dialogue: 0,1:14:57.00,1:14:58.24,Default,,0,0,0,,You need to annotate.
Dialogue: 0,1:14:58.24,1:15:01.16,Default,,0,0,0,,In fact, in System F,\N you need to annotate
Dialogue: 0,1:15:01.16,1:15:04.64,Default,,0,0,0,,every time you instantiate\N with a type application,
Dialogue: 0,1:15:04.64,1:15:09.16,Default,,0,0,0,,like I am doing here\N with at for all A, A to A,
Dialogue: 0,1:15:09.16,1:15:12.16,Default,,0,0,0,,and you also have to annotate\N every time you generalize,
Dialogue: 0,1:15:12.16,1:15:14.48,Default,,0,0,0,,every time you need to\N have a for all in a type,
Dialogue: 0,1:15:14.48,1:15:16.60,Default,,0,0,0,,with a big lambda,\N like I am doing here,
Dialogue: 0,1:15:16.60,1:15:20.72,Default,,0,0,0,,in the big lambda for\N the first argument.
Dialogue: 0,1:15:20.72,1:15:23.72,Default,,0,0,0,,So the problem actually\N is not impredicativity,
Dialogue: 0,1:15:23.72,1:15:25.84,Default,,0,0,0,,but impredicative inference.
Dialogue: 0,1:15:25.84,1:15:27.60,Default,,0,0,0,,We want to write\N something like here,
Dialogue: 0,1:15:27.60,1:15:30.92,Default,,0,0,0,,where we cons,\N an identity function to id,
Dialogue: 0,1:15:30.92,1:15:35.16,Default,,0,0,0,,which is itself a list\N of for all A A to As,
Dialogue: 0,1:15:35.16,1:15:38.60,Default,,0,0,0,,and we want the inference
Dialogue: 0,1:15:38.60,1:15:42.52,Default,,0,0,0,,and to be able to add\N anything we need.
Dialogue: 0,1:15:42.52,1:15:44.44,Default,,0,0,0,,But there are several questions.
Dialogue: 0,1:15:44.44,1:15:47.84,Default,,0,0,0,,First of all, how do we\N instantiate the cons?
Dialogue: 0,1:15:47.84,1:15:49.56,Default,,0,0,0,,Hindley-Damas-Milner\N for example,
Dialogue: 0,1:15:49.56,1:15:53.32,Default,,0,0,0,,which is one of the best known\N inference algorithms,
Dialogue: 0,1:15:53.32,1:15:57.12,Default,,0,0,0,,that's not allowed polymorphic\N instantiation at all.
Dialogue: 0,1:15:57.12,1:16:00.60,Default,,0,0,0,,The second question is how\N do we choose to generalize?
Dialogue: 0,1:16:00.60,1:16:03.64,Default,,0,0,0,,How do we know that we have\N to have a big Lambda
Dialogue: 0,1:16:03.64,1:16:07.92,Default,,0,0,0,,at the point we need it\N and not somewhere else?
Dialogue: 0,1:16:07.92,1:16:11.44,Default,,0,0,0,,There's been a lot of work about\N impredicative inference.
Dialogue: 0,1:16:11.44,1:16:14.44,Default,,0,0,0,,There are so many related work.
Dialogue: 0,1:16:14.44,1:16:18.52,Default,,0,0,0,,Here I want to present Quick\N Look which is a new idea
Dialogue: 0,1:16:18.52,1:16:20.96,Default,,0,0,0,,in which what we do is\N we introduce a new
Dialogue: 0,1:16:20.96,1:16:23.48,Default,,0,0,0,,Quick Look phase through\N an instantiation which discovers
Dialogue: 0,1:16:23.48,1:16:26.52,Default,,0,0,0,,impredicativity\N as much as possible.
Dialogue: 0,1:16:26.52,1:16:32.64,Default,,0,0,0,,And then there is a type checking\N just remains as it was.
Dialogue: 0,1:16:32.64,1:16:34.16,Default,,0,0,0,,Let me show you an example.
Dialogue: 0,1:16:34.16,1:16:37.28,Default,,0,0,0,,For example, I have here cons id
Dialogue: 0,1:16:37.28,1:16:41.08,Default,,0,0,0,,where instead of using id directly,
Dialogue: 0,1:16:41.56,1:16:43.64,Default,,0,0,0,,I'm putting this into\N a local binding,
Dialogue: 0,1:16:43.64,1:16:46.56,Default,,0,0,0,,but here you can see all the types.
Dialogue: 0,1:16:46.56,1:16:48.72,Default,,0,0,0,,If you do inference with\N Hindley-Damas-Milner,
Dialogue: 0,1:16:48.72,1:16:51.24,Default,,0,0,0,,what will happen is\N that you instantiate
Dialogue: 0,1:16:51.24,1:16:54.76,Default,,0,0,0,,the type of cons\N and you're introducing cons
Dialogue: 0,1:16:54.76,1:16:58.40,Default,,0,0,0,,applied to one type\N variable, you don't know
Dialogue: 0,1:16:58.40,1:16:59.96,Default,,0,0,0,,I'm going to call it\N alpha here,
Dialogue: 0,1:16:59.96,1:17:03.80,Default,,0,0,0,,and then you have\N the argument id and ids.
Dialogue: 0,1:17:03.80,1:17:08.80,Default,,0,0,0,,The type of the arguments are then\N alpha and list of alphas.
Dialogue: 0,1:17:10.12,1:17:12.76,Default,,0,0,0,,The question now is what\N is alpha of course,
Dialogue: 0,1:17:12.76,1:17:14.72,Default,,0,0,0,,and if you have a declarative spec,
Dialogue: 0,1:17:14.72,1:17:17.20,Default,,0,0,0,,maybe you guess the instantiation,
Dialogue: 0,1:17:17.20,1:17:19.16,Default,,0,0,0,,or if you have a type\N inference engine
Dialogue: 0,1:17:19.16,1:17:21.04,Default,,0,0,0,,that inference will do unification
Dialogue: 0,1:17:21.04,1:17:23.80,Default,,0,0,0,,and try to figure this\N out, but the thing is
Dialogue: 0,1:17:23.80,1:17:28.44,Default,,0,0,0,,no instantiation without\N for all type works,
Dialogue: 0,1:17:28.44,1:17:32.68,Default,,0,0,0,,so this example is prohibited\N by Hindley-Damas-Milner.
Dialogue: 0,1:17:32.68,1:17:34.04,Default,,0,0,0,,How does it work with Quick Look?
Dialogue: 0,1:17:34.04,1:17:35.92,Default,,0,0,0,,Well you start with the same step,
Dialogue: 0,1:17:35.92,1:17:37.72,Default,,0,0,0,,you instantiate the type of cons,
Dialogue: 0,1:17:37.72,1:17:40.84,Default,,0,0,0,,and at this point you have\N a quick look at the arguments.
Dialogue: 0,1:17:40.84,1:17:43.36,Default,,0,0,0,,You try to get as many\N information about
Dialogue: 0,1:17:43.36,1:17:45.12,Default,,0,0,0,,the impredicativity\N you need by looking
Dialogue: 0,1:17:45.12,1:17:47.32,Default,,0,0,0,,at having a peek at the arguments.
Dialogue: 0,1:17:47.32,1:17:48.72,Default,,0,0,0,,In this case we're\N going to learn nothing
Dialogue: 0,1:17:48.72,1:17:50.84,Default,,0,0,0,,from the first argument id,
Dialogue: 0,1:17:50.84,1:17:52.76,Default,,0,0,0,,and from the second arguments\N we're going to learn
Dialogue: 0,1:17:52.76,1:17:57.04,Default,,0,0,0,,that alpha has to be\N exactly for all A, A to A.
Dialogue: 0,1:17:57.04,1:17:58.44,Default,,0,0,0,,At this point, what we\N know is that
Dialogue: 0,1:17:58.44,1:18:01.20,Default,,0,0,0,,the type of these arguments are\N not just any alpha,
Dialogue: 0,1:18:01.20,1:18:05.52,Default,,0,0,0,,they are exactly for all A, A to A\N and list of for all A, A to A.
Dialogue: 0,1:18:05.52,1:18:08.08,Default,,0,0,0,,And there is nothing else to guess
Dialogue: 0,1:18:08.08,1:18:12.48,Default,,0,0,0,,and type checking can succeed.
Dialogue: 0,1:18:12.48,1:18:15.76,Default,,0,0,0,,Now I've said that we\N learn nothing from id,
Dialogue: 0,1:18:15.76,1:18:19.28,Default,,0,0,0,,but from ids we learn\N that alpha must be
Dialogue: 0,1:18:19.28,1:18:21.80,Default,,0,0,0,,for all A, A to A, so you\N might be wondering
Dialogue: 0,1:18:21.80,1:18:24.96,Default,,0,0,0,,what's difference between\N these two arguments?
Dialogue: 0,1:18:24.96,1:18:27.16,Default,,0,0,0,,Let me try to explain this.
Dialogue: 0,1:18:27.16,1:18:30.16,Default,,0,0,0,,Here are the types we are\N push, the types that went
Dialogue: 0,1:18:30.16,1:18:35.08,Default,,0,0,0,,from the instantiation,\N and the types that are obtained
Dialogue: 0,1:18:35.08,1:18:37.24,Default,,0,0,0,,from looking at\N the type of the variables.
Dialogue: 0,1:18:37.24,1:18:39.52,Default,,0,0,0,,In the case of id,\N the type which is pushed
Dialogue: 0,1:18:39.52,1:18:43.88,Default,,0,0,0,,is this single type\N variable alpha
Dialogue: 0,1:18:43.88,1:18:46.52,Default,,0,0,0,,we get from\N the variable is for all A, A to A
Dialogue: 0,1:18:46.52,1:18:48.12,Default,,0,0,0,,and from ids it's\N the same,
Dialogue: 0,1:18:48.12,1:18:53.32,Default,,0,0,0,,but everything\N is wrapped in a list construct.
Dialogue: 0,1:18:53.32,1:18:57.80,Default,,0,0,0,,So actually in the case of ids\N we have only one possibility.
Dialogue: 0,1:18:57.80,1:18:59.72,Default,,0,0,0,,In order for the list of alpha
Dialogue: 0,1:18:59.72,1:19:03.76,Default,,0,0,0,,and the list of for all\N A, A to B to be equal,
Dialogue: 0,1:19:03.76,1:19:08.76,Default,,0,0,0,,just alpha has to be\N for all A, A to A.
Dialogue: 0,1:19:10.20,1:19:13.64,Default,,0,0,0,,Now for the second case, we\N actually have two possibilities.
Dialogue: 0,1:19:13.64,1:19:16.36,Default,,0,0,0,,It could be that alpha\N is for all A, A to A,
Dialogue: 0,1:19:16.36,1:19:17.60,Default,,0,0,0,,but we have another option.
Dialogue: 0,1:19:17.60,1:19:20.08,Default,,0,0,0,,At this point, we could instantiate,
Dialogue: 0,1:19:20.08,1:19:23.16,Default,,0,0,0,,so the for all A, A to\N A becomes beta to beta,
Dialogue: 0,1:19:23.16,1:19:27.68,Default,,0,0,0,,and then we make alpha\N equal to this beta to beta.
Dialogue: 0,1:19:27.68,1:19:30.68,Default,,0,0,0,,The difference here is that\N alpha in the second case
Dialogue: 0,1:19:30.68,1:19:32.44,Default,,0,0,0,,is what we call guarded,
Dialogue: 0,1:19:32.44,1:19:35.68,Default,,0,0,0,,which means it appears\N under a type constructor.
Dialogue: 0,1:19:35.68,1:19:39.28,Default,,0,0,0,,And the key idea is that\N the instantiation relation
Dialogue: 0,1:19:39.28,1:19:41.60,Default,,0,0,0,,becomes simple equality\N when you have
Dialogue: 0,1:19:41.60,1:19:43.48,Default,,0,0,0,,a type constructor on top.
Dialogue: 0,1:19:43.48,1:19:45.96,Default,,0,0,0,,So in the second case, you\N have nothing to decide.
Dialogue: 0,1:19:45.96,1:19:48.08,Default,,0,0,0,,There is only one\N choice, so you take it.
Dialogue: 0,1:19:48.08,1:19:51.52,Default,,0,0,0,,If you have a single type\N variable lying around,
Dialogue: 0,1:19:51.52,1:19:53.96,Default,,0,0,0,,like in a type of ids, you\N don't know what to do,
Dialogue: 0,1:19:53.96,1:19:57.40,Default,,0,0,0,,so we just say, "Well, at this\N point we learn nothing."
Dialogue: 0,1:19:57.40,1:19:58.48,Default,,0,0,0,,And actually, it can be the case
Dialogue: 0,1:19:58.48,1:20:01.00,Default,,0,0,0,,that quick look gets\N us no information.
Dialogue: 0,1:20:01.00,1:20:03.84,Default,,0,0,0,,That's, for example, cons\N id with an empty list.
Dialogue: 0,1:20:03.84,1:20:06.72,Default,,0,0,0,,In this list, we will\N instantiate the type of cons,
Dialogue: 0,1:20:06.72,1:20:08.60,Default,,0,0,0,,have a quick look at the arguments,
Dialogue: 0,1:20:08.60,1:20:10.84,Default,,0,0,0,,and we will learn nothing from id,
Dialogue: 0,1:20:10.84,1:20:12.72,Default,,0,0,0,,and we will learn nothing\N from the empty list,
Dialogue: 0,1:20:12.72,1:20:15.92,Default,,0,0,0,,so we need to fall back to\N monomorphic instantiation.
Dialogue: 0,1:20:15.92,1:20:18.44,Default,,0,0,0,,And the result will be\N that the inferred type
Dialogue: 0,1:20:18.44,1:20:22.80,Default,,0,0,0,,is the most useful\N list of tau to tau,
Dialogue: 0,1:20:22.80,1:20:27.00,Default,,0,0,0,,where these taus are\N monomorphic types.
Dialogue: 0,1:20:27.00,1:20:30.28,Default,,0,0,0,,We can also take some other\N information into account.
Dialogue: 0,1:20:30.28,1:20:33.80,Default,,0,0,0,,Imagine, for example, we\N have this go to single id.
Dialogue: 0,1:20:33.80,1:20:37.36,Default,,0,0,0,,Well, we have a pretty similar\N story with the arguments.
Dialogue: 0,1:20:37.36,1:20:41.40,Default,,0,0,0,,The type of id is going to be\N alpha when we push it,
Dialogue: 0,1:20:41.40,1:20:43.92,Default,,0,0,0,,and then we have\N a for all A, A to A.
Dialogue: 0,1:20:43.92,1:20:45.56,Default,,0,0,0,,So we have two choices here, again:
Dialogue: 0,1:20:45.56,1:20:47.72,Default,,0,0,0,,we can make alpha equal\N to for all A, A to A,
Dialogue: 0,1:20:47.72,1:20:49.60,Default,,0,0,0,,or we could instantiate.
Dialogue: 0,1:20:49.60,1:20:53.96,Default,,0,0,0,,So quick look gives you\N no information here.
Dialogue: 0,1:20:53.96,1:20:56.80,Default,,0,0,0,,But if we have a better look,
Dialogue: 0,1:20:56.80,1:21:00.08,Default,,0,0,0,,we can also take into consideration\N the type of the result,
Dialogue: 0,1:21:00.08,1:21:02.40,Default,,0,0,0,,and in that case, we\N can play the same trick
Dialogue: 0,1:21:02.40,1:21:05.32,Default,,0,0,0,,as we did for\N the cons of id with ids.
Dialogue: 0,1:21:05.32,1:21:08.12,Default,,0,0,0,,The type we get pushed\N is for all A, A to A,
Dialogue: 0,1:21:08.12,1:21:09.24,Default,,0,0,0,,that's from the annotation,
Dialogue: 0,1:21:09.24,1:21:12.84,Default,,0,0,0,,and the type we get from\N the instantiation is list of alpha.
Dialogue: 0,1:21:12.84,1:21:16.68,Default,,0,0,0,,So we can make alpha equal\N to for all A, A to A.
Dialogue: 0,1:21:16.68,1:21:19.24,Default,,0,0,0,,So by knowing\N the special result type,
Dialogue: 0,1:21:19.24,1:21:22.68,Default,,0,0,0,,we can get even more\N impredicative information,
Dialogue: 0,1:21:22.68,1:21:24.60,Default,,0,0,0,,and this will actually inform us
Dialogue: 0,1:21:24.60,1:21:26.92,Default,,0,0,0,,to get a bidirectional type system
Dialogue: 0,1:21:26.92,1:21:30.72,Default,,0,0,0,,instead of a single-directional one,
Dialogue: 0,1:21:30.72,1:21:35.00,Default,,0,0,0,,as Hindley-Milner is, for example.
Dialogue: 0,1:21:35.00,1:21:37.76,Default,,0,0,0,,But the question is when\N to stop with looking.
Dialogue: 0,1:21:37.76,1:21:40.20,Default,,0,0,0,,Up to now, we've only\N dealt with variables.
Dialogue: 0,1:21:40.20,1:21:43.36,Default,,0,0,0,,So everything was one application,
Dialogue: 0,1:21:43.36,1:21:45.28,Default,,0,0,0,,and this application had arguments,
Dialogue: 0,1:21:45.28,1:21:47.96,Default,,0,0,0,,but those arguments\N were all variables.
Dialogue: 0,1:21:47.96,1:21:51.08,Default,,0,0,0,,We can actually go deeper\N and inspect nested applications,
Dialogue: 0,1:21:51.08,1:21:52.24,Default,,0,0,0,,and if you think, for example,
Dialogue: 0,1:21:52.24,1:21:56.00,Default,,0,0,0,,into this goal cons\N id to cons id ids,
Dialogue: 0,1:21:56.00,1:21:58.04,Default,,0,0,0,,in order for the top-most cons
Dialogue: 0,1:21:58.04,1:21:59.36,Default,,0,0,0,,to be correctly instantiated,
Dialogue: 0,1:21:59.36,1:22:03.92,Default,,0,0,0,,you need to go up to\N the ids so that you learn that,
Dialogue: 0,1:22:03.92,1:22:06.16,Default,,0,0,0,,well, this should\N have a type of list
Dialogue: 0,1:22:06.16,1:22:09.44,Default,,0,0,0,,of for all A, A to A, and this\N will inform both constants.
Dialogue: 0,1:22:09.44,1:22:12.64,Default,,0,0,0,,So you gain something by\N inspecting nested applications.
Dialogue: 0,1:22:13.32,1:22:15.84,Default,,0,0,0,,But we don't know more.\N We really want to keep this simple.
Dialogue: 0,1:22:15.84,1:22:18.24,Default,,0,0,0,,We don't want to go\N into environmental changes.
Dialogue: 0,1:22:18.24,1:22:21.00,Default,,0,0,0,,So we don't inspect lambdas.\N We don't inspect
Dialogue: 0,1:22:21.00,1:22:24.28,Default,,0,0,0,,let's because this introduce\N new things into the environment.
Dialogue: 0,1:22:24.28,1:22:26.32,Default,,0,0,0,,And we don't try\N to inspect them
Dialogue: 0,1:22:26.32,1:22:29.12,Default,,0,0,0,,with multiple branches,\N like ifs or pattern matching
Dialogue: 0,1:22:29.12,1:22:33.00,Default,,0,0,0,,because it will lead us\N that we need to not only
Dialogue: 0,1:22:33.00,1:22:35.24,Default,,0,0,0,,unify things in a simple way\N we also need
Dialogue: 0,1:22:35.24,1:22:38.04,Default,,0,0,0,,to consider the case\N in which these two branches
Dialogue: 0,1:22:38.04,1:22:41.52,Default,,0,0,0,,don't have a similar type.\N So we just really want
Dialogue: 0,1:22:41.52,1:22:43.56,Default,,0,0,0,,to keep it simple.\N And we want, we found that
Dialogue: 0,1:22:43.56,1:22:45.92,Default,,0,0,0,,nested applications\N seems to be a sweet spot.
Dialogue: 0,1:22:45.92,1:22:47.80,Default,,0,0,0,,So you really gain\N a lot of information
Dialogue: 0,1:22:47.80,1:22:51.04,Default,,0,0,0,,by looking at nested applications\N and for the rest
Dialogue: 0,1:22:51.04,1:22:54.40,Default,,0,0,0,,of the cases you,\N well, you often get
Dialogue: 0,1:22:54.40,1:22:57.00,Default,,0,0,0,,information pushed\N by bidirectional
Dialogue: 0,1:22:57.00,1:22:59.88,Default,,0,0,0,,typing mechanisms.\N So this is the sweet spot.
Dialogue: 0,1:22:59.88,1:23:03.32,Default,,0,0,0,,So it will say,\N so our goal actually
Dialogue: 0,1:23:03.32,1:23:05.52,Default,,0,0,0,,has always been\N to have a predictable
Dialogue: 0,1:23:05.52,1:23:08.96,Default,,0,0,0,,inference for which\N I mean a simple mental
Dialogue: 0,1:23:08.96,1:23:10.76,Default,,0,0,0,,model that the\N developer can have.
Dialogue: 0,1:23:10.76,1:23:13.48,Default,,0,0,0,,One thing will succeed.\N And also when things
Dialogue: 0,1:23:13.48,1:23:16.36,Default,,0,0,0,,break where the annotations\N should be placed,
Dialogue: 0,1:23:17.00,1:23:19.48,Default,,0,0,0,,we also want obvious\N programs to be typable
Dialogue: 0,1:23:19.48,1:23:22.92,Default,,0,0,0,,without annotations.\N And of course, what obvious are,
Dialogue: 0,1:23:22.92,1:23:25.80,Default,,0,0,0,,is objective in the paper.\N We have a big list of examples,
Dialogue: 0,1:23:25.80,1:23:27.56,Default,,0,0,0,,would we need,\N should we think
Dialogue: 0,1:23:27.56,1:23:29.84,Default,,0,0,0,,we should be typable\N without annotations.
Dialogue: 0,1:23:29.84,1:23:31.84,Default,,0,0,0,,And many of the examples\N I've shown here
Dialogue: 0,1:23:31.84,1:23:33.72,Default,,0,0,0,,are also typable\N without annotations
Dialogue: 0,1:23:33.72,1:23:37.28,Default,,0,0,0,,so we really want to push\N for getting as much
Dialogue: 0,1:23:37.28,1:23:39.76,Default,,0,0,0,,impredicativity\N information as we can,
Dialogue: 0,1:23:39.76,1:23:44.24,Default,,0,0,0,,so that developers don't have\N to annotate all the time.
Dialogue: 0,1:23:45.08,1:23:48.00,Default,,0,0,0,,The other goal we have\N is to be a conservative extension
Dialogue: 0,1:23:48.00,1:23:51.16,Default,,0,0,0,,of existing features.\N So we want this thing
Dialogue: 0,1:23:51.16,1:23:52.64,Default,,0,0,0,,to be compatible\N with type classes,
Dialogue: 0,1:23:52.64,1:23:55.68,Default,,0,0,0,,type families, everything\N which is already in GHC
Dialogue: 0,1:23:55.68,1:23:58.68,Default,,0,0,0,,and also to be localized\N in specification and
Dialogue: 0,1:23:58.68,1:24:01.04,Default,,0,0,0,,implementation.\N Because as I was saying,
Dialogue: 0,1:24:01.04,1:24:04.00,Default,,0,0,0,,we want to implement\N this in GHC without
Dialogue: 0,1:24:04.00,1:24:08.92,Default,,0,0,0,,massive changes.\N So let me talk a bit more
Dialogue: 0,1:24:08.92,1:24:11.72,Default,,0,0,0,,about the fact that\N Quick Look is very localized.
Dialogue: 0,1:24:11.72,1:24:14.80,Default,,0,0,0,,And as I said,\N this only affects instantiation.
Dialogue: 0,1:24:14.80,1:24:18.24,Default,,0,0,0,,The rest of the type\N check-in has no changes.
Dialogue: 0,1:24:18.24,1:24:20.64,Default,,0,0,0,,So we've integrated\N this into GHC,
Dialogue: 0,1:24:20.64,1:24:23.52,Default,,0,0,0,,which has type classes,\N type families, data type promotion,
Dialogue: 0,1:24:23.52,1:24:25.64,Default,,0,0,0,,levity polymorphism,\N you name it.
Dialogue: 0,1:24:25.64,1:24:27.84,Default,,0,0,0,,And we were able\N to implement this
Dialogue: 0,1:24:27.84,1:24:29.72,Default,,0,0,0,,and there is a merge request\N for doing so.
Dialogue: 0,1:24:29.72,1:24:34.16,Default,,0,0,0,,And we only had to add\N 450 lines out of roughly
Dialogue: 0,1:24:34.16,1:24:37.84,Default,,0,0,0,,90,000 lines which make up\N the type checker in GHC.
Dialogue: 0,1:24:37.84,1:24:40.16,Default,,0,0,0,,So I think we succeeded\N in making thing,
Dialogue: 0,1:24:40.16,1:24:43.56,Default,,0,0,0,,really localized.\N Of course, I encourage
Dialogue: 0,1:24:43.56,1:24:45.76,Default,,0,0,0,,you to read the paper.\N There is more there
Dialogue: 0,1:24:45.76,1:24:48.96,Default,,0,0,0,,you have the full formalization.\N And actually we think
Dialogue: 0,1:24:48.96,1:24:50.60,Default,,0,0,0,,it's the first time\N that bidirectional
Dialogue: 0,1:24:50.60,1:24:53.52,Default,,0,0,0,,type inference and constraint\N have been written
Dialogue: 0,1:24:53.52,1:24:57.76,Default,,0,0,0,,down in a paper.\N This is what was inside GHC,
Dialogue: 0,1:24:57.76,1:25:01.96,Default,,0,0,0,,but there was no nothing written\N about how you integrate
Dialogue: 0,1:25:01.96,1:25:04.16,Default,,0,0,0,,all of this together.\N And on top of that,
Dialogue: 0,1:25:04.16,1:25:06.88,Default,,0,0,0,,we built Quick Look\N impredicativity.
Dialogue: 0,1:25:06.88,1:25:08.76,Default,,0,0,0,,Of course we have,\N we talk about
Dialogue: 0,1:25:08.76,1:25:13.16,Default,,0,0,0,,metatheoretical properties.\N Also we talk about
Dialogue: 0,1:25:13.16,1:25:16.64,Default,,0,0,0,,how we integrate quick look\N with visible type application.
Dialogue: 0,1:25:16.64,1:25:21.20,Default,,0,0,0,,And the reason is that when,\N when Quick Look fails,
Dialogue: 0,1:25:21.20,1:25:23.96,Default,,0,0,0,,the easiest way to override\N this is a way to tell
Dialogue: 0,1:25:23.96,1:25:26.04,Default,,0,0,0,,the compiler\N what this instantiation
Dialogue: 0,1:25:26.04,1:25:28.20,Default,,0,0,0,,should be is to use\N visible type application.
Dialogue: 0,1:25:28.20,1:25:29.60,Default,,0,0,0,,So we think it's really\N important that does
Dialogue: 0,1:25:29.60,1:25:31.60,Default,,0,0,0,,these two things\N play together.
Dialogue: 0,1:25:31.60,1:25:34.92,Default,,0,0,0,,Well, we also talk\N a bit about how qualified type
Dialogue: 0,1:25:34.92,1:25:37.44,Default,,0,0,0,,and GADTs is integrated\N with Quick Look
Dialogue: 0,1:25:37.44,1:25:40.00,Default,,0,0,0,,and also lots of related work,\N because as I've shown
Dialogue: 0,1:25:40.00,1:25:41.76,Default,,0,0,0,,at the beginning,\N a lot of people
Dialogue: 0,1:25:41.76,1:25:43.80,Default,,0,0,0,,have been struggling\N with this problem
Dialogue: 0,1:25:43.80,1:25:47.08,Default,,0,0,0,,and trying to solve it\N for a long time.
Dialogue: 0,1:25:47.08,1:25:49.08,Default,,0,0,0,,In summary, quick look\N impredicativity
Dialogue: 0,1:25:49.08,1:25:51.96,Default,,0,0,0,,is a simple approach\N to impredicative inference
Dialogue: 0,1:25:51.96,1:25:54.88,Default,,0,0,0,,which tries to be predictable,\N but yet type
Dialogue: 0,1:25:54.88,1:25:57.96,Default,,0,0,0,,as many obvious program\N as possible without annotation.
Dialogue: 0,1:25:57.96,1:26:00.20,Default,,0,0,0,,And it's also\N a conservative extension
Dialogue: 0,1:26:00.20,1:26:02.72,Default,,0,0,0,,to what it's already there\N and very localized
Dialogue: 0,1:26:02.72,1:26:05.64,Default,,0,0,0,,in the specification\N and implementation.
Dialogue: 0,1:26:05.64,1:26:07.96,Default,,0,0,0,,That's what the whole,\N I love to hear you
Dialogue: 0,1:26:07.96,1:26:11.40,Default,,0,0,0,,any new ideas,\N any questions in the,
Dialogue: 0,1:26:11.40,1:26:15.76,Default,,0,0,0,,in the ICFP channel for this,\N and thanks for watching
Dialogue: 0,1:26:17.20,1:26:24.04,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:26:24.04,1:26:26.16,Default,,0,0,0,,
Dialogue: 0,1:26:26.16,1:26:28.64,Default,,0,0,0,,STEPHANIE: Thank you Alejandro.\N If you are watching
Dialogue: 0,1:26:28.64,1:26:31.16,Default,,0,0,0,,this talk live,\N please don't forget
Dialogue: 0,1:26:31.16,1:26:34.20,Default,,0,0,0,,about the Q & A session\N that may be available
Dialogue: 0,1:26:34.20,1:26:38.60,Default,,0,0,0,,in your time now.\N We will now pause here
Dialogue: 0,1:26:38.60,1:26:41.76,Default,,0,0,0,,to sync up with\N the talk schedule.
Dialogue: 0,1:28:02.12,1:28:04.72,Default,,0,0,0,,Our next talk presents\N a general mechanism
Dialogue: 0,1:28:04.72,1:28:07.88,Default,,0,0,0,,and type system design\N inspired by modal logic.
Dialogue: 0,1:28:08.48,1:28:10.68,Default,,0,0,0,,This work is called\N 'A unified view
Dialogue: 0,1:28:10.68,1:28:12.72,Default,,0,0,0,,of modalities\N in type systems',
Dialogue: 0,1:28:12.72,1:28:15.16,Default,,0,0,0,,and it is a paper\N by Andreas Abel
Dialogue: 0,1:28:15.16,1:28:19.04,Default,,0,0,0,,and Jean-Phillipe Bernardy,\N both from Gothenburg.
Dialogue: 0,1:28:19.04,1:28:22.92,Default,,0,0,0,,Jean-Phillipe Bernardy\N will be giving the talk.
Dialogue: 0,1:28:22.92,1:28:24.04,Default,,0,0,0,,JEAN-PHILLIPE BERNARDY: Hello\N and welcome to
Dialogue: 0,1:28:24.04,1:28:27.12,Default,,0,0,0,,A unified view of Modalities\N in type systems.
Dialogue: 0,1:28:27.12,1:28:29.76,Default,,0,0,0,,My name is Jean-Phillipe Bernardy\N and this is joint work
Dialogue: 0,1:28:29.76,1:28:32.68,Default,,0,0,0,,with Andreas Abel.
Dialogue: 0,1:28:32.68,1:28:36.24,Default,,0,0,0,,Modalities are qualifiers,\N that modify types or propositions.
Dialogue: 0,1:28:36.24,1:28:39.08,Default,,0,0,0,,For example, in the sentence,\N it may rain today.
Dialogue: 0,1:28:39.08,1:28:41.24,Default,,0,0,0,,The rain today\N proposition is qualified
Dialogue: 0,1:28:41.24,1:28:43.36,Default,,0,0,0,,with the possibility modality.
Dialogue: 0,1:28:43.36,1:28:46.52,Default,,0,0,0,,Another possible example\N is the qualification of propositions
Dialogue: 0,1:28:46.52,1:28:49.88,Default,,0,0,0,,by the agent who believe it\N as in John thinks
Dialogue: 0,1:28:49.88,1:28:53.72,Default,,0,0,0,,that it rains today\N in programming languages,
Dialogue: 0,1:28:53.72,1:28:55.32,Default,,0,0,0,,it can be useful\N to qualify your type,
Dialogue: 0,1:28:55.32,1:28:58.48,Default,,0,0,0,,but in amount in presenting,\N how much is available.
Dialogue: 0,1:28:58.48,1:29:03.52,Default,,0,0,0,,For example 5.543mm of rain.
Dialogue: 0,1:29:03.52,1:29:06.76,Default,,0,0,0,,Another useful kind of qualifier\N is whether information
Dialogue: 0,1:29:06.76,1:29:09.84,Default,,0,0,0,,is public or secret\N in this work.
Dialogue: 0,1:29:09.84,1:29:12.04,Default,,0,0,0,,I will go this to describe\N the system which unifies
Dialogue: 0,1:29:12.04,1:29:15.00,Default,,0,0,0,,all such instances\N of modalities.
Dialogue: 0,1:29:15.00,1:29:18.20,Default,,0,0,0,,We also want the system\N to have a useful meta theory,
Dialogue: 0,1:29:18.20,1:29:21.00,Default,,0,0,0,,which all instances\N can inherit.
Dialogue: 0,1:29:21.00,1:29:22.80,Default,,0,0,0,,Our work is set\N in the framework
Dialogue: 0,1:29:22.80,1:29:25.40,Default,,0,0,0,,of the system F\N also known as
Dialogue: 0,1:29:25.40,1:29:29.48,Default,,0,0,0,,the Polymorphic Lambda Calculus.\N I am going to assume
Dialogue: 0,1:29:29.48,1:29:32.44,Default,,0,0,0,,familiarity with it.\N Also, I assume
Dialogue: 0,1:29:32.44,1:29:34.56,Default,,0,0,0,,you know that\N they are isomorphic.
Dialogue: 0,1:29:34.56,1:29:37.32,Default,,0,0,0,,If you watch the video offline,\N feel free to pause,
Dialogue: 0,1:29:37.32,1:29:39.28,Default,,0,0,0,,and we decide\N that you won't face,
Dialogue: 0,1:29:39.28,1:29:43.40,Default,,0,0,0,,or we can consult the paper\N and come back later here,
Dialogue: 0,1:29:43.40,1:29:44.76,Default,,0,0,0,,as suggested\N by the examples
Dialogue: 0,1:29:44.76,1:29:47.40,Default,,0,0,0,,that I've shown above.\N We add a new type form
Dialogue: 0,1:29:47.40,1:29:52.40,Default,,0,0,0,,of P<A>, which I will just read\N out PA in the future.
Dialogue: 0,1:29:52.96,1:29:56.76,Default,,0,0,0,,This means A\N qualifying by modality P.
Dialogue: 0,1:29:57.72,1:30:00.04,Default,,0,0,0,,To support modal types.\N The key idea is to
Dialogue: 0,1:30:00.04,1:30:03.96,Default,,0,0,0,,annotate every type variable\N or every variable
Dialogue: 0,1:30:03.96,1:30:08.36,Default,,0,0,0,,with a modality\N in addition to its type. Again.
Dialogue: 0,1:30:08.36,1:30:10.72,Default,,0,0,0,,To support modal types\N the key idea is to annotate
Dialogue: 0,1:30:10.72,1:30:12.44,Default,,0,0,0,,every variable\N with the modality
Dialogue: 0,1:30:12.44,1:30:15.32,Default,,0,0,0,,in addition to its type.\N Formally what we do
Dialogue: 0,1:30:15.32,1:30:17.28,Default,,0,0,0,,is to change the judgment.\N So that includes
Dialogue: 0,1:30:17.28,1:30:20.72,Default,,0,0,0,,this little gamma here.\N It is a map
Dialogue: 0,1:30:20.72,1:30:23.40,Default,,0,0,0,,from variable names to modalities\N and important thing
Dialogue: 0,1:30:23.40,1:30:24.84,Default,,0,0,0,,to note is that\N the reason we have
Dialogue: 0,1:30:24.84,1:30:27.92,Default,,0,0,0,,type A in the judgment\N has a unit in gamma.
Dialogue: 0,1:30:27.92,1:30:30.36,Default,,0,0,0,,This unit modality\N will be interpreted differently
Dialogue: 0,1:30:30.36,1:30:33.08,Default,,0,0,0,,depending on the application.\N But I can only say that
Dialogue: 0,1:30:33.08,1:30:39.80,Default,,0,0,0,,it acts as a default\N to produce a modality, say P(A),
Dialogue: 0,1:30:39.80,1:30:42.68,Default,,0,0,0,,here we need to multiply\N the modality context by P
Dialogue: 0,1:30:42.68,1:30:47.00,Default,,0,0,0,,that is we multiply every modality\N in the context by P.
Dialogue: 0,1:30:47.00,1:30:49.64,Default,,0,0,0,,In the same vein.\N If we want the product
Dialogue: 0,1:30:49.64,1:30:52.72,Default,,0,0,0,,of A and B, then we\N build the sum of their
Dialogue: 0,1:30:52.72,1:30:57.40,Default,,0,0,0,,respective modality contexts.\N To see how this plays out
Dialogue: 0,1:30:57.40,1:31:00.32,Default,,0,0,0,,let us first look\N at the fragment of system F,
Dialogue: 0,1:31:00.32,1:31:03.24,Default,,0,0,0,,without modalities.\N Then we can see
Dialogue: 0,1:31:03.24,1:31:06.00,Default,,0,0,0,,how modality annotations\N get added.
Dialogue: 0,1:31:06.00,1:31:07.68,Default,,0,0,0,,Let's look first\N at the variable
Dialogue: 0,1:31:07.68,1:31:10.76,Default,,0,0,0,,rule, what it says\N is that a is used exactly once.
Dialogue: 0,1:31:10.76,1:31:13.72,Default,,0,0,0,,And so A is annotated\N with a unit modality
Dialogue: 0,1:31:13.72,1:31:16.84,Default,,0,0,0,,in the context also\N that the rest of the context
Dialogue: 0,1:31:16.84,1:31:20.20,Default,,0,0,0,,is not used at all.\N And so it is annotated
Dialogue: 0,1:31:20.20,1:31:24.24,Default,,0,0,0,,with the zero modality\N for consistency,
Dialogue: 0,1:31:24.24,1:31:27.00,Default,,0,0,0,,We also annotate domain\N of the arrow type
Dialogue: 0,1:31:27.00,1:31:29.56,Default,,0,0,0,,with the modality.\N You can see how this
Dialogue: 0,1:31:29.56,1:31:33.48,Default,,0,0,0,,plays out in the ABS\N and APP rules
Dialogue: 0,1:31:33.48,1:31:39.72,Default,,0,0,0,,abstraction applications.\N In particular, in the application rule
Dialogue: 0,1:31:39.72,1:31:42.08,Default,,0,0,0,,to be able to fit qA\N to the function.
Dialogue: 0,1:31:42.08,1:31:45.00,Default,,0,0,0,,We need q times delta.
Dialogue: 0,1:31:45.00,1:31:47.16,Default,,0,0,0,,In passing we know quickly\N that the application
Dialogue: 0,1:31:47.16,1:31:50.20,Default,,0,0,0,,does nothing useful\N with the modality context.
Dialogue: 0,1:31:51.44,1:31:52.96,Default,,0,0,0,,Let's now look\N at the introduction
Dialogue: 0,1:31:52.96,1:31:56.16,Default,,0,0,0,,and elimination rules\N for qualified types.
Dialogue: 0,1:31:57.20,1:31:59.76,Default,,0,0,0,,Introduction rule works\N as we said before,
Dialogue: 0,1:31:59.76,1:32:03.04,Default,,0,0,0,,namely, we multiplied\N the context by P.
Dialogue: 0,1:32:03.04,1:32:05.60,Default,,0,0,0,,Elimination rule\N is a bit more involved.
Dialogue: 0,1:32:05.60,1:32:08.24,Default,,0,0,0,,Note first that we assume\N that little gamma
Dialogue: 0,1:32:08.24,1:32:11.28,Default,,0,0,0,,produces P(A).\N Now we want to use this A
Dialogue: 0,1:32:11.28,1:32:14.16,Default,,0,0,0,,to put to produce\N C in continuation.
Dialogue: 0,1:32:14.16,1:32:16.56,Default,,0,0,0,,We could think that\N we'd have PA
Dialogue: 0,1:32:16.56,1:32:18.56,Default,,0,0,0,,in the context\N of the continuation,
Dialogue: 0,1:32:18.56,1:32:22.40,Default,,0,0,0,,but instead we are allowed\N to multiply by the annotation of an arbitrary Q.
Dialogue: 0,1:32:22.40,1:32:26.64,Default,,0,0,0,,This is because\N to produce 1C,
Dialogue: 0,1:32:26.64,1:32:29.16,Default,,0,0,0,,unit C,\N we may need another modality.
Dialogue: 0,1:32:29.16,1:32:32.52,Default,,0,0,0,,Exactly P for A,\N and thus this version
Dialogue: 0,1:32:32.52,1:32:35.16,Default,,0,0,0,,gives more flexibility\N to the programmer.
Dialogue: 0,1:32:35.16,1:32:39.56,Default,,0,0,0,,On top of this, we also have\N an order of modalities
Dialogue: 0,1:32:39.56,1:32:44.72,Default,,0,0,0,,and it is generated\N by this lattice.
Dialogue: 0,1:32:44.72,1:32:47.04,Default,,0,0,0,,This order drives\N the weakening rule
Dialogue: 0,1:32:47.04,1:32:50.60,Default,,0,0,0,,as shown here.\N We can also see the converse,
Dialogue: 0,1:32:50.60,1:32:55.12,Default,,0,0,0,,and, this is\N a conversion rule from P to Q.
Dialogue: 0,1:32:55.12,1:32:58.72,Default,,0,0,0,,If P is less than Q.\N The exact structure
Dialogue: 0,1:32:58.72,1:33:01.60,Default,,0,0,0,,of modalities is\N as shown here.
Dialogue: 0,1:33:01.60,1:33:05.80,Default,,0,0,0,,Pause the video, or you can\N check out the paper.
Dialogue: 0,1:33:05.80,1:33:08.08,Default,,0,0,0,,But the interesting bit\N is the last line,
Dialogue: 0,1:33:08.08,1:33:10.32,Default,,0,0,0,,namely, that addition\N distribute over meet,
Dialogue: 0,1:33:10.32,1:33:13.92,Default,,0,0,0,,This property also implies\N addition is monotonous.
Dialogue: 0,1:33:15.00,1:33:17.04,Default,,0,0,0,,We can instantiate\N the structure to various
Dialogue: 0,1:33:17.04,1:33:20.12,Default,,0,0,0,,various special cases\N and obtain several
Dialogue: 0,1:33:20.12,1:33:23.28,Default,,0,0,0,,useful systems in this way.\N First, we can do
Dialogue: 0,1:33:23.28,1:33:25.64,Default,,0,0,0,,zero and one,
Dialogue: 0,1:33:25.64,1:33:28.44,Default,,0,0,0,,as you'd expect,\N we just need to add
Dialogue: 0,1:33:28.44,1:33:33.60,Default,,0,0,0,,the modality Omega to support\N unrestricted usage
Dialogue: 0,1:33:33.60,1:33:37.24,Default,,0,0,0,,That's the bang\N modality in linear (INAUDIBLE) .
Dialogue: 0,1:33:37.84,1:33:40.64,Default,,0,0,0,,The rest of the structure\N is at you expect.
Dialogue: 0,1:33:40.64,1:33:44.08,Default,,0,0,0,,And Omega is acting\N as a catch-all value.
Dialogue: 0,1:33:44.08,1:33:47.52,Default,,0,0,0,,A useful generalization\N of linear types is the system
Dialogue: 0,1:33:47.52,1:33:49.56,Default,,0,0,0,,which tracks\N the exact number of times
Dialogue: 0,1:33:49.56,1:33:52.44,Default,,0,0,0,,that a variable is used.\N However, one must
Dialogue: 0,1:33:52.44,1:33:55.04,Default,,0,0,0,,allow for sets\N of possible usages.
Dialogue: 0,1:33:55.04,1:33:58.12,Default,,0,0,0,,We implemented meet, et cetera.\N The rest of the structure
Dialogue: 0,1:33:58.12,1:34:02.12,Default,,0,0,0,,falls out from this choice.\N An interesting property
Dialogue: 0,1:34:02.12,1:34:05.16,Default,,0,0,0,,of all such models,\N Modal systems
Dialogue: 0,1:34:05.16,1:34:10.12,Default,,0,0,0,,is that zero annotated parameter\N is guaranteed not to be used
Dialogue: 0,1:34:10.12,1:34:12.52,Default,,0,0,0,,this is capture by\N the irrelevance theorem,
Dialogue: 0,1:34:12.52,1:34:14.36,Default,,0,0,0,,which is stated\N as shown here
Dialogue: 0,1:34:14.36,1:34:19.92,Default,,0,0,0,,and proven in the paper,\N the lattice, which as you'll recall,
Dialogue: 0,1:34:19.92,1:34:22.92,Default,,0,0,0,,corresponds to the order\N of modalities can be used
Dialogue: 0,1:34:22.92,1:34:26.48,Default,,0,0,0,,for various purposes.\N It can be used
Dialogue: 0,1:34:26.48,1:34:30.32,Default,,0,0,0,,for security purposes,\N with more secret levels
Dialogue: 0,1:34:30.32,1:34:32.88,Default,,0,0,0,,towards the top.\N It can be used to represent
Dialogue: 0,1:34:32.88,1:34:35.08,Default,,0,0,0,,the necessity modalities\N with more necessary
Dialogue: 0,1:34:35.08,1:34:37.20,Default,,0,0,0,,propositions towards\N the bottom.
Dialogue: 0,1:34:37.20,1:34:39.76,Default,,0,0,0,,It can represent\N levels of beliefs.
Dialogue: 0,1:34:39.76,1:34:42.96,Default,,0,0,0,,More credulous agents\N are at the top.
Dialogue: 0,1:34:43.64,1:34:46.16,Default,,0,0,0,,We can represent\N computational relevance
Dialogue: 0,1:34:46.16,1:34:49.56,Default,,0,0,0,,with more relevant types\N toward the bottom.
Dialogue: 0,1:34:50.44,1:34:53.60,Default,,0,0,0,,Remember that convertibility\N is from bottom to top.
Dialogue: 0,1:34:53.60,1:34:57.16,Default,,0,0,0,,And so at the meet of P and Q\N all data which is available
Dialogue: 0,1:34:57.16,1:35:01.60,Default,,0,0,0,,for either P or Q is\N also available there.
Dialogue: 0,1:35:03.52,1:35:05.20,Default,,0,0,0,,We can now take\N a moment to ponder
Dialogue: 0,1:35:05.20,1:35:08.28,Default,,0,0,0,,what happens when one\N does not care about quantities.
Dialogue: 0,1:35:08.28,1:35:10.40,Default,,0,0,0,,And so modalities\N are only used to
Dialogue: 0,1:35:10.40,1:35:13.96,Default,,0,0,0,,represent levels in areas\N such as shown previously
Dialogue: 0,1:35:13.96,1:35:15.56,Default,,0,0,0,,in this case,\N the meet becomes
Dialogue: 0,1:35:15.56,1:35:19.24,Default,,0,0,0,,the addition and the join\N becomes multiplication.
Dialogue: 0,1:35:19.24,1:35:23.12,Default,,0,0,0,,Additionally, zero\N is also the top of the lattice.
Dialogue: 0,1:35:23.12,1:35:25.96,Default,,0,0,0,,The consequence is that\N to produce zero A
Dialogue: 0,1:35:25.96,1:35:29.60,Default,,0,0,0,,or really top A,\N the modality context
Dialogue: 0,1:35:29.60,1:35:33.56,Default,,0,0,0,,can be ignored.\N And so we can use all variables,
Dialogue: 0,1:35:33.56,1:35:35.12,Default,,0,0,0,,even those\N that are available
Dialogue: 0,1:35:35.12,1:35:39.32,Default,,0,0,0,,with modality zero, in data.\N It has the application
Dialogue: 0,1:35:39.32,1:35:41.52,Default,,0,0,0,,where precise quantities\N are tracked,
Dialogue: 0,1:35:41.52,1:35:45.52,Default,,0,0,0,,in sensitivity analysis,\N which you can read
Dialogue: 0,1:35:45.52,1:35:48.28,Default,,0,0,0,,about in the paper.\N Let's now turn
Dialogue: 0,1:35:48.28,1:35:51.72,Default,,0,0,0,,to the metatheory.\N We consider our first
Dialogue: 0,1:35:51.72,1:35:53.92,Default,,0,0,0,,operational semantics,\N whose cornerstone
Dialogue: 0,1:35:53.92,1:35:56.60,Default,,0,0,0,,is the substitution Lemma,\N the proof follows
Dialogue: 0,1:35:56.60,1:35:59.56,Default,,0,0,0,,the issue of structure.\N We have additionally
Dialogue: 0,1:35:59.56,1:36:03.60,Default,,0,0,0,,to express how modalities\N are transformed by substitution.
Dialogue: 0,1:36:03.60,1:36:06.36,Default,,0,0,0,,It turns out that the modality\N transformation applied by
Dialogue: 0,1:36:06.36,1:36:11.56,Default,,0,0,0,,your substitution here, Sigma\N is a linear operator, here.
Dialogue: 0,1:36:11.56,1:36:13.96,Default,,0,0,0,,So, the proof\N is straightforward,
Dialogue: 0,1:36:13.96,1:36:16.28,Default,,0,0,0,,but it is interesting\N to note that the requirements,
Dialogue: 0,1:36:16.28,1:36:18.84,Default,,0,0,0,,this is a well-formed modality\N is correspond exactly
Dialogue: 0,1:36:18.84,1:36:23.08,Default,,0,0,0,,to the modality structure,\N which we have shown previously.
Dialogue: 0,1:36:23.08,1:36:26.40,Default,,0,0,0,,We also have a modality\N preserving abstract machine.
Dialogue: 0,1:36:26.40,1:36:27.80,Default,,0,0,0,,This is a call by name machine
Dialogue: 0,1:36:27.80,1:36:31.36,Default,,0,0,0,,where every state is well typed\N and well-qualified.
Dialogue: 0,1:36:31.36,1:36:33.08,Default,,0,0,0,,The main point\N of showing this machine
Dialogue: 0,1:36:33.08,1:36:35.64,Default,,0,0,0,,is to show that\N dynamic execution steps
Dialogue: 0,1:36:35.64,1:36:38.16,Default,,0,0,0,,will never over-consume\N under consume,
Dialogue: 0,1:36:38.16,1:36:42.00,Default,,0,0,0,,see private information,\N et cetera.
Dialogue: 0,1:36:42.68,1:36:45.72,Default,,0,0,0,,So the modalities annotations\N can be realized
Dialogue: 0,1:36:45.72,1:36:47.84,Default,,0,0,0,,at run time time as such.
Dialogue: 0,1:36:49.04,1:36:51.84,Default,,0,0,0,,Finally, we have\N a relation now
Dialogue: 0,1:36:51.84,1:36:56.80,Default,,0,0,0,,Kripke case style semantics.\N We interpret types by relations
Dialogue: 0,1:36:56.80,1:37:00.00,Default,,0,0,0,,and these relations\N are indexed by worlds.
Dialogue: 0,1:37:00.00,1:37:02.84,Default,,0,0,0,,The main novelty here\N is that we can interpret
Dialogue: 0,1:37:02.84,1:37:05.36,Default,,0,0,0,,the PA type by\N a notion of division
Dialogue: 0,1:37:05.36,1:37:08.96,Default,,0,0,0,,or more precisely\N a galois connection.
Dialogue: 0,1:37:10.48,1:37:12.32,Default,,0,0,0,,For quantitative systems
Dialogue: 0,1:37:12.32,1:37:15.56,Default,,0,0,0,,w is a multiset\N of resources to consume.
Dialogue: 0,1:37:15.56,1:37:18.56,Default,,0,0,0,,P is then interpreted\N as a natural number
Dialogue: 0,1:37:18.56,1:37:24.12,Default,,0,0,0,,and to interpret P(A) at a world w,
Dialogue: 0,1:37:24.12,1:37:28.72,Default,,0,0,0,,we interpret A\N at a world w divided by P.
Dialogue: 0,1:37:28.72,1:37:30.72,Default,,0,0,0,,For non quantitative systems,
Dialogue: 0,1:37:30.72,1:37:35.48,Default,,0,0,0,,w is a set of capabilities.\N Types are indistinguishable
Dialogue: 0,1:37:35.48,1:37:39.64,Default,,0,0,0,,if the associated capability\N is not in w.
Dialogue: 0,1:37:39.64,1:37:41.60,Default,,0,0,0,,We can take\N advantage of the fact
Dialogue: 0,1:37:41.60,1:37:44.92,Default,,0,0,0,,that every modality\N can be represented
Dialogue: 0,1:37:44.92,1:37:47.00,Default,,0,0,0,,by a set of capabilities.
Dialogue: 0,1:37:47.00,1:37:50.92,Default,,0,0,0,,So to interpret P(A) at w\N we interpret A at the world,
Dialogue: 0,1:37:50.92,1:37:54.84,Default,,0,0,0,,which is the difference\N of the sets w and P
Dialogue: 0,1:37:56.00,1:37:58.80,Default,,0,0,0,,combining the two views\N is somewhat curious,
Dialogue: 0,1:37:58.80,1:38:03.52,Default,,0,0,0,,but it is shown in the paper.\N A perhaps controversial choice
Dialogue: 0,1:38:03.52,1:38:07.56,Default,,0,0,0,,is that we have a constraint\N on which modalities...
Dialogue: 0,1:38:10.60,1:38:12.48,Default,,0,0,0,,can take to be scrutinized
Dialogue: 0,1:38:12.48,1:38:16.24,Default,,0,0,0,,by a case expression.\N We demand that they must
Dialogue: 0,1:38:16.24,1:38:19.32,Default,,0,0,0,,be convertible\N to the unit modality.
Dialogue: 0,1:38:19.32,1:38:22.52,Default,,0,0,0,,This constraint is\N necessary for irrelevance.
Dialogue: 0,1:38:22.52,1:38:25.60,Default,,0,0,0,,Otherwise we will be able to see\N if we are on the left
Dialogue: 0,1:38:25.60,1:38:27.76,Default,,0,0,0,,or on the right\N of the sum
Dialogue: 0,1:38:27.76,1:38:31.84,Default,,0,0,0,,for every modality, and then\N everything becomes observable
Dialogue: 0,1:38:31.84,1:38:35.16,Default,,0,0,0,,at every level,\N even zero,
Dialogue: 0,1:38:35.96,1:38:39.36,Default,,0,0,0,,but the operational semantics\N do not in fact rely...
Dialogue: 0,1:38:40.00,1:38:43.32,Default,,0,0,0,,this constraint, rely\N on this constraint.
Dialogue: 0,1:38:43.32,1:38:45.40,Default,,0,0,0,,And so there are other choices.
Dialogue: 0,1:38:46.64,1:38:49.72,Default,,0,0,0,,There is an extended discussion\N of this topic in the paper.
Dialogue: 0,1:38:51.48,1:38:55.68,Default,,0,0,0,,Additionally in the paper, we deal\N with the whole of system F of course
Dialogue: 0,1:38:55.68,1:38:56.88,Default,,0,0,0,,with sum and products.
Dialogue: 0,1:38:57.36,1:39:00.24,Default,,0,0,0,,And we have quantification\N over modalities
Dialogue: 0,1:39:00.24,1:39:04.12,Default,,0,0,0,,which means that we have\N higher-order modal types.
Dialogue: 0,1:39:04.88,1:39:07.56,Default,,0,0,0,,We also show more applications\N of free theorems.
Dialogue: 0,1:39:07.56,1:39:10.08,Default,,0,0,0,,And we also give\N a wealth of nice details.
Dialogue: 0,1:39:10.08,1:39:11.60,Default,,0,0,0,,So feel free to check these out.
Dialogue: 0,1:39:12.60,1:39:15.16,Default,,0,0,0,,In conclusion we\N declare victory because
Dialogue: 0,1:39:15.92,1:39:19.80,Default,,0,0,0,,many useful system can be\N captured by our framework.
Dialogue: 0,1:39:20.32,1:39:22.36,Default,,0,0,0,,And (INAUDIBLE) rich metatheory.
Dialogue: 0,1:39:23.36,1:39:25.80,Default,,0,0,0,,As usual, it can be useful\N to describe an application
Dialogue: 0,1:39:25.80,1:39:29.60,Default,,0,0,0,,which exhibits a non\N commutative multiplication
Dialogue: 0,1:39:30.84,1:39:34.12,Default,,0,0,0,,or (INAUDIBLE)
Dialogue: 0,1:39:35.88,1:39:39.32,Default,,0,0,0,,Another useful development would be\N to have a representation theorem
Dialogue: 0,1:39:39.32,1:39:40.84,Default,,0,0,0,,for the modality structure.
Dialogue: 0,1:39:42.32,1:39:43.32,Default,,0,0,0,,Thanks for watching.
Dialogue: 0,1:39:43.32,1:39:48.32,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:39:51.44,1:39:53.08,Default,,0,0,0,,STEPHANIE: Thank you Jean-Philippe.
Dialogue: 0,1:39:53.84,1:39:57.96,Default,,0,0,0,,At this point please make\N sure to join a Q&A session
Dialogue: 0,1:39:57.96,1:40:00.24,Default,,0,0,0,,if it is available in your time map.
Dialogue: 0,1:40:02.48,1:40:05.44,Default,,0,0,0,,We will now pause to sync up with\N the rest of the talk schedule.
Dialogue: 0,1:40:57.44,1:41:02.44,Default,,0,0,0,,(ROCK MUSIC PLAYING)
Dialogue: 0,1:42:42.80,1:42:44.48,Default,,0,0,0,,(MUSIC ENDS)
Dialogue: 0,1:43:00.24,1:43:04.52,Default,,0,0,0,,Our next talk discusses\N pattern matching
Dialogue: 0,1:43:04.52,1:43:07.00,Default,,0,0,0,,in the Glasgow Haskell compiler.
Dialogue: 0,1:43:07.92,1:43:11.88,Default,,0,0,0,,It is based on work by Sebastian\N Graf, Simon Peyton Jones
Dialogue: 0,1:43:11.88,1:43:12.88,Default,,0,0,0,,and Ryan Scott.
Dialogue: 0,1:43:13.36,1:43:15.72,Default,,0,0,0,,The talk will be\N presented by Sebastian.
Dialogue: 0,1:43:17.48,1:43:19.12,Default,,0,0,0,,SEBASTIAN GRAF: Hi, I'm Sebastian
Dialogue: 0,1:43:19.12,1:43:22.84,Default,,0,0,0,,and I'm here to talk to you about\N pattern-match coverage checking.
Dialogue: 0,1:43:23.36,1:43:25.84,Default,,0,0,0,,In case you are wondering how\N this problem hasn't been solved
Dialogue: 0,1:43:25.84,1:43:26.92,Default,,0,0,0,,like 40 years ago,
Dialogue: 0,1:43:26.92,1:43:29.92,Default,,0,0,0,,well lower your guard\N and hold back on your judgment
Dialogue: 0,1:43:29.92,1:43:31.20,Default,,0,0,0,,just for a few more minutes.
Dialogue: 0,1:43:32.96,1:43:36.08,Default,,0,0,0,,Let's start with a quick recap\N about pattern-match warnings.
Dialogue: 0,1:43:36.80,1:43:39.52,Default,,0,0,0,,This incomplete definition\N of isJust in Haskell here
Dialogue: 0,1:43:40.24,1:43:42.04,Default,,0,0,0,,will crash when called with Nothing
Dialogue: 0,1:43:43.04,1:43:44.88,Default,,0,0,0,,because it lacks a covering clause.
Dialogue: 0,1:43:45.64,1:43:47.64,Default,,0,0,0,,Now, runtime crushes are
Dialogue: 0,1:43:47.64,1:43:49.84,Default,,0,0,0,,annoying, especially for such\N an obvious oversight.
Dialogue: 0,1:43:50.32,1:43:53.92,Default,,0,0,0,,So the compiler should and\N indeed, in the case of GHC,
Dialogue: 0,1:43:53.92,1:43:55.32,Default,,0,0,0,,it does warn about it.
Dialogue: 0,1:43:56.32,1:43:59.52,Default,,0,0,0,,I'll talk about how GHC\N figures out these missing cases.
Dialogue: 0,1:44:01.00,1:44:04.72,Default,,0,0,0,,Apart from such missing\N equations like Nothing here,
Dialogue: 0,1:44:05.20,1:44:07.24,Default,,0,0,0,,compilers can also find\N redundant equations
Dialogue: 0,1:44:07.24,1:44:08.60,Default,,0,0,0,,like the third one here.
Dialogue: 0,1:44:09.36,1:44:11.52,Default,,0,0,0,,In fact compilers have\N been able to produce
Dialogue: 0,1:44:11.52,1:44:13.28,Default,,0,0,0,,these kinds of warnings\N for a long time.
Dialogue: 0,1:44:14.00,1:44:16.24,Default,,0,0,0,,So you might think there is\N nothing new to find here.
Dialogue: 0,1:44:17.72,1:44:20.80,Default,,0,0,0,,And I thought so too before\N I picked up maintenance
Dialogue: 0,1:44:20.80,1:44:25.04,Default,,0,0,0,,of GHC's pattern-match checker as\N a side project about a year ago.
Dialogue: 0,1:44:26.56,1:44:29.20,Default,,0,0,0,,As of recently there are\N over 28 open tickets
Dialogue: 0,1:44:29.20,1:44:30.68,Default,,0,0,0,,for the pattern-match checker,
Dialogue: 0,1:44:30.68,1:44:33.76,Default,,0,0,0,,most of them related to\N performance and incorrect handling
Dialogue: 0,1:44:33.76,1:44:37.24,Default,,0,0,0,,of some subtle interaction\N of source syntax features.
Dialogue: 0,1:44:39.72,1:44:43.48,Default,,0,0,0,,So how exactly can something\N that looks so simple
Dialogue: 0,1:44:43.48,1:44:44.88,Default,,0,0,0,,give us so many headaches?
Dialogue: 0,1:44:46.88,1:44:49.32,Default,,0,0,0,,Let's start with a little\N warm-up exercise.
Dialogue: 0,1:44:50.04,1:44:51.48,Default,,0,0,0,,Is this function exhaustive?
Dialogue: 0,1:44:52.20,1:44:54.36,Default,,0,0,0,,Well that's a pretty\N suggestive question
Dialogue: 0,1:44:54.36,1:44:56.20,Default,,0,0,0,,and since this isn't a live talk,
Dialogue: 0,1:44:56.92,1:44:58.00,Default,,0,0,0,,I won't be waiting for you.
Dialogue: 0,1:44:58.48,1:45:01.16,Default,,0,0,0,,The answer is no and these are\N values that it failed to cover.
Dialogue: 0,1:45:02.40,1:45:04.36,Default,,0,0,0,,There are only four pattern matches
Dialogue: 0,1:45:04.36,1:45:07.88,Default,,0,0,0,,but 16 different combinations\N of arguments to consider.
Dialogue: 0,1:45:08.88,1:45:12.52,Default,,0,0,0,,Clearly a scalable, automated\N checker needs to know when
Dialogue: 0,1:45:12.52,1:45:15.64,Default,,0,0,0,,and how to bail out of this\N exponential behavior.
Dialogue: 0,1:45:17.64,1:45:21.08,Default,,0,0,0,,Now, Haskell is\N lazy but not total.
Dialogue: 0,1:45:21.08,1:45:23.40,Default,,0,0,0,,That also reflects in its\N pattern-matching semantics.
Dialogue: 0,1:45:24.16,1:45:26.32,Default,,0,0,0,,Take this function\N here as an example.
Dialogue: 0,1:45:27.60,1:45:30.80,Default,,0,0,0,,It might be tempting to think that\N the second equation is redundant,
Dialogue: 0,1:45:31.28,1:45:32.64,Default,,0,0,0,,but in fact it isn't.
Dialogue: 0,1:45:34.12,1:45:37.16,Default,,0,0,0,,Deleting equation 2 would\N alter the semantics of the function
Dialogue: 0,1:45:37.16,1:45:41.36,Default,,0,0,0,,from crashing to returning\N 3 in this call here.
Dialogue: 0,1:45:41.36,1:45:42.48,Default,,0,0,0,,So, not redundant.
Dialogue: 0,1:45:44.00,1:45:46.40,Default,,0,0,0,,But on the other hand, we\N can never return 2,
Dialogue: 0,1:45:46.40,1:45:50.12,Default,,0,0,0,,which definitely smells like\N a bug worth reporting to the user.
Dialogue: 0,1:45:51.36,1:45:54.96,Default,,0,0,0,,We say that the equation has\N an inaccessible right-hand side.
Dialogue: 0,1:45:55.72,1:45:57.88,Default,,0,0,0,,Of course, when we call\N a clause redundant,
Dialogue: 0,1:45:57.88,1:46:01.12,Default,,0,0,0,,that always implies its right-\N hand side is inaccessible.
Dialogue: 0,1:46:03.36,1:46:05.48,Default,,0,0,0,,Lazy but not total also means
Dialogue: 0,1:46:05.48,1:46:08.32,Default,,0,0,0,,that we have bottom\N inhabiting every data type.
Dialogue: 0,1:46:08.84,1:46:10.56,Default,,0,0,0,,That includes the data type Void,
Dialogue: 0,1:46:10.56,1:46:12.80,Default,,0,0,0,,which doesn't have any\N data constructors,
Dialogue: 0,1:46:12.80,1:46:15.12,Default,,0,0,0,,so bottom is its only inhabitant.
Dialogue: 0,1:46:16.60,1:46:19.40,Default,,0,0,0,,These examples here introduce\N bindings of type Void
Dialogue: 0,1:46:19.92,1:46:23.04,Default,,0,0,0,,by resorting to divergence\N and runtime errors.
Dialogue: 0,1:46:24.04,1:46:26.72,Default,,0,0,0,,f here matches on them in\N a lazy wildcard match
Dialogue: 0,1:46:26.72,1:46:29.76,Default,,0,0,0,,and it's just a regular, exhaustive\N function definition.
Dialogue: 0,1:46:32.52,1:46:36.40,Default,,0,0,0,,Now that we have Void, we can\N combine it with strict fields.
Dialogue: 0,1:46:37.40,1:46:40.08,Default,,0,0,0,,Here is a strict Maybe\N data type, as you can tell
Dialogue: 0,1:46:40.08,1:46:43.84,Default,,0,0,0,,by the strictness annotation\N on SJust's field here.
Dialogue: 0,1:46:44.56,1:46:46.08,Default,,0,0,0,,Whenever SJust is constructed,
Dialogue: 0,1:46:46.08,1:46:48.44,Default,,0,0,0,,its field needs to\N be evaluated first.
Dialogue: 0,1:46:49.92,1:46:51.08,Default,,0,0,0,,The function f here
Dialogue: 0,1:46:51.08,1:46:52.96,Default,,0,0,0,,matches on SMaybe Void.
Dialogue: 0,1:46:53.72,1:46:57.52,Default,,0,0,0,,Question: is the second clause\N of f redundant or not?
Dialogue: 0,1:46:58.76,1:47:00.28,Default,,0,0,0,,We can answer this systematically
Dialogue: 0,1:47:00.28,1:47:03.84,Default,,0,0,0,,by enumerating\N the inhabitants of SMaybe Void
Dialogue: 0,1:47:03.84,1:47:06.76,Default,,0,0,0,,and see which equations\N of f match them.
Dialogue: 0,1:47:08.24,1:47:11.44,Default,,0,0,0,,The only two inhabitants\N are bottom and SNothing.
Dialogue: 0,1:47:12.96,1:47:14.72,Default,,0,0,0,,SJust of bottom is\N not an inhabitant
Dialogue: 0,1:47:14.72,1:47:16.44,Default,,0,0,0,,because of the strict field.
Dialogue: 0,1:47:17.20,1:47:19.72,Default,,0,0,0,,The first equation of\N f diverges on bottom
Dialogue: 0,1:47:20.48,1:47:22.16,Default,,0,0,0,,and matches on Nothing.
Dialogue: 0,1:47:24.16,1:47:25.20,Default,,0,0,0,,So yes: redundant.
Dialogue: 0,1:47:25.20,1:47:28.04,Default,,0,0,0,,There is no value possibly\N reaching the second equation.
Dialogue: 0,1:47:31.80,1:47:35.36,Default,,0,0,0,,Guards are another very basic\N pattern language feature of Haskell
Dialogue: 0,1:47:36.88,1:47:38.68,Default,,0,0,0,,Does sign have any\N redundant clauses?
Dialogue: 0,1:47:39.68,1:47:42.12,Default,,0,0,0,,In general, it's hard to tell\N without knowing the definition
Dialogue: 0,1:47:42.12,1:47:44.80,Default,,0,0,0,,of (<), (==), and so on.
Dialogue: 0,1:47:45.32,1:47:48.60,Default,,0,0,0,,Also we quickly become undecidable\N if we just reasoned about
Dialogue: 0,1:47:48.60,1:47:50.28,Default,,0,0,0,,every function we know\N the definition of.
Dialogue: 0,1:47:52.52,1:47:56.32,Default,,0,0,0,,So apparently, guards are quite\N rich, semantically speaking.
Dialogue: 0,1:47:57.32,1:48:00.28,Default,,0,0,0,,Here you can see how it's even\N possible to do pattern matching
Dialogue: 0,1:48:00.28,1:48:01.40,Default,,0,0,0,,with pattern guards.
Dialogue: 0,1:48:01.88,1:48:06.60,Default,,0,0,0,,And get here even mixes both\N structural pattern matching
Dialogue: 0,1:48:07.60,1:48:08.76,Default,,0,0,0,,and pattern guards.
Dialogue: 0,1:48:09.76,1:48:13.32,Default,,0,0,0,,This definition is exhaustive\N and the compiler should not flag it
Dialogue: 0,1:48:13.32,1:48:14.36,Default,,0,0,0,,as non-exhaustive.
Dialogue: 0,1:48:16.36,1:48:18.32,Default,,0,0,0,,I hope it has become clearer that
Dialogue: 0,1:48:18.32,1:48:20.84,Default,,0,0,0,,there are a lot of\N surface language features
Dialogue: 0,1:48:20.84,1:48:24.16,Default,,0,0,0,,that the pattern-match checker\N has to cope with efficiently.
Dialogue: 0,1:48:24.88,1:48:27.84,Default,,0,0,0,,Also many of these features\N interact with each other.
Dialogue: 0,1:48:28.60,1:48:31.08,Default,,0,0,0,,I won't have time to talk\N about the ones in parentheses
Dialogue: 0,1:48:31.08,1:48:32.92,Default,,0,0,0,,like long distance information,
Dialogue: 0,1:48:33.44,1:48:36.12,Default,,0,0,0,,so please do ask\N questions afterwards
Dialogue: 0,1:48:36.12,1:48:38.12,Default,,0,0,0,,and read the paper\N if you are interested.
Dialogue: 0,1:48:40.84,1:48:46.52,Default,,0,0,0,,The status quo in GHC was\N based on a 2015 ICFP paper
Dialogue: 0,1:48:46.52,1:48:50.12,Default,,0,0,0,,that handles most of the language\N features in the previous list,
Dialogue: 0,1:48:50.12,1:48:53.60,Default,,0,0,0,,including GADTs and type-level\N information in particular.
Dialogue: 0,1:48:54.60,1:48:58.12,Default,,0,0,0,,But having been battle-tested\N over the last couple of years,
Dialogue: 0,1:48:59.12,1:49:02.60,Default,,0,0,0,,the implementation revealed shortcomings\N in being too buggy and slow.
Dialogue: 0,1:49:03.12,1:49:09.92,Default,,0,0,0,,Also, it was pretty complicated. In\N trying to improve on what we had,
Dialogue: 0,1:49:09.92,1:49:11.24,Default,,0,0,0,,we iterated a couple of times
Dialogue: 0,1:49:11.24,1:49:14.44,Default,,0,0,0,,and came out with the new approach\N we called Lower Your Guards.
Dialogue: 0,1:49:16.92,1:49:18.36,Default,,0,0,0,,As the name suggests,
Dialogue: 0,1:49:18.36,1:49:22.12,Default,,0,0,0,,we abandoned all structural\N pattern matching like in f here
Dialogue: 0,1:49:22.12,1:49:25.56,Default,,0,0,0,,and desugar function\N definitions into guard trees.
Dialogue: 0,1:49:27.08,1:49:29.40,Default,,0,0,0,,Then we do coverage checking\N on these guard trees
Dialogue: 0,1:49:29.40,1:49:34.08,Default,,0,0,0,,which is split in two\N simple functions A and U.
Dialogue: 0,1:49:35.56,1:49:39.32,Default,,0,0,0,,A returns an annotated tree\N decorated with refinement types
Dialogue: 0,1:49:39.32,1:49:42.32,Default,,0,0,0,,that capture redundancy\N and inaccessibility information.
Dialogue: 0,1:49:43.32,1:49:45.24,Default,,0,0,0,,If you want to know more about this part,
Dialogue: 0,1:49:45.24,1:49:46.88,Default,,0,0,0,,I encourage you to read the paper.
Dialogue: 0,1:49:48.40,1:49:52.24,Default,,0,0,0,,U computes the set of values that\N weren't covered by any clause
Dialogue: 0,1:49:52.24,1:49:53.64,Default,,0,0,0,,as a refinement type Θ,
Dialogue: 0,1:49:54.40,1:49:58.48,Default,,0,0,0,,and then all we have to do is\N report the inhabitants of Θ
Dialogue: 0,1:49:58.48,1:50:01.20,Default,,0,0,0,,as uncovered patterns\N of the definition.
Dialogue: 0,1:50:04.92,1:50:07.12,Default,,0,0,0,,Let's desugar this\N fancy example function.
Dialogue: 0,1:50:07.84,1:50:09.84,Default,,0,0,0,,Green indicates source syntax.
Dialogue: 0,1:50:09.84,1:50:13.04,Default,,0,0,0,,You can see that fancy makes\N use of constructor patterns
Dialogue: 0,1:50:13.04,1:50:14.68,Default,,0,0,0,,and even two language extensions:
Dialogue: 0,1:50:15.40,1:50:17.68,Default,,0,0,0,,a bang pattern that\N forces the matched thing,
Dialogue: 0,1:50:18.44,1:50:21.96,Default,,0,0,0,,and a view pattern that\N applies g to the matched thing
Dialogue: 0,1:50:23.44,1:50:25.64,Default,,0,0,0,,and matches\N the result against True.
Dialogue: 0,1:50:29.12,1:50:32.04,Default,,0,0,0,,In yellow you see fancy's\N desugaring to guard trees.
Dialogue: 0,1:50:33.28,1:50:35.24,Default,,0,0,0,,Here is their syntax\N definition for reference.
Dialogue: 0,1:50:36.00,1:50:37.80,Default,,0,0,0,,Let's focus on tree syntax first.
Dialogue: 0,1:50:38.80,1:50:40.60,Default,,0,0,0,,There is one branch\N in the guard tree
Dialogue: 0,1:50:40.60,1:50:42.76,Default,,0,0,0,,for each clause in\N the function definition,
Dialogue: 0,1:50:43.24,1:50:44.44,Default,,0,0,0,,modeling fall-through semantics.
Dialogue: 0,1:50:45.16,1:50:47.32,Default,,0,0,0,,There are also a bunch of\N guards on each branch,
Dialogue: 0,1:50:47.32,1:50:51.08,Default,,0,0,0,,and each branch ends in\N an ordinal that identifies
Dialogue: 0,1:50:51.08,1:50:54.08,Default,,0,0,0,,a particular clause in\N the original program.
Dialogue: 0,1:50:56.56,1:51:00.04,Default,,0,0,0,,Looking at guards, we can see\N that nested pattern matching
Dialogue: 0,1:51:00.04,1:51:03.84,Default,,0,0,0,,was completely decomposed into\N multiple flat pattern guards,
Dialogue: 0,1:51:03.84,1:51:05.32,Default,,0,0,0,,like on Just here.
Dialogue: 0,1:51:08.32,1:51:10.12,Default,,0,0,0,,Pattern guards are considered lazy,
Dialogue: 0,1:51:10.12,1:51:15.16,Default,,0,0,0,,and evaluation is forced by\N bang guards such as on x1 here,
Dialogue: 0,1:51:15.16,1:51:17.00,Default,,0,0,0,,which stands for the first argument.
Dialogue: 0,1:51:19.76,1:51:21.76,Default,,0,0,0,,Pattern guards can only\N match on variables
Dialogue: 0,1:51:21.76,1:51:23.48,Default,,0,0,0,,and only one level deep at a time.
Dialogue: 0,1:51:24.76,1:51:27.20,Default,,0,0,0,,We give names to more\N complex expressions
Dialogue: 0,1:51:27.20,1:51:29.92,Default,,0,0,0,,like this function application\N with a let binding,
Dialogue: 0,1:51:30.68,1:51:35.08,Default,,0,0,0,,which also allows us to desugar\N the view pattern here, for example.
Dialogue: 0,1:51:36.32,1:51:40.28,Default,,0,0,0,,Desugaring also introduces\N a few administrative lets
Dialogue: 0,1:51:41.04,1:51:42.48,Default,,0,0,0,,that fix up naming differences,
Dialogue: 0,1:51:42.48,1:51:45.88,Default,,0,0,0,,like the one binding xs to\N the temporary t2 here.
Dialogue: 0,1:51:49.88,1:51:53.28,Default,,0,0,0,,We found similar desugarings for\N all the pattern-match syntax
Dialogue: 0,1:51:53.28,1:51:54.28,Default,,0,0,0,,of modern Haskell.
Dialogue: 0,1:51:55.00,1:51:58.04,Default,,0,0,0,,Also note that desugaring is\N for coverage checking only.
Dialogue: 0,1:51:58.04,1:51:59.44,Default,,0,0,0,,There is no code\N generation involved.
Dialogue: 0,1:52:03.20,1:52:08.08,Default,,0,0,0,,Alright, next up: characterizing\N the set of uncovered values
Dialogue: 0,1:52:08.08,1:52:10.44,Default,,0,0,0,,that we can report\N uncovered patterns for.
Dialogue: 0,1:52:11.68,1:52:16.16,Default,,0,0,0,,We compute the set by gradually\N refining the set of possible values
Dialogue: 0,1:52:17.16,1:52:21.04,Default,,0,0,0,,as a fraction of them falls through\N from one clause to the next.

Dialogue: 0,1:52:23.04,1:52:27.36,Default,,0,0,0,,How do we represent such a set with\N possibly infinitely many values?
Dialogue: 0,1:52:28.84,1:52:30.52,Default,,0,0,0,,We picked refinement\N types for the job.

Dialogue: 0,1:52:31.52,1:52:34.04,Default,,0,0,0,,Here are a few example\N refinement types in blue,
Dialogue: 0,1:52:34.04,1:52:37.04,Default,,0,0,0,,as well as the sets\N they denote in orange.
Dialogue: 0,1:52:38.04,1:52:42.36,Default,,0,0,0,,Cross is the unsatisfiable\N refinement predicate,
Dialogue: 0,1:52:42.36,1:52:44.12,Default,,0,0,0,,so there are no inhabitants.
Dialogue: 0,1:52:45.40,1:52:49.16,Default,,0,0,0,,Check mark is the trivially\N satisfiable refinement predicate
Dialogue: 0,1:52:49.16,1:52:51.68,Default,,0,0,0,,which means we have all\N the inhabitants of Bool.
Dialogue: 0,1:52:53.44,1:52:56.40,Default,,0,0,0,,This is the type of\N unlifted Booleans
Dialogue: 0,1:52:56.40,1:52:58.72,Default,,0,0,0,,and this one also rules out False.
Dialogue: 0,1:53:00.44,1:53:04.28,Default,,0,0,0,,This last one here shows what's\N unusual about our refinement types.
Dialogue: 0,1:53:04.28,1:53:06.84,Default,,0,0,0,,It has a pattern guard on mx
Dialogue: 0,1:53:07.84,1:53:10.96,Default,,0,0,0,,that brings Just's field x into scope,
Dialogue: 0,1:53:11.96,1:53:15.24,Default,,0,0,0,,which then scopes over the conjunct\N to the right of the pattern guard.
Dialogue: 0,1:53:19.24,1:53:21.84,Default,,0,0,0,,For some reasonably simple\N end-to-end example,
Dialogue: 0,1:53:21.84,1:53:23.40,Default,,0,0,0,,consider this source program.
Dialogue: 0,1:53:24.16,1:53:25.88,Default,,0,0,0,,It will desugar to this guard tree,
Dialogue: 0,1:53:25.88,1:53:29.12,Default,,0,0,0,,which in turn we can compute\N the uncovered set for.
Dialogue: 0,1:53:31.12,1:53:33.12,Default,,0,0,0,,Note that the resulting\N refinement type
Dialogue: 0,1:53:33.12,1:53:35.12,Default,,0,0,0,,has a disjunction in its predicate
Dialogue: 0,1:53:35.88,1:53:38.56,Default,,0,0,0,,because we can fall through\N from this clause here
Dialogue: 0,1:53:38.56,1:53:39.60,Default,,0,0,0,,in two different ways.
Dialogue: 0,1:53:40.12,1:53:42.04,Default,,0,0,0,,First, the match on Just\N could have failed,
Dialogue: 0,1:53:42.04,1:53:44.36,Default,,0,0,0,,and even if the match\N on Just succeeded,
Dialogue: 0,1:53:45.08,1:53:46.80,Default,,0,0,0,,the match on True could have failed.
Dialogue: 0,1:53:47.28,1:53:50.04,Default,,0,0,0,,Question now: how do we\N do this in general?
Dialogue: 0,1:53:52.56,1:53:53.76,Default,,0,0,0,,With a function like this,
Dialogue: 0,1:53:55.04,1:53:57.28,Default,,0,0,0,,U computes the subset of Θ
Dialogue: 0,1:53:57.28,1:54:00.32,Default,,0,0,0,,whose values do not\N match the guard tree t.
Dialogue: 0,1:54:02.32,1:54:05.60,Default,,0,0,0,,When we reach the right-hand side,\N every incoming value is covered.
Dialogue: 0,1:54:05.60,1:54:07.96,Default,,0,0,0,,So we return\N the empty refinement type.
Dialogue: 0,1:54:08.96,1:54:11.16,Default,,0,0,0,,Branches model fall-\N through semantics.
Dialogue: 0,1:54:11.16,1:54:13.48,Default,,0,0,0,,Only values that fall\N through the first branch
Dialogue: 0,1:54:14.48,1:54:16.40,Default,,0,0,0,,can fall through the second branch.

Dialogue: 0,1:54:17.92,1:54:21.40,Default,,0,0,0,,A bang guard on x adds\N the constraint that x can't be bottom
Dialogue: 0,1:54:21.40,1:54:23.32,Default,,0,0,0,,to the incoming values\N of the subtree;
Dialogue: 0,1:54:24.32,1:54:25.56,Default,,0,0,0,,likewise for let bindings.
Dialogue: 0,1:54:27.32,1:54:30.68,Default,,0,0,0,,A pattern guard matching\N against constructor K
Dialogue: 0,1:54:30.68,1:54:33.32,Default,,0,0,0,,will fall through when x is not K.
Dialogue: 0,1:54:35.56,1:54:39.44,Default,,0,0,0,,Also everything not covered\N by the subtree is uncovered,
Dialogue: 0,1:54:39.44,1:54:43.08,Default,,0,0,0,,so we adjoin the two refinement types.
Dialogue: 0,1:54:44.08,1:54:45.84,Default,,0,0,0,,And that's all there is\N to coverage checking.

Dialogue: 0,1:54:47.32,1:54:51.80,Default,,0,0,0,,The next step is to generate\N inhabitants of the refinement type
Dialogue: 0,1:54:51.80,1:54:53.16,Default,,0,0,0,,falling out at the bottom.
Dialogue: 0,1:54:53.64,1:54:57.16,Default,,0,0,0,,These are the uncovered clauses\N which we want to report to the user.
Dialogue: 0,1:54:57.16,1:55:00.00,Default,,0,0,0,,If it's empty, then\N the pattern match was exhaustive.
Dialogue: 0,1:55:01.24,1:55:03.40,Default,,0,0,0,,For our particular running example,
Dialogue: 0,1:55:03.40,1:55:06.00,Default,,0,0,0,,the inhabitants are easy\N to find: Just True and
Dialogue: 0,1:55:07.32,1:55:09.32,Default,,0,0,0,,Just False, which are\N already in a suitable form
Dialogue: 0,1:55:09.32,1:55:12.00,Default,,0,0,0,,to be presented to the user.
Dialogue: 0,1:55:12.52,1:55:14.12,Default,,0,0,0,,Algorithmically, we could use
Dialogue: 0,1:55:14.12,1:55:16.68,Default,,0,0,0,,Liquid Haskell's embedding\N of refinement types,
Dialogue: 0,1:55:16.68,1:55:19.68,Default,,0,0,0,,or an SMT solver directly,\N to generate inhabitants.
Dialogue: 0,1:55:19.68,1:55:22.52,Default,,0,0,0,,But we didn't do that, because
Dialogue: 0,1:55:22.52,1:55:27.20,Default,,0,0,0,,reflecting GHC's type-\N constraint solver into SMT logic
Dialogue: 0,1:55:27.20,1:55:29.08,Default,,0,0,0,,is quite an undertaking.
Dialogue: 0,1:55:29.08,1:55:33.52,Default,,0,0,0,,And we think that FFI calls\N and serialization of facts

Dialogue: 0,1:55:33.52,1:55:35.84,Default,,0,0,0,,incur too much overhead.
Dialogue: 0,1:55:35.84,1:55:37.44,Default,,0,0,0,,So, we bit the bullet
Dialogue: 0,1:55:37.44,1:55:40.76,Default,,0,0,0,,and just wrote our own \N ad-hoc generator function.

Dialogue: 0,1:55:40.76,1:55:42.88,Default,,0,0,0,,You can read more about\N its implementation
Dialogue: 0,1:55:42.88,1:55:46.16,Default,,0,0,0,,and its completeness\N properties in the paper.
Dialogue: 0,1:55:46.68,1:55:50.12,Default,,0,0,0,,Now, for an uncovered\N set coming from
Dialogue: 0,1:55:50.12,1:55:53.04,Default,,0,0,0,,an obviously exhaustive\N definition like h here,
Dialogue: 0,1:55:53.04,1:55:55.44,Default,,0,0,0,,we find that we can't\N produce any inhabitants.
Dialogue: 0,1:55:55.44,1:55:59.44,Default,,0,0,0,,So, no values to represent,\N hence no warnings to emit.
Dialogue: 0,1:55:59.44,1:56:01.56,Default,,0,0,0,,h is found to be exhaustive.
Dialogue: 0,1:56:03.80,1:56:07.56,Default,,0,0,0,,In conclusion, we came up\N with what we find to be
Dialogue: 0,1:56:07.56,1:56:11.24,Default,,0,0,0,,quite a nice solution to\N pattern-match coverage checking.
Dialogue: 0,1:56:11.24,1:56:12.60,Default,,0,0,0,,It took us many\N iterations to get there,
Dialogue: 0,1:56:12.60,1:56:14.40,Default,,0,0,0,,but in the end, it paid off.
Dialogue: 0,1:56:14.40,1:56:17.28,Default,,0,0,0,,The end result is, at the same\N time, simpler to think about;
Dialogue: 0,1:56:17.28,1:56:20.92,Default,,0,0,0,,simpler to implement;\N and executes much faster.
Dialogue: 0,1:56:22.32,1:56:24.40,Default,,0,0,0,,The fact that we invented\N it for a lazy language
Dialogue: 0,1:56:24.40,1:56:26.52,Default,,0,0,0,,shouldn't stop you from\N lowering your guards
Dialogue: 0,1:56:26.52,1:56:29.48,Default,,0,0,0,,in strict or even mostly\N imperative languages.
Dialogue: 0,1:56:29.48,1:56:31.48,Default,,0,0,0,,Just write your own\N desugaring function.
Dialogue: 0,1:56:31.48,1:56:33.68,Default,,0,0,0,,And if you're in the process\N of writing a coverage checker
Dialogue: 0,1:56:33.68,1:56:36.12,Default,,0,0,0,,and don't want to make\N the same mistakes,
Dialogue: 0,1:56:36.12,1:56:38.32,Default,,0,0,0,,I can only encourage\N you to read the paper.
Dialogue: 0,1:56:38.32,1:56:40.44,Default,,0,0,0,,Lots of more stories to be told
Dialogue: 0,1:56:40.44,1:56:43.64,Default,,0,0,0,,about language extensions\N and efficiency concerns.
Dialogue: 0,1:56:45.32,1:56:48.08,Default,,0,0,0,,Alright, that's it.\N Thank you for listening.
Dialogue: 0,1:56:48.56,1:56:53.56,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:56:56.92,1:56:58.44,Default,,0,0,0,,STEPHANIE: Thank you, Sebastian.
Dialogue: 0,1:56:58.44,1:57:00.72,Default,,0,0,0,,If you are watching this talk live,
Dialogue: 0,1:57:00.72,1:57:03.64,Default,,0,0,0,,be sure to join the Q&A\N session with the author,
Dialogue: 0,1:57:03.64,1:57:07.60,Default,,0,0,0,,if it is available in your time zone.
Dialogue: 0,1:57:09.20,1:57:14.20,Default,,0,0,0,,We will now pause to sync up\N with the rest of the schedule.
Dialogue: 0,1:58:01.68,1:58:03.56,Default,,0,0,0,,STEPHANIE: The last talk\N of this session is
Dialogue: 0,1:58:03.56,1:58:08.00,Default,,0,0,0,,signature restriction for\N polymorphic algebraic effects.
Dialogue: 0,1:58:08.00,1:58:13.92,Default,,0,0,0,,This paper is by Taro Sekiyama,\N Takeshi Tsukada and Atsushi Igarashi.
Dialogue: 0,1:58:14.80,1:58:18.52,Default,,0,0,0,,The talk will be presented\N by Taro Sekiyama.
Dialogue: 0,1:58:19.24,1:58:21.64,Default,,0,0,0,,TARO SEKIYAMA: Hello,\N I'm Taro Sekiyama.
Dialogue: 0,1:58:21.64,1:58:24.68,Default,,0,0,0,,This talk is about our ICFP paper,
Dialogue: 0,1:58:24.68,1:58:29.04,Default,,0,0,0,,signature restriction for\N polymorphic algebraic effect.
Dialogue: 0,1:58:29.04,1:58:33.64,Default,,0,0,0,,In this work, we consider\N our new type-safe approach
Dialogue: 0,1:58:33.64,1:58:36.52,Default,,0,0,0,,to combining two\N programming features,
Dialogue: 0,1:58:36.52,1:58:40.44,Default,,0,0,0,,algebraic effects handlers\N and polymorphism.
Dialogue: 0,1:58:41.04,1:58:46.84,Default,,0,0,0,,Algebraic effect handlers is\N an approach to user-defined effects.
Dialogue: 0,1:58:46.84,1:58:53.20,Default,,0,0,0,,And they can also structure effectful\N programs in a modular way.
Dialogue: 0,1:58:53.20,1:58:58.20,Default,,0,0,0,,Thanks to the separation of interface\N and implementation of effect.
Dialogue: 0,1:58:58.92,1:59:02.04,Default,,0,0,0,,Using algebraic effect handlers,\N we can define various effects,
Dialogue: 0,1:59:02.04,1:59:07.04,Default,,0,0,0,,such as an exception backtracking\N state, and interactions by user.
Dialogue: 0,1:59:08.40,1:59:13.44,Default,,0,0,0,,Another feature we consider in\N this work is polymorphism.
Dialogue: 0,1:59:13.44,1:59:16.96,Default,,0,0,0,,In particular, we consider\N implicit polymorphism
Dialogue: 0,1:59:16.96,1:59:19.88,Default,,0,0,0,,as in let-polymorphism.
Dialogue: 0,1:59:19.88,1:59:23.28,Default,,0,0,0,,And by combining these\N two programming features,
Dialogue: 0,1:59:23.28,1:59:28.28,Default,,0,0,0,,we can make not only expressions,\N but also effects polymorphic.
Dialogue: 0,1:59:30.68,1:59:35.48,Default,,0,0,0,,So, let's show one\N example of using your
Dialogue: 0,1:59:35.48,1:59:39.36,Default,,0,0,0,,algebraic effect handlers\N and polymorphism.
Dialogue: 0,1:59:39.36,1:59:44.24,Default,,0,0,0,,Algebraic effects handlers\N provide us three constructs
Dialogue: 0,1:59:44.24,1:59:46.88,Default,,0,0,0,,to implement our effect.
Dialogue: 0,1:59:48.36,1:59:52.84,Default,,0,0,0,,The first construct is\N effect declarations
Dialogue: 0,1:59:52.84,1:59:57.84,Default,,0,0,0,,which is used in the first\N line of the running example.
Dialogue: 0,1:59:58.68,2:00:06.20,Default,,0,0,0,,Here, the operation 'choose' is declared\N with this polymorphic type.
Dialogue: 0,2:00:06.20,2:00:10.20,Default,,0,0,0,,So, this type means that the 'choose'\N operation takes two arguments,
Dialogue: 0,2:00:10.20,2:00:12.76,Default,,0,0,0,,and returns either of them.
Dialogue: 0,2:00:13.28,2:00:17.00,Default,,0,0,0,,Here, polymorphism allows\N the type of 'choose'
Dialogue: 0,2:00:17.00,2:00:20.92,Default,,0,0,0,,to abstract over\N the type of argument.
Dialogue: 0,2:00:23.80,2:00:25.56,Default,,0,0,0,,The second construct\N is operation calls,
Dialogue: 0,2:00:25.56,2:00:29.16,Default,,0,0,0,,which is used in these expressions.
Dialogue: 0,2:00:30.76,2:00:36.08,Default,,0,0,0,,Here, the arguments to choose\N operation calls are passed
Dialogue: 0,2:00:36.08,2:00:40.40,Default,,0,0,0,,on the second function for peers.
Dialogue: 0,2:00:41.08,2:00:46.88,Default,,0,0,0,,So, both of these functions can\N be of this polymorphic type.
Dialogue: 0,2:00:47.48,2:00:52.40,Default,,0,0,0,,So, the result of this\N operation calls is also
Dialogue: 0,2:00:52.40,2:00:55.84,Default,,0,0,0,,assigned the same polymorphic type.
Dialogue: 0,2:00:56.76,2:01:03.48,Default,,0,0,0,,The third construct is\N for 'define' effect.
Dialogue: 0,2:01:04.44,2:01:08.28,Default,,0,0,0,,and which is achieved by\N the use of effects handlers.
Dialogue: 0,2:01:08.28,2:01:13.40,Default,,0,0,0,,So, if you have handlers, a key\N component in defining effects,
Dialogue: 0,2:01:13.40,2:01:16.96,Default,,0,0,0,,but in this talk, I omit\N the details of them.
Dialogue: 0,2:01:19.52,2:01:26.72,Default,,0,0,0,,So, the problem we consider\N in this talk is (INAUDIBLE)
Dialogue: 0,2:01:26.72,2:01:30.80,Default,,0,0,0,,combining algebraic library;\N combining algebraic effect handlers
Dialogue: 0,2:01:30.80,2:01:32.20,Default,,0,0,0,,and implicit polymorphism.
Dialogue: 0,2:01:32.68,2:01:36.48,Default,,0,0,0,,So, this is a problem because\N the right combination
Dialogue: 0,2:01:36.48,2:01:38.80,Default,,0,0,0,,of these programming features
Dialogue: 0,2:01:38.80,2:01:42.64,Default,,0,0,0,,makes a statically\N typed language unsafe.
Dialogue: 0,2:01:42.64,2:01:47.32,Default,,0,0,0,,This is because algebraic effect\N handlers have the ability
Dialogue: 0,2:01:47.32,2:01:50.20,Default,,0,0,0,,to manipulate delimited\N continuations.
Dialogue: 0,2:01:50.20,2:01:56.04,Default,,0,0,0,,But the combination\N of the use of continuations
Dialogue: 0,2:01:56.04,2:02:01.04,Default,,0,0,0,,and implicit polymorphism\N is known to be unsafe.
Dialogue: 0,2:02:01.04,2:02:06.04,Default,,0,0,0,,So, this is a problem we attack\N in this program, in this work.
Dialogue: 0,2:02:06.60,2:02:08.92,Default,,0,0,0,,But this is a classic problem.
Dialogue: 0,2:02:08.92,2:02:13.20,Default,,0,0,0,,There are many approaches\N to solving this one.
Dialogue: 0,2:02:13.20,2:02:19.92,Default,,0,0,0,,So, the existing approaches can be\N classified into two categories.
Dialogue: 0,2:02:19.92,2:02:22.20,Default,,0,0,0,,The first category is considered
Dialogue: 0,2:02:22.20,2:02:27.20,Default,,0,0,0,,restricting operation calls\N in polymorphic expressions.
Dialogue: 0,2:02:28.04,2:02:30.48,Default,,0,0,0,,For the running examples,
Dialogue: 0,2:02:30.48,2:02:36.60,Default,,0,0,0,,the approaches in this category\N restrict these expressions,
Dialogue: 0,2:02:36.60,2:02:41.72,Default,,0,0,0,,because this is an operation call\N in a polymorphic expression.
Dialogue: 0,2:02:41.72,2:02:46.32,Default,,0,0,0,,For example, value restriction,\N weak polymorphism, closure typing
Dialogue: 0,2:02:46.32,2:02:49.44,Default,,0,0,0,,belong to this category.
Dialogue: 0,2:02:49.44,2:02:53.24,Default,,0,0,0,,An advantage of using\N these approaches is that
Dialogue: 0,2:02:53.24,2:02:57.04,Default,,0,0,0,,they can address any effect
Dialogue: 0,2:02:57.04,2:03:01.28,Default,,0,0,0,,including ML-style reference\N under control operators.
Dialogue: 0,2:03:01.88,2:03:06.36,Default,,0,0,0,,However, the disadvantage\N of these approaches is that
Dialogue: 0,2:03:06.36,2:03:11.36,Default,,0,0,0,,they impose a restriction\N on any effect code.
Dialogue: 0,2:03:12.04,2:03:14.60,Default,,0,0,0,,Because, for example,
Dialogue: 0,2:03:14.60,2:03:19.28,Default,,0,0,0,,even if the operation call\N doesn't need restriction.
Dialogue: 0,2:03:19.28,2:03:23.28,Default,,0,0,0,,For example, we found\N in the previous work,
Dialogue: 0,2:03:23.28,2:03:28.76,Default,,0,0,0,,exceptions on the backtracking\N don't need a restriction.
Dialogue: 0,2:03:28.76,2:03:35.04,Default,,0,0,0,,But the approaches in this category\N don't distinguish effect
Dialogue: 0,2:03:35.04,2:03:37.76,Default,,0,0,0,,that need\N a restriction from the effects,
Dialogue: 0,2:03:37.76,2:03:39.96,Default,,0,0,0,,that don't\N need a restriction.
Dialogue: 0,2:03:40.48,2:03:44.40,Default,,0,0,0,,So, they impose\N a restriction for all effects.
Dialogue: 0,2:03:46.56,2:03:49.60,Default,,0,0,0,,As a complimentary approach\N in the previous work,
Dialogue: 0,2:03:49.60,2:03:56.48,Default,,0,0,0,,we provided our new approach to\N restricting effect handlers
Dialogue: 0,2:03:56.48,2:03:58.72,Default,,0,0,0,,instead of operation calls.
Dialogue: 0,2:03:58.72,2:04:00.96,Default,,0,0,0,,So, in the running example,
Dialogue: 0,2:04:00.96,2:04:05.40,Default,,0,0,0,,this approach illustrates\N this part, effect handlers.
Dialogue: 0,2:04:07.64,2:04:10.40,Default,,0,0,0,,A good point over this\N approach is that
Dialogue: 0,2:04:10.40,2:04:15.60,Default,,0,0,0,,it allows operation calls\N of safe effects anywhere;
Dialogue: 0,2:04:15.60,2:04:20.24,Default,,0,0,0,,and it rejects unsafe\N effects safely.
Dialogue: 0,2:04:20.84,2:04:26.80,Default,,0,0,0,,But the problem of\N this approach is that
Dialogue: 0,2:04:26.80,2:04:29.76,Default,,0,0,0,,it is not clear how to mix
Dialogue: 0,2:04:29.76,2:04:34.32,Default,,0,0,0,,safe and unsafe effects\N in a single program.
Dialogue: 0,2:04:34.32,2:04:38.80,Default,,0,0,0,,So, this could be a problem\N in a general purpose program,
Dialogue: 0,2:04:38.80,2:04:42.88,Default,,0,0,0,,because we may want to use
Dialogue: 0,2:04:42.88,2:04:47.88,Default,,0,0,0,,a safe and unsafe effect\N in a single program.
Dialogue: 0,2:04:50.40,2:04:54.68,Default,,0,0,0,,To solve this problem, we\N propose a new approach
Dialogue: 0,2:04:54.68,2:04:59.24,Default,,0,0,0,,which restricts the types\N of effect operations.
Dialogue: 0,2:04:59.24,2:05:02.80,Default,,0,0,0,,So, in this running examples,
Dialogue: 0,2:05:02.80,2:05:06.80,Default,,0,0,0,,this new approach restricts\N effect declarations.
Dialogue: 0,2:05:07.80,2:05:12.32,Default,,0,0,0,,We can determine whether\N any usable effects are safe
Dialogue: 0,2:05:12.32,2:05:15.60,Default,,0,0,0,,only by examining how this is like.
Dialogue: 0,2:05:18.68,2:05:21.20,Default,,0,0,0,,OK, so, let me summarize our work.
Dialogue: 0,2:05:21.72,2:05:26.36,Default,,0,0,0,,We propose a signature restriction\N which can ensure safety
Dialogue: 0,2:05:26.36,2:05:29.28,Default,,0,0,0,,of effects with polymorphism.
Dialogue: 0,2:05:29.28,2:05:33.12,Default,,0,0,0,,And the signature restriction\N accepts only effects that can
Dialogue: 0,2:05:33.12,2:05:37.20,Default,,0,0,0,,be safely used anywhere, even\N in polymorphic expressions
Dialogue: 0,2:05:37.20,2:05:40.12,Default,,0,0,0,,without any other restriction.
Dialogue: 0,2:05:40.64,2:05:44.04,Default,,0,0,0,,Now, the signature\N restriction examines
Dialogue: 0,2:05:44.04,2:05:47.56,Default,,0,0,0,,the typed signatures of effects.
Dialogue: 0,2:05:47.56,2:05:50.52,Default,,0,0,0,,So, it is very simple criteria.
Dialogue: 0,2:05:51.08,2:05:55.72,Default,,0,0,0,,But how it is still\N permissive, in the sense that
Dialogue: 0,2:05:55.72,2:06:00.96,Default,,0,0,0,,it can accept a many useful\N effects and it is also scalable.
Dialogue: 0,2:06:00.96,2:06:05.32,Default,,0,0,0,,It means that their signature\N restriction can easily support
Dialogue: 0,2:06:05.32,2:06:11.12,Default,,0,0,0,,basic programming constructs\N including products, sums and lists.
Dialogue: 0,2:06:13.52,2:06:17.00,Default,,0,0,0,,And to shows the correctness\N of this signature restriction.
Dialogue: 0,2:06:17.00,2:06:20.56,Default,,0,0,0,,We provided a simple type system
Dialogue: 0,2:06:20.56,2:06:24.88,Default,,0,0,0,,for algebraic effect\N handlers and polymorphism.
Dialogue: 0,2:06:24.88,2:06:28.28,Default,,0,0,0,,We show soundness of\N the simple type system
Dialogue: 0,2:06:28.28,2:06:33.28,Default,,0,0,0,,by assuming all effects satisfy\N the signature restriction.
Dialogue: 0,2:06:33.92,2:06:38.92,Default,,0,0,0,,So, this demonstrates the correctness\N of the signature restriction.
Dialogue: 0,2:06:40.76,2:06:44.84,Default,,0,0,0,,But the problem with this\N simple type system is that
Dialogue: 0,2:06:44.84,2:06:48.44,Default,,0,0,0,,we cannot use both effects
Dialogue: 0,2:06:48.44,2:06:52.96,Default,,0,0,0,,that satisfy and don't satisfy\N the signature restriction.
Dialogue: 0,2:06:52.96,2:06:57.76,Default,,0,0,0,,So, to solve this situation,\N we propose an effect system
Dialogue: 0,2:06:57.76,2:07:03.56,Default,,0,0,0,,where both safe effects\N and unsafe effects can be used.
Dialogue: 0,2:07:06.08,2:07:10.60,Default,,0,0,0,,And more precisely, in\N this effect system,
Dialogue: 0,2:07:10.60,2:07:14.00,Default,,0,0,0,,effects that satisfy\N the signature restriction can be used
Dialogue: 0,2:07:14.00,2:07:16.68,Default,,0,0,0,,anywhere without a restriction.
Dialogue: 0,2:07:16.68,2:07:20.32,Default,,0,0,0,,But if effects don't satisfy\N the signature restriction,
Dialogue: 0,2:07:20.32,2:07:25.32,Default,,0,0,0,,then they can be used only\N in monomorphic expressions.
Dialogue: 0,2:07:26.16,2:07:29.72,Default,,0,0,0,,We also provide\N an artifact that implements
Dialogue: 0,2:07:29.72,2:07:33.36,Default,,0,0,0,,a tiny small ML-like functional\N programming language,
Dialogue: 0,2:07:33.36,2:07:38.88,Default,,0,0,0,,where all effects are supposed to\N satisfy the signature restriction.
Dialogue: 0,2:07:39.36,2:07:43.40,Default,,0,0,0,,And this implementation does not\N cover the effect system part.
Dialogue: 0,2:07:45.40,2:07:49.64,Default,,0,0,0,,OK, so this is a quick\N summary of our work.
Dialogue: 0,2:07:49.64,2:07:54.76,Default,,0,0,0,,On the next, I will present a brief\N overview of signature restriction.
Dialogue: 0,2:07:54.76,2:07:59.76,Default,,0,0,0,,As I said, signature\N restriction is an approach
Dialogue: 0,2:07:59.76,2:08:04.76,Default,,0,0,0,,to determining safety of effects\N with the signature of effects.
Dialogue: 0,2:08:05.48,2:08:09.32,Default,,0,0,0,,So, let's suppose we\N consider these operations
Dialogue: 0,2:08:09.32,2:08:12.32,Default,,0,0,0,,with this polymorphic type
Dialogue: 0,2:08:12.32,2:08:18.72,Default,,0,0,0,,Here, the signature restriction\N determines the safety of effect
Dialogue: 0,2:08:19.28,2:08:23.40,Default,,0,0,0,,only by examining\N the polarities of alpha
Dialogue: 0,2:08:23.40,2:08:27.32,Default,,0,0,0,,in argument type tau one\N and return type tau two.
Dialogue: 0,2:08:27.80,2:08:34.04,Default,,0,0,0,,But formally, we can say operation\N satisfy the signature restriction,
Dialogue: 0,2:08:34.04,2:08:37.80,Default,,0,0,0,,if and only if alpha\N occurs only negatively,
Dialogue: 0,2:08:37.80,2:08:42.96,Default,,0,0,0,,or strictly positively\N in argument type tau one.
Dialogue: 0,2:08:42.96,2:08:47.96,Default,,0,0,0,,And alpha occurs only\N positively in return type tau two.
Dialogue: 0,2:08:48.52,2:08:54.72,Default,,0,0,0,,Here, let me remember what that\N means by strictly positively.
Dialogue: 0,2:08:55.40,2:08:58.32,Default,,0,0,0,,So, in this simple function type,
Dialogue: 0,2:08:58.32,2:09:04.52,Default,,0,0,0,,the occurrences of alpha one\N and alpha three are positive,
Dialogue: 0,2:09:05.12,2:09:09.44,Default,,0,0,0,,but only the occurrence of alpha\N three is strictly positive.
Dialogue: 0,2:09:09.44,2:09:12.36,Default,,0,0,0,,This is because the occurrence\N of alpha three is reached
Dialogue: 0,2:09:12.36,2:09:16.76,Default,,0,0,0,,by going through only\N the positive part of function phi,
Dialogue: 0,2:09:16.76,2:09:21.52,Default,,0,0,0,,but the occurrence of\N alpha one is reached by
Dialogue: 0,2:09:21.52,2:09:26.04,Default,,0,0,0,,going through a negative part\N of functional type constructor.
Dialogue: 0,2:09:26.04,2:09:27.84,Default,,0,0,0,,So, this is the difference of
Dialogue: 0,2:09:27.84,2:09:32.40,Default,,0,0,0,,the polarities of alpha\N one and alpha three.
Dialogue: 0,2:09:32.92,2:09:38.08,Default,,0,0,0,,And by using this\N definitions, we check
Dialogue: 0,2:09:38.08,2:09:44.88,Default,,0,0,0,,our three operation calls\N satisfy the signature restriction.
Dialogue: 0,2:09:45.48,2:09:48.04,Default,,0,0,0,,The first example is 'choose'.
Dialogue: 0,2:09:48.04,2:09:51.88,Default,,0,0,0,,So, we can easily find this type.
Dialogue: 0,2:09:52.36,2:09:55.96,Default,,0,0,0,,This type of 'choose' satisfies\N the signature restriction
Dialogue: 0,2:09:55.96,2:09:58.88,Default,,0,0,0,,because, for the argument type,
Dialogue: 0,2:09:58.88,2:10:03.32,Default,,0,0,0,,the bound type variables occurs\N only strictly positively.
Dialogue: 0,2:10:03.32,2:10:09.52,Default,,0,0,0,,And for return type, it also\N occurs only positively.
Dialogue: 0,2:10:10.00,2:10:15.28,Default,,0,0,0,,So, all these operations satisfy\N the signature restriction;
Dialogue: 0,2:10:15.28,2:10:19.68,Default,,0,0,0,,and we can apply similar discussion\N to the 'fail' operation.
Dialogue: 0,2:10:19.68,2:10:26.20,Default,,0,0,0,,For the satisfied operations,\N this whole function or
Dialogue: 0,2:10:26.20,2:10:29.96,Default,,0,0,0,,this argument type\N may seem complicated,
Dialogue: 0,2:10:29.96,2:10:32.96,Default,,0,0,0,,but their priority\N checking is very easy.
Dialogue: 0,2:10:32.96,2:10:36.76,Default,,0,0,0,,We can easily find that this type,
Dialogue: 0,2:10:36.76,2:10:43.44,Default,,0,0,0,,the bound type variable alpha\N occurs only strictly positively.
Dialogue: 0,2:10:43.96,2:10:48.96,Default,,0,0,0,,So, 'satisfy' operation also\N follows the signature restriction.
Dialogue: 0,2:10:49.76,2:10:50.84,Default,,0,0,0,,And, as a result,
Dialogue: 0,2:10:50.84,2:10:54.40,Default,,0,0,0,,all of these three operations\N satisfy the signature restriction.
Dialogue: 0,2:10:54.40,2:10:58.68,Default,,0,0,0,,OK. So, this is our work.
Dialogue: 0,2:10:58.68,2:11:02.40,Default,,0,0,0,,But our work does not\N cover all useful features
Dialogue: 0,2:11:02.40,2:11:04.20,Default,,0,0,0,,in functional programming language.
Dialogue: 0,2:11:04.20,2:11:07.44,Default,,0,0,0,,For example, this work does\N not cover type inference
Dialogue: 0,2:11:07.44,2:11:11.88,Default,,0,0,0,,and general algebraic data types.
Dialogue: 0,2:11:11.88,2:11:18.16,Default,,0,0,0,,So, the support for these\N features is left as future work.
Dialogue: 0,2:11:18.16,2:11:26.56,Default,,0,0,0,,And we also consider studying\N a CPS transformation
Dialogue: 0,2:11:26.56,2:11:28.24,Default,,0,0,0,,for this restriction method
Dialogue: 0,2:11:28.24,2:11:32.68,Default,,0,0,0,,and applying the signature\N restriction to other user defined,
Dialogue: 0,2:11:33.36,2:11:36.20,Default,,0,0,0,,or user defined effect\N handler mechanisms such as the monads.
Dialogue: 0,2:11:36.20,2:11:41.48,Default,,0,0,0,,It should be interesting\N because you know.
Dialogue: 0,2:11:41.48,2:11:44.72,Default,,0,0,0,,OK, let me summarize this talk.
Dialogue: 0,2:11:44.72,2:11:48.12,Default,,0,0,0,,The problem we attack\N in this work is that,
Dialogue: 0,2:11:48.12,2:11:53.28,Default,,0,0,0,,naive combinations of\N algebraic effect handlers,
Dialogue: 0,2:11:53.28,2:11:56.16,Default,,0,0,0,,and polymorphism may be problematic.
Dialogue: 0,2:11:56.16,2:11:57.92,Default,,0,0,0,,To solve these problems,
Dialogue: 0,2:11:57.92,2:12:01.00,Default,,0,0,0,,we propose a signature restriction
Dialogue: 0,2:12:01.00,2:12:03.64,Default,,0,0,0,,which is a new approach to determine
Dialogue: 0,2:12:03.64,2:12:08.40,Default,,0,0,0,,safety of effect in\N a polymorphic setting.
Dialogue: 0,2:12:08.40,2:12:10.88,Default,,0,0,0,,The signature restriction\N rests only on
Dialogue: 0,2:12:10.88,2:12:13.60,Default,,0,0,0,,the properties of\N bound type variables.
Dialogue: 0,2:12:13.60,2:12:15.24,Default,,0,0,0,,So, it is very simple,
Dialogue: 0,2:12:15.24,2:12:20.24,Default,,0,0,0,,it just examines\N the signature of effect.
Dialogue: 0,2:12:20.76,2:12:25.76,Default,,0,0,0,,And it is still\N permissive and scalable.
Dialogue: 0,2:12:26.24,2:12:28.76,Default,,0,0,0,,We provide a simple type system
Dialogue: 0,2:12:28.76,2:12:30.76,Default,,0,0,0,,and prove its soundness
Dialogue: 0,2:12:30.76,2:12:34.64,Default,,0,0,0,,by assuming all effects satisfy\N the signature restriction
Dialogue: 0,2:12:34.64,2:12:39.64,Default,,0,0,0,,and which demonstrates qualities\N of signature restriction.
Dialogue: 0,2:12:40.24,2:12:43.16,Default,,0,0,0,,We also provide effects system
Dialogue: 0,2:12:43.16,2:12:48.24,Default,,0,0,0,,where both effects that satisfy
Dialogue: 0,2:12:48.24,2:12:53.08,Default,,0,0,0,,and don't satisfy the signature\N restriction can be used.
Dialogue: 0,2:12:53.08,2:12:54.08,Default,,0,0,0,,That's it,
Dialogue: 0,2:12:54.08,2:12:55.48,Default,,0,0,0,,thank you for listening.
Dialogue: 0,2:12:55.48,2:13:00.48,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,2:13:03.68,2:13:05.80,Default,,0,0,0,,STEPHANIE: Thank you Toro.
Dialogue: 0,2:13:05.80,2:13:07.88,Default,,0,0,0,,If you are watching\N this stream live,
Dialogue: 0,2:13:07.88,2:13:10.08,Default,,0,0,0,,don't forget about\N the Q&A session
Dialogue: 0,2:13:10.08,2:13:12.72,Default,,0,0,0,,that may be available\N in your time band
Dialogue: 0,2:13:12.72,2:13:17.80,Default,,0,0,0,,so that you can discuss this\N work with the authors.
Dialogue: 0,2:13:17.80,2:13:20.28,Default,,0,0,0,,This is the last paper\N in session four,
Dialogue: 0,2:13:20.28,2:13:25.28,Default,,0,0,0,,thank you for attending.
Dialogue: 0,2:14:22.28,2:14:27.28,Default,,0,0,0,,(SOFT INSTRUMENTAL MUSIC PLAYS)
