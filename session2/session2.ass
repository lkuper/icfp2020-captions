[Script Info]
; This is an Advanced Sub Station Alpha v4+ script.
Title: session2
ScriptType: v4.00+
Collisions: Normal
PlayDepth: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: Default,Arial,20,&H00FFFFFF,&H0300FFFF,&H00000000,&H02000000,0,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text
Dialogue: 0,0:00:55.96,0:01:00.64,Default,,0,0,0,,
Dialogue: 0,0:05:10.56,0:05:11.56,Default,,0,0,0,,
Dialogue: 0,0:06:08.28,0:06:13.28,Default,,0,0,0,,
Dialogue: 0,0:09:55.16,0:09:57.80,Default,,0,0,0,,
Dialogue: 0,0:10:38.64,0:10:43.64,Default,,0,0,0,,
Dialogue: 0,0:12:23.92,0:12:24.92,Default,,0,0,0,,
Dialogue: 0,0:12:59.84,0:13:00.96,Default,,0,0,0,,ALAN JEFFREY: Hello everybody.
Dialogue: 0,0:13:00.96,0:13:05.92,Default,,0,0,0,,And welcome to the second\Nsession of ICFP 2020.
Dialogue: 0,0:13:05.96,0:13:07.80,Default,,0,0,0,,You're joining us on YouTube,
Dialogue: 0,0:13:07.80,0:13:10.40,Default,,0,0,0,,and registered participants\Nfor the conference
Dialogue: 0,0:13:10.44,0:13:12.84,Default,,0,0,0,,can also join us in chat,
Dialogue: 0,0:13:12.96,0:13:15.28,Default,,0,0,0,,on the Clowdr system.
Dialogue: 0,0:13:15.32,0:13:19.16,Default,,0,0,0,,And also, if they want\Nto join a live Q&A,
Dialogue: 0,0:13:19.16,0:13:21.52,Default,,0,0,0,,with the authors, after the talk.
Dialogue: 0,0:13:21.56,0:13:23.60,Default,,0,0,0,,And so the first talk\Nfor the session,
Dialogue: 0,0:13:23.68,0:13:27.36,Default,,0,0,0,,is going to be achieving high\Nperformance the functional way,
Dialogue: 0,0:13:27.40,0:13:28.92,Default,,0,0,0,,and it'll be presented by,
Dialogue: 0,0:13:28.92,0:13:30.16,Default,,0,0,0,,Bastian Hagedorn.
Dialogue: 0,0:13:31.76,0:13:33.56,Default,,0,0,0,,BASTIAN: Hi, this Bastian Hagedorn,
Dialogue: 0,0:13:33.56,0:13:35.32,Default,,0,0,0,,from the university of MÃ¼nster,
Dialogue: 0,0:13:35.36,0:13:37.40,Default,,0,0,0,,and I'll be presenting\Na functional pearl,
Dialogue: 0,0:13:37.48,0:13:38.88,Default,,0,0,0,,on achieving high-performance,
Dialogue: 0,0:13:38.96,0:13:40.64,Default,,0,0,0,,the functional way.
Dialogue: 0,0:13:40.68,0:13:42.40,Default,,0,0,0,,This one's about expressing\Nhigh-performance
Dialogue: 0,0:13:42.48,0:13:45.72,Default,,0,0,0,,program optimizations,\Nas rewrite strategies.
Dialogue: 0,0:13:45.72,0:13:48.88,Default,,0,0,0,,This is joint work with colleagues\Nfrom the universities of Edinburgh
Dialogue: 0,0:13:48.96,0:13:49.96,Default,,0,0,0,,and Glasgow.
Dialogue: 0,0:13:51.52,0:13:53.40,Default,,0,0,0,,Let me begin with\Nasking the question,
Dialogue: 0,0:13:53.40,0:13:56.56,Default,,0,0,0,,why we care about high\Nperformance in the first place?
Dialogue: 0,0:13:56.56,0:13:58.12,Default,,0,0,0,,And the answer is quite simple,
Dialogue: 0,0:13:58.24,0:14:00.72,Default,,0,0,0,,We literally cannot afford not to.
Dialogue: 0,0:14:00.72,0:14:03.68,Default,,0,0,0,,Because apparently it cost\Nabout a quarter million dollars
Dialogue: 0,0:14:03.92,0:14:07.12,Default,,0,0,0,,to perform state of the art\Nmachine learning research.
Dialogue: 0,0:14:07.12,0:14:08.64,Default,,0,0,0,,And this high cost is mostly due to
Dialogue: 0,0:14:08.96,0:14:12.52,Default,,0,0,0,,the long time required to train neural\Nnetworks on parallel hardware.
Dialogue: 0,0:14:14.20,0:14:17.64,Default,,0,0,0,,It gets worse when you translate\Nthe dollar spent into carbon emitted.
Dialogue: 0,0:14:18.32,0:14:20.12,Default,,0,0,0,,So here, training\Nthis neural network,
Dialogue: 0,0:14:20.32,0:14:22.12,Default,,0,0,0,,releases about five tons of carbon
Dialogue: 0,0:14:22.12,0:14:23.12,Default,,0,0,0,,into the atmosphere,
Dialogue: 0,0:14:23.44,0:14:27.00,Default,,0,0,0,,which is equivalent to driving\N11,000 miles with a car.
Dialogue: 0,0:14:27.00,0:14:29.44,Default,,0,0,0,,And just to show you\Nhow insane it is,
Dialogue: 0,0:14:29.44,0:14:31.28,Default,,0,0,0,,here's a map showing a road trip,
Dialogue: 0,0:14:31.52,0:14:32.84,Default,,0,0,0,,from the North of Norway,
Dialogue: 0,0:14:32.92,0:14:34.96,Default,,0,0,0,,all the way down to South Africa.
Dialogue: 0,0:14:34.96,0:14:37.56,Default,,0,0,0,,Which corresponds to\Nroughly 11,000 miles.
Dialogue: 0,0:14:37.60,0:14:39.52,Default,,0,0,0,,So clearly, we need to find a way,
Dialogue: 0,0:14:39.52,0:14:40.68,Default,,0,0,0,,to reduce those costs,
Dialogue: 0,0:14:40.72,0:14:43.56,Default,,0,0,0,,and optimizing a program, to\Nachieve high performance.
Dialogue: 0,0:14:43.56,0:14:47.32,Default,,0,0,0,,Might allow us to significantly\Nreduce the time required to,
Dialogue: 0,0:14:47.32,0:14:48.32,Default,,0,0,0,,to, for example,
Dialogue: 0,0:14:48.32,0:14:49.64,Default,,0,0,0,,train neural networks.
Dialogue: 0,0:14:51.24,0:14:54.32,Default,,0,0,0,,So, how do we achieve\Nhigh performance?
Dialogue: 0,0:14:54.32,0:14:55.52,Default,,0,0,0,,Here's a naive implementation
Dialogue: 0,0:14:55.52,0:14:58.60,Default,,0,0,0,,of a matrix multiplication\Nand computation in CUDA,
Dialogue: 0,0:14:58.60,0:15:00.64,Default,,0,0,0,,which targets GPU's.
Dialogue: 0,0:15:00.64,0:15:03.12,Default,,0,0,0,,And if you know, a little\Nbit about CUDA and GPU's,
Dialogue: 0,0:15:03.12,0:15:04.12,Default,,0,0,0,,I'd argue that,
Dialogue: 0,0:15:04.12,0:15:07.00,Default,,0,0,0,,this is quite easy to\Nwrite and to understand.
Dialogue: 0,0:15:07.00,0:15:10.56,Default,,0,0,0,,But unfortunately, this\Nprogram is also not very fast.
Dialogue: 0,0:15:10.56,0:15:14.80,Default,,0,0,0,,So, for achieving the highest\Nperformance on modern GPU's,
Dialogue: 0,0:15:14.92,0:15:18.68,Default,,0,0,0,,the simple program has to\Nbe significantly modified.
Dialogue: 0,0:15:18.68,0:15:21.04,Default,,0,0,0,,So for example, here is\Nan optimized version,
Dialogue: 0,0:15:21.04,0:15:22.84,Default,,0,0,0,,of the same computation,
Dialogue: 0,0:15:22.84,0:15:26.68,Default,,0,0,0,,which achieves up to three orders\Nof magnitude more performance.
Dialogue: 0,0:15:26.68,0:15:29.36,Default,,0,0,0,,And if we compare this again\Nto our road trip example,
Dialogue: 0,0:15:29.36,0:15:30.52,Default,,0,0,0,,and the carbon emitted,
Dialogue: 0,0:15:30.52,0:15:31.92,Default,,0,0,0,,a thousand X improvement
Dialogue: 0,0:15:31.92,0:15:36.00,Default,,0,0,0,,barely allows us to drive\N15 minutes on the highway.
Dialogue: 0,0:15:36.00,0:15:39.16,Default,,0,0,0,,However, this manual way of\Nachieving high performance,
Dialogue: 0,0:15:39.16,0:15:40.88,Default,,0,0,0,,requires some expert to sit down,
Dialogue: 0,0:15:40.96,0:15:43.88,Default,,0,0,0,,for quite some time,\Nand to optimize the program,
Dialogue: 0,0:15:43.88,0:15:47.84,Default,,0,0,0,,in a time intensive\Nand incredibly error prone process.
Dialogue: 0,0:15:47.84,0:15:49.44,Default,,0,0,0,,So, another way,
Dialogue: 0,0:15:49.44,0:15:50.80,Default,,0,0,0,,to achieve high performance,
Dialogue: 0,0:15:50.96,0:15:53.52,Default,,0,0,0,,is what I call the decoupled way,
Dialogue: 0,0:15:53.52,0:15:57.56,Default,,0,0,0,,which was pioneered by the domain\Nspecific compiler called Halide.
Dialogue: 0,0:15:57.56,0:15:58.84,Default,,0,0,0,,And the key idea here,
Dialogue: 0,0:15:58.84,0:16:01.52,Default,,0,0,0,,is to decouple what\Nis being computed,
Dialogue: 0,0:16:01.52,0:16:03.84,Default,,0,0,0,,from how it is optimized.
Dialogue: 0,0:16:03.84,0:16:07.12,Default,,0,0,0,,So this allows a domain scientist,
Dialogue: 0,0:16:07.12,0:16:09.36,Default,,0,0,0,,to focus on implementing\Nthe computation,
Dialogue: 0,0:16:09.36,0:16:11.52,Default,,0,0,0,,which can then be\Nseparately optimized,
Dialogue: 0,0:16:11.52,0:16:13.16,Default,,0,0,0,,by a performance engineer,
Dialogue: 0,0:16:13.16,0:16:15.20,Default,,0,0,0,,with the so called schedule.
Dialogue: 0,0:16:15.20,0:16:16.96,Default,,0,0,0,,And this way of achieving\Nhigh performance,
Dialogue: 0,0:16:16.96,0:16:18.44,Default,,0,0,0,,is currently very popular,
Dialogue: 0,0:16:18.44,0:16:20.84,Default,,0,0,0,,there are many compilers\Nfollowing this approach.
Dialogue: 0,0:16:20.84,0:16:23.32,Default,,0,0,0,,So, this particular example here,
Dialogue: 0,0:16:23.32,0:16:27.04,Default,,0,0,0,,is taken from the TVM\Nmachine learning compiler,
Dialogue: 0,0:16:27.04,0:16:28.68,Default,,0,0,0,,which is currently\Nthe state of the art,
Dialogue: 0,0:16:28.68,0:16:31.80,Default,,0,0,0,,in generating high performance\Nmachine learning implementation.
Dialogue: 0,0:16:32.80,0:16:34.60,Default,,0,0,0,,TVM comes with a tutorial
Dialogue: 0,0:16:34.60,0:16:38.20,Default,,0,0,0,,on how to optimize matrix\Nmultiplications for CPU's.
Dialogue: 0,0:16:38.20,0:16:41.52,Default,,0,0,0,,And we'll take a closer\Nlook at that in a moment.
Dialogue: 0,0:16:43.08,0:16:46.68,Default,,0,0,0,,So the TVM compiler uses both\Nthe algorithm and the schedule,
Dialogue: 0,0:16:46.84,0:16:48.92,Default,,0,0,0,,to generate an efficient\Nimplementation.
Dialogue: 0,0:16:48.92,0:16:51.52,Default,,0,0,0,,So here, for example, we\Nsee the blocking version
Dialogue: 0,0:16:51.52,0:16:52.88,Default,,0,0,0,,from the TVM tutorial,
Dialogue: 0,0:16:52.92,0:16:56.32,Default,,0,0,0,,which applies some specific\Nloop transformations.
Dialogue: 0,0:16:56.32,0:16:58.32,Default,,0,0,0,,The best version presented\Nin this tutorial,
Dialogue: 0,0:16:58.32,0:17:00.84,Default,,0,0,0,,is about 200 times faster\Nthan the baseline,
Dialogue: 0,0:17:00.84,0:17:04.64,Default,,0,0,0,,but only requires to add a few\Nmore lines to the schedule,
Dialogue: 0,0:17:04.64,0:17:06.68,Default,,0,0,0,,or at least that's the idea.
Dialogue: 0,0:17:06.68,0:17:09.72,Default,,0,0,0,,So when you take\Na closer look at this,
Dialogue: 0,0:17:09.72,0:17:11.32,Default,,0,0,0,,the schedule based approach,
Dialogue: 0,0:17:11.32,0:17:13.24,Default,,0,0,0,,you'll find a few problems.
Dialogue: 0,0:17:13.24,0:17:15.64,Default,,0,0,0,,One of the first few\Nthings you might find is that
Dialogue: 0,0:17:15.64,0:17:19.00,Default,,0,0,0,,the algorithm and\Nthe schedule are not fully separated.
Dialogue: 0,0:17:19.00,0:17:22.04,Default,,0,0,0,,Here, the schedule uses\Nthe same python identifiers,
Dialogue: 0,0:17:22.04,0:17:24.12,Default,,0,0,0,,that have been declared\Nin the algorithm.
Dialogue: 0,0:17:24.12,0:17:25.40,Default,,0,0,0,,And that simply means that,
Dialogue: 0,0:17:25.40,0:17:27.12,Default,,0,0,0,,both the algorithm and the schedule
Dialogue: 0,0:17:27.12,0:17:28.92,Default,,0,0,0,,have to live in the same scope,
Dialogue: 0,0:17:28.92,0:17:31.40,Default,,0,0,0,,and that hinders\Nthe re-use of the schedule,
Dialogue: 0,0:17:31.40,0:17:34.88,Default,,0,0,0,,for optimizing\Na different computation.
Dialogue: 0,0:17:34.88,0:17:37.68,Default,,0,0,0,,The next problem is that there's\Nno well-defined semantics,
Dialogue: 0,0:17:37.68,0:17:39.64,Default,,0,0,0,,for the scheduling primitives.
Dialogue: 0,0:17:39.64,0:17:41.48,Default,,0,0,0,,So there's only\Na documentation online,
Dialogue: 0,0:17:41.48,0:17:42.92,Default,,0,0,0,,And for some primitives,
Dialogue: 0,0:17:42.92,0:17:45.96,Default,,0,0,0,,this is quite cryptic\Nand basically requires,
Dialogue: 0,0:17:45.96,0:17:48.60,Default,,0,0,0,,knowledge of how the compiler\Ninternally implements
Dialogue: 0,0:17:48.60,0:17:50.68,Default,,0,0,0,,the scheduling primitives.
Dialogue: 0,0:17:50.68,0:17:54.04,Default,,0,0,0,,And finally, all scheduling\Nprimitives are built in,
Dialogue: 0,0:17:54.04,0:17:56.32,Default,,0,0,0,,which makes them hard to extend.
Dialogue: 0,0:17:56.32,0:17:57.84,Default,,0,0,0,,So typically every  primitive,
Dialogue: 0,0:17:57.84,0:17:59.24,Default,,0,0,0,,like tile or vectorize,
Dialogue: 0,0:17:59.24,0:18:00.96,Default,,0,0,0,,represents a common\Noptimization,
Dialogue: 0,0:18:00.96,0:18:02.72,Default,,0,0,0,,you might want to apply,
Dialogue: 0,0:18:02.72,0:18:04.88,Default,,0,0,0,,but as soon as you need\Nsomething slightly different
Dialogue: 0,0:18:04.88,0:18:05.88,Default,,0,0,0,,you're in trouble.
Dialogue: 0,0:18:05.88,0:18:09.16,Default,,0,0,0,,Because, there's no easy way to extend\Nthe set of exposed optimizations
Dialogue: 0,0:18:09.16,0:18:12.48,Default,,0,0,0,,besides digging deep into\Nthe implementation of the compiler itself.
Dialogue: 0,0:18:12.52,0:18:16.32,Default,,0,0,0,,And this is something we\Ndon't often want to do.
Dialogue: 0,0:18:17.44,0:18:20.20,Default,,0,0,0,,So, this is why with our\Nfunctional approach,
Dialogue: 0,0:18:20.20,0:18:21.72,Default,,0,0,0,,we aim for a more principled way,
Dialogue: 0,0:18:21.72,0:18:25.04,Default,,0,0,0,,to describe and apply high-performance\Nprogram optimizations.
Dialogue: 0,0:18:26.20,0:18:29.72,Default,,0,0,0,,Specifically, we aim\Nto separate concerns, by
Dialogue: 0,0:18:30.16,0:18:32.28,Default,,0,0,0,,specifying computation at\Na high abstraction level only,
Dialogue: 0,0:18:32.28,0:18:36.84,Default,,0,0,0,,without changing them for\Nexpressing optimizations.
Dialogue: 0,0:18:37.00,0:18:41.16,Default,,0,0,0,,We aim to facilitate reuse by\Ndefining optimization strategies,
Dialogue: 0,0:18:41.16,0:18:44.28,Default,,0,0,0,,clearly separated from\Nthe computations.
Dialogue: 0,0:18:44.28,0:18:48.00,Default,,0,0,0,,We aim to enable composability\Nby allowing to define both
Dialogue: 0,0:18:48.00,0:18:50.92,Default,,0,0,0,,computations and optimizations\Nas compositions of
Dialogue: 0,0:18:50.92,0:18:54.68,Default,,0,0,0,,user defined building blocks.\NWe aim to allow reasoning by
Dialogue: 0,0:18:54.68,0:18:57.28,Default,,0,0,0,,giving those building blocks\Nwell-defined semantics.
Dialogue: 0,0:18:57.28,0:19:00.72,Default,,0,0,0,,And finally, we aim to be\Nexplicit and avoid all implicit
Dialogue: 0,0:19:00.72,0:19:02.60,Default,,0,0,0,,default behavior of the compiler.
Dialogue: 0,0:19:02.96,0:19:05.52,Default,,0,0,0,,And essentially we argue that\Na strategy language should
Dialogue: 0,0:19:05.52,0:19:07.84,Default,,0,0,0,,be built with the same\Nstandards as a language
Dialogue: 0,0:19:07.84,0:19:12.40,Default,,0,0,0,,describing the computation. Now,\Nlet me show you the functional,
Dialogue: 0,0:19:12.40,0:19:14.88,Default,,0,0,0,,way of achieving\Nhigh performance.
Dialogue: 0,0:19:15.32,0:19:18.16,Default,,0,0,0,,In our approach we follow\Nthe same idea of decoupling
Dialogue: 0,0:19:18.16,0:19:22.20,Default,,0,0,0,,computations and optimizations,\Nbut we're using the well established
Dialogue: 0,0:19:22.20,0:19:25.76,Default,,0,0,0,,functional programming\Ntechniques to express both.
Dialogue: 0,0:19:25.92,0:19:29.36,Default,,0,0,0,,So on the top left, we have a high\Nlevel program that is written in
Dialogue: 0,0:19:29.36,0:19:31.20,Default,,0,0,0,,the functional programming\Nlanguage called RISE.
Dialogue: 0,0:19:31.20,0:19:34.76,Default,,0,0,0,,That is based on\Nthe ICFP paper from 2015.
Dialogue: 0,0:19:35.04,0:19:38.52,Default,,0,0,0,,And on the right, you see\Nan optimization strategy that describes
Dialogue: 0,0:19:38.52,0:19:42.44,Default,,0,0,0,,how to optimize that RISE program.\NAnd this is written in Elevate,
Dialogue: 0,0:19:42.44,0:19:46.08,Default,,0,0,0,,which is based on ideas already\Npublished in the late nineties.
Dialogue: 0,0:19:47.20,0:19:50.80,Default,,0,0,0,,Our compiler then rewrites\Nthe RISE program based on the
Dialogue: 0,0:19:50.80,0:19:53.56,Default,,0,0,0,,optimizations described in\Nthe Elevate strategy and
Dialogue: 0,0:19:53.56,0:19:56.44,Default,,0,0,0,,eventually generates\Nhigh performance code.
Dialogue: 0,0:19:57.00,0:19:59.88,Default,,0,0,0,,Our functional pearl is all\Nabout how to express the high
Dialogue: 0,0:19:59.88,0:20:03.00,Default,,0,0,0,,performance optimizations\Ntypically applied manually or
Dialogue: 0,0:20:03.00,0:20:05.28,Default,,0,0,0,,using the schedule based approach.
Dialogue: 0,0:20:05.60,0:20:08.88,Default,,0,0,0,,However, as composable\Nrewrites strategies instead.
Dialogue: 0,0:20:10.28,0:20:13.52,Default,,0,0,0,,Alright, let's see how we do\Nthis and we'll start by taking
Dialogue: 0,0:20:13.52,0:20:15.64,Default,,0,0,0,,a closer look at\NElevate our language
Dialogue: 0,0:20:15.64,0:20:18.28,Default,,0,0,0,,for describing the optimizations.
Dialogue: 0,0:20:18.44,0:20:22.48,Default,,0,0,0,,The most basic building block\Nin Elevate is a strategy and
Dialogue: 0,0:20:22.48,0:20:25.44,Default,,0,0,0,,a strategy is simply a function\Nfrom some program P to what
Dialogue: 0,0:20:25.44,0:20:29.80,Default,,0,0,0,,we call a RewriteResult and\Na RewriteResult is simply saying
Dialogue: 0,0:20:29.80,0:20:33.44,Default,,0,0,0,,whether the applied strategy\Nsucceeded in which case it contains
Dialogue: 0,0:20:33.44,0:20:36.84,Default,,0,0,0,,the rewritten program,\Nor it failed in which case it
Dialogue: 0,0:20:36.84,0:20:39.32,Default,,0,0,0,,contained the strategy,\Nwhich failed.
Dialogue: 0,0:20:39.52,0:20:42.32,Default,,0,0,0,,Rewrite rules are examples\Nfor very simple strategies.
Dialogue: 0,0:20:42.32,0:20:44.52,Default,,0,0,0,,And you could, for example,\Ngo ahead and implement
Dialogue: 0,0:20:44.52,0:20:49.04,Default,,0,0,0,,the typical fusion rule for RISE\Nprograms as an Elevate strategy.
Dialogue: 0,0:20:49.04,0:20:52.48,Default,,0,0,0,,As you see on the bottom. This\Nrule simply says that whenever
Dialogue: 0,0:20:52.48,0:20:55.48,Default,,0,0,0,,you see a RISE program that\Ncontains two consecutive maps,
Dialogue: 0,0:20:55.48,0:20:58.48,Default,,0,0,0,,you can fuse those maps\Nand return the fused program,
Dialogue: 0,0:20:58.48,0:21:00.76,Default,,0,0,0,,and if there are no\Nconsecutive two maps,
Dialogue: 0,0:21:00.76,0:21:03.96,Default,,0,0,0,,then this rule is simply not\Napplicable and it fails.
Dialogue: 0,0:21:05.24,0:21:08.72,Default,,0,0,0,,For building more powerful strategies,\Nwe can combine tools
Dialogue: 0,0:21:08.72,0:21:11.48,Default,,0,0,0,,and Elevate using several\Ndifferent combinators.
Dialogue: 0,0:21:11.64,0:21:14.60,Default,,0,0,0,,So for example,\Nthe sequence combinator allows
Dialogue: 0,0:21:14.60,0:21:17.16,Default,,0,0,0,,to apply two strategies in sequence.
Dialogue: 0,0:21:17.48,0:21:21.20,Default,,0,0,0,,The left choice operator\Nexpects also two strategies,
Dialogue: 0,0:21:21.20,0:21:24.52,Default,,0,0,0,,but only applies the second one\Nin case the first one fails.
Dialogue: 0,0:21:24.88,0:21:28.52,Default,,0,0,0,,The try combinator tries to\Napply the given strategy and
Dialogue: 0,0:21:28.52,0:21:30.84,Default,,0,0,0,,if it is not applicable, it's\Nsimply returns the unchanged
Dialogue: 0,0:21:30.84,0:21:33.80,Default,,0,0,0,,input program by applying\Nthe ID strategy.
Dialogue: 0,0:21:33.80,0:21:38.16,Default,,0,0,0,,And finally, the repeat strategy\Nallows us to repetitively apply
Dialogue: 0,0:21:38.16,0:21:41.24,Default,,0,0,0,,the same strategy until it\Nis no longer applicable.
Dialogue: 0,0:21:42.04,0:21:44.88,Default,,0,0,0,,Now, what if we have\Nthe following situation.
Dialogue: 0,0:21:45.12,0:21:48.12,Default,,0,0,0,,Here you see a RISE program\Nthat contains three maps.
Dialogue: 0,0:21:48.12,0:21:51.60,Default,,0,0,0,,And if we now want to apply\Nthe mapfusion rule, we have just defined,
Dialogue: 0,0:21:51.60,0:21:54.52,Default,,0,0,0,,there are two possible\Nlocations for fusing the maps.
Dialogue: 0,0:21:54.52,0:21:57.88,Default,,0,0,0,,So we can either use the first\Ntwo or the last two maps.
Dialogue: 0,0:21:58.24,0:22:01.12,Default,,0,0,0,,And with elevate, you can\Nprecisely define locations in
Dialogue: 0,0:22:01.12,0:22:03.92,Default,,0,0,0,,the AST using so-called traversals.
Dialogue: 0,0:22:04.08,0:22:07.32,Default,,0,0,0,,So for example, the body traversal\Napplies a given strategy at
Dialogue: 0,0:22:07.32,0:22:09.44,Default,,0,0,0,,the body of a function\Nabstraction mode.
Dialogue: 0,0:22:09.44,0:22:13.76,Default,,0,0,0,,And in this example, body\Nmapfusion would then fuse the
Dialogue: 0,0:22:13.76,0:22:16.16,Default,,0,0,0,,first two maps as we've seen here.
Dialogue: 0,0:22:16.52,0:22:19.48,Default,,0,0,0,,Similarly, we define traversals\Nfor the other nodes and
Dialogue: 0,0:22:19.48,0:22:22.80,Default,,0,0,0,,could for example, apply\Nbody(argument(mapFusion)),
Dialogue: 0,0:22:22.80,0:22:26.44,Default,,0,0,0,,for fusing the last two maps in\Nthis expression and in the paper,
Dialogue: 0,0:22:26.44,0:22:29.32,Default,,0,0,0,,we explained in more detail how\Nto describe precise locations
Dialogue: 0,0:22:29.32,0:22:31.96,Default,,0,0,0,,using these and other traversals.
Dialogue: 0,0:22:32.36,0:22:35.76,Default,,0,0,0,,Sometimes it's not desirable\Nto specify a precise path,
Dialogue: 0,0:22:35.76,0:22:38.84,Default,,0,0,0,,but instead we might want to\Nsay something like apply this
Dialogue: 0,0:22:38.84,0:22:41.32,Default,,0,0,0,,given strategy at\Nthe first place you'll find,
Dialogue: 0,0:22:41.32,0:22:44.92,Default,,0,0,0,,and this is what bottom\Nup or top down do.
Dialogue: 0,0:22:44.92,0:22:49.24,Default,,0,0,0,,So these traversal strategies,\Ntraverse the AST either like from top
Dialogue: 0,0:22:49.24,0:22:52.24,Default,,0,0,0,,down or bottom up\Nand apply the given strategy
Dialogue: 0,0:22:52.24,0:22:55.68,Default,,0,0,0,,at the first place where it's\Napplicable and then stop.
Dialogue: 0,0:22:56.52,0:22:59.56,Default,,0,0,0,,Another useful traversal is\Nthe normalized strategy,
Dialogue: 0,0:22:59.56,0:23:02.60,Default,,0,0,0,,which applies a given strategy\Nexhaustively until it is no longer
Dialogue: 0,0:23:02.60,0:23:05.28,Default,,0,0,0,,applicable anywhere in\Nthe give expression.
Dialogue: 0,0:23:05.28,0:23:08.80,Default,,0,0,0,,And in the paper we define a few\Nnormal forms for RISE expressions.
Dialogue: 0,0:23:08.80,0:23:11.44,Default,,0,0,0,,And one simple example\Nfor one of those is
Dialogue: 0,0:23:11.44,0:23:14.68,Default,,0,0,0,,the beta eta-normal form, which\Nsimply applies beta reduction
Dialogue: 0,0:23:14.68,0:23:17.60,Default,,0,0,0,,and eta reduction\Nas often as possible.
Dialogue: 0,0:23:18.12,0:23:21.28,Default,,0,0,0,,Using those generic building\Nblocks, we then try to implement
Dialogue: 0,0:23:21.28,0:23:24.64,Default,,0,0,0,,TVM scheduling language\Nand try to especially define
Dialogue: 0,0:23:24.64,0:23:27.64,Default,,0,0,0,,Elevate strategies that\Napply the same optimizations
Dialogue: 0,0:23:27.64,0:23:31.76,Default,,0,0,0,,as describing the TVM tutorial,\Nwhich we've mentioned earlier.
Dialogue: 0,0:23:32.28,0:23:34.60,Default,,0,0,0,,So here's what the baseline\Nversion looks like.
Dialogue: 0,0:23:34.60,0:23:37.80,Default,,0,0,0,,And for TVM, we described\Nthe matrix multiplication using
Dialogue: 0,0:23:37.80,0:23:40.88,Default,,0,0,0,,the python and API and use\Nthe default schedule
Dialogue: 0,0:23:40.88,0:23:43.36,Default,,0,0,0,,to generate unoptimized code.
Dialogue: 0,0:23:43.88,0:23:46.88,Default,,0,0,0,,For our functional way, we describe\Nthe matrix multiplication
Dialogue: 0,0:23:46.88,0:23:50.00,Default,,0,0,0,,computation using RISE\Nand its functional array
Dialogue: 0,0:23:50.00,0:23:51.76,Default,,0,0,0,,primitives like\Nmap and reduce.
Dialogue: 0,0:23:51.76,0:23:54.84,Default,,0,0,0,,And we define a separate\Nstrategy in Elevate,
Dialogue: 0,0:23:54.84,0:23:58.56,Default,,0,0,0,,which explains how to\Noptimize this computation.
Dialogue: 0,0:23:58.96,0:24:01.64,Default,,0,0,0,,And here we can already see that\Nwe have a clear separation
Dialogue: 0,0:24:01.64,0:24:04.20,Default,,0,0,0,,between the computation\Nand the optimization.
Dialogue: 0,0:24:04.48,0:24:09.36,Default,,0,0,0,,More crucially TVM's default\Nstrategy implicitly describes
Dialogue: 0,0:24:09.36,0:24:12.48,Default,,0,0,0,,some way of lowering\Nthe program to executable code.
Dialogue: 0,0:24:12.48,0:24:15.60,Default,,0,0,0,,And we don't really know\Nhow this is performed.
Dialogue: 0,0:24:15.92,0:24:19.28,Default,,0,0,0,,With our approach, we aim to\Ncompletely avoid implicit behavior
Dialogue: 0,0:24:19.28,0:24:22.24,Default,,0,0,0,,and describe every\Ntransformation explicitly.
Dialogue: 0,0:24:22.60,0:24:25.12,Default,,0,0,0,,So here, we're simply saying\Nthat the dot product should
Dialogue: 0,0:24:25.12,0:24:28.16,Default,,0,0,0,,be computed using a single\Nstatement, by fusing the map and
Dialogue: 0,0:24:28.16,0:24:32.32,Default,,0,0,0,,the reduce pattern, similar to\Nhow TVM computes the dot product.
Dialogue: 0,0:24:32.96,0:24:35.44,Default,,0,0,0,,This way we implemented each of the
Dialogue: 0,0:24:35.44,0:24:37.36,Default,,0,0,0,,seven differently optimized versions.
Dialogue: 0,0:24:37.36,0:24:40.40,Default,,0,0,0,,And in the paper we described,\Nfor example, how to implement
Dialogue: 0,0:24:40.40,0:24:43.56,Default,,0,0,0,,TVMs built-in tile\Noptimization as a composition
Dialogue: 0,0:24:43.56,0:24:46.36,Default,,0,0,0,,of only a few rewrite rules\Nand the combinators and
Dialogue: 0,0:24:46.36,0:24:50.36,Default,,0,0,0,,traversals we've just seen.\NAlso our functional approach
Dialogue: 0,0:24:50.36,0:24:52.60,Default,,0,0,0,,allows us to define\Nthe different optimized versions
Dialogue: 0,0:24:52.60,0:24:55.88,Default,,0,0,0,,as reusable strategies.\NSo here, for example,
Dialogue: 0,0:24:55.88,0:24:57.88,Default,,0,0,0,,we define the loop perms strategy,
Dialogue: 0,0:24:57.88,0:25:02.00,Default,,0,0,0,,which we will reuse in\Nthe following more optimized versions.
Dialogue: 0,0:25:02.72,0:25:05.40,Default,,0,0,0,,This is the most optimized\Nversion implemented
Dialogue: 0,0:25:05.40,0:25:07.32,Default,,0,0,0,,in both TVM and our approach.
Dialogue: 0,0:25:07.32,0:25:10.32,Default,,0,0,0,,And here you can see that\Nwe are able to reuse and
Dialogue: 0,0:25:10.32,0:25:12.44,Default,,0,0,0,,to build upon\Nthe loop perm strategy,
Dialogue: 0,0:25:12.44,0:25:15.92,Default,,0,0,0,,whereas in TVM we always have to\Ndescribe the whole optimization
Dialogue: 0,0:25:15.92,0:25:19.88,Default,,0,0,0,,from scratch because we cannot\Neasily define our own abstractions.
Dialogue: 0,0:25:19.88,0:25:23.68,Default,,0,0,0,,One crucial problem is also that\Nthe TVM algorithm has to be
Dialogue: 0,0:25:23.68,0:25:27.20,Default,,0,0,0,,changed a few times during\Nthe tutorial because the scheduling
Dialogue: 0,0:25:27.20,0:25:28.92,Default,,0,0,0,,language is not powerful enough
Dialogue: 0,0:25:28.92,0:25:31.52,Default,,0,0,0,,to express all desirable\Noptimizations.
Dialogue: 0,0:25:31.84,0:25:35.32,Default,,0,0,0,,Our approach with RISE and Elevate\Ndoes not require us to do so.
Dialogue: 0,0:25:35.32,0:25:39.12,Default,,0,0,0,,And we use the same RISE matrix\Nmultiplication that is optimized
Dialogue: 0,0:25:39.12,0:25:42.64,Default,,0,0,0,,by seven different\Nand separate Elevate strategies.
Dialogue: 0,0:25:43.40,0:25:46.20,Default,,0,0,0,,To evaluate our approach,\Nwe look at two things.
Dialogue: 0,0:25:46.20,0:25:51.92,Default,,0,0,0,,So in the first experiment,\Nwe simply counted the number of
Dialogue: 0,0:25:51.96,0:25:55.24,Default,,0,0,0,,successful rewrite steps per\Nversion, which you can see here.
Dialogue: 0,0:25:55.24,0:25:58.80,Default,,0,0,0,,And since the baseline version\Ndoes not perform any interesting
Dialogue: 0,0:25:58.80,0:26:03.28,Default,,0,0,0,,transformations it only\Nrequires a few rewrite steps.
Dialogue: 0,0:26:03.28,0:26:06.80,Default,,0,0,0,,But as soon as we're performing\Nactual program optimizations,
Dialogue: 0,0:26:06.80,0:26:10.44,Default,,0,0,0,,we reach about yeah,\N45,000 and
Dialogue: 0,0:26:10.44,0:26:13.40,Default,,0,0,0,,later up to 62,000\Nseparate rewrites steps.
Dialogue: 0,0:26:13.68,0:26:16.24,Default,,0,0,0,,And this shows that our\Napproach is scalable because
Dialogue: 0,0:26:16.24,0:26:19.12,Default,,0,0,0,,we were able to define\Nthe complex TVM like optimizations
Dialogue: 0,0:26:19.12,0:26:22.56,Default,,0,0,0,,by simply composing a few\Nrewrite rules using Elevate.
Dialogue: 0,0:26:22.84,0:26:26.28,Default,,0,0,0,,Also performing this many steps\Ntook less than two seconds
Dialogue: 0,0:26:26.28,0:26:30.04,Default,,0,0,0,,per version on a regular notebook.\NSo this is no bottleneck.
Dialogue: 0,0:26:30.44,0:26:33.68,Default,,0,0,0,,Obviously we also wanted to see\Nif the performance we achieve
Dialogue: 0,0:26:33.68,0:26:35.60,Default,,0,0,0,,with our functional way\Nmatches the performance
Dialogue: 0,0:26:35.60,0:26:38.84,Default,,0,0,0,,achieved by the TVM compiler.\NAnd here you see the performance
Dialogue: 0,0:26:38.84,0:26:41.88,Default,,0,0,0,,achieved for each of\Nthe seven different versions and
Dialogue: 0,0:26:41.88,0:26:44.12,Default,,0,0,0,,you'll find that we are able\Nto achieve a similar trend,
Dialogue: 0,0:26:44.12,0:26:46.52,Default,,0,0,0,,which means that our\NElevate strategies encode
Dialogue: 0,0:26:46.52,0:26:49.68,Default,,0,0,0,,the same high performance\Nprogram optimizations as applied
Dialogue: 0,0:26:49.68,0:26:52.28,Default,,0,0,0,,by the state of\Nthe art TVM compiler.
Dialogue: 0,0:26:52.64,0:26:55.88,Default,,0,0,0,,And if you would like to find out\Nmore about a functional way of
Dialogue: 0,0:26:55.88,0:26:58.28,Default,,0,0,0,,achieving high performance,\Nsimply contact us and
Dialogue: 0,0:26:58.28,0:27:00.68,Default,,0,0,0,,have a look at our\Npaper and with this,
Dialogue: 0,0:27:00.68,0:27:02.12,Default,,0,0,0,,I'd like to end the presentation
Dialogue: 0,0:27:02.12,0:27:04.48,Default,,0,0,0,,and mention that you can find\Nall our implementations
Dialogue: 0,0:27:04.48,0:27:08.28,Default,,0,0,0,,online or in the artifact.\NThanks for your attention.
Dialogue: 0,0:27:08.28,0:27:18.68,Default,,0,0,0,,(CLAPS)\NALAN JEFFREY: So thank you, Bastian.
Dialogue: 0,0:27:18.68,0:27:24.56,Default,,0,0,0,,So for anybody who is wanting to join\Nthe authors for the live Q&A,
Dialogue: 0,0:27:24.64,0:27:29.64,Default,,0,0,0,,you can click on the link that's\Nin the Clowdr page for this talk.
Dialogue: 0,0:27:59.44,0:28:04.28,Default,,0,0,0,,Our next paper in the second\Nsession of ICFP 2020,
Dialogue: 0,0:28:04.28,0:28:08.12,Default,,0,0,0,,is going to be Staged selective\Nparser combinators and
Dialogue: 0,0:28:08.12,0:28:12.68,Default,,0,0,0,,it's going to be presented by\NJamie Willis and Nick Wu.
Dialogue: 0,0:28:18.28,0:28:22.52,Default,,0,0,0,,JAMIE: Hello? Can you hear me?\NNICK: Hello? Yeah, I can hear you.
Dialogue: 0,0:28:22.52,0:28:26.16,Default,,0,0,0,,JAMIE: Nice. I can hear you too.\NNICK: So I don't know if we've met.
Dialogue: 0,0:28:26.16,0:28:28.48,Default,,0,0,0,,My name is Nick Wu. I'm from\NImperial college London.
Dialogue: 0,0:28:28.48,0:28:31.04,Default,,0,0,0,,JAMIE: Oh, Hey, I'm Jamie\NWillis. I'm also from Imperial.
Dialogue: 0,0:28:31.04,0:28:34.08,Default,,0,0,0,,NICK: Oh, what a coincidence.\NIt's strange doing an
Dialogue: 0,0:28:34.08,0:28:36.08,Default,,0,0,0,,online conference with\Nprerecord videos. Isn't it?
Dialogue: 0,0:28:36.08,0:28:39.08,Default,,0,0,0,,JAMIE: Yeah. ICFP is\Ninteresting this year.
Dialogue: 0,0:28:39.08,0:28:42.44,Default,,0,0,0,,I wonder if anyone's made the most\Nof it in their presentation somehow.
Dialogue: 0,0:28:42.44,0:28:45.04,Default,,0,0,0,,NICK: Indeed. So what\Nare you working on?
Dialogue: 0,0:28:45.04,0:28:46.76,Default,,0,0,0,,JAMIE: I've been\Nworking with parsers.
Dialogue: 0,0:28:46.76,0:28:49.20,Default,,0,0,0,,NICK: Oh, nice. I'm a big\Nfan of parser combinators.
Dialogue: 0,0:28:49.20,0:28:51.84,Default,,0,0,0,,JAMIE: What are those?\NNICK: Oh, well, they're a way of building
Dialogue: 0,0:28:51.84,0:28:54.32,Default,,0,0,0,,a parse that follows\Nthe structure of a grammar closely
Dialogue: 0,0:28:54.32,0:28:57.16,Default,,0,0,0,,by treating parses as first\Nclass values and building
Dialogue: 0,0:28:57.16,0:28:59.36,Default,,0,0,0,,larger parsers from smaller ones.
Dialogue: 0,0:28:59.36,0:29:01.28,Default,,0,0,0,,JAMIE: Right. Can I have an example?
Dialogue: 0,0:29:01.28,0:29:04.12,Default,,0,0,0,,NICK: Let's look at the BNF for\Na language that recognizes
Dialogue: 0,0:29:04.12,0:29:06.88,Default,,0,0,0,,strings of characters. Let's\Nsuppose that they're non-empty.
Dialogue: 0,0:29:06.88,0:29:12.24,Default,,0,0,0,,So here's some code the non\Nterminal alpha is the choice of
Dialogue: 0,0:29:12.32,0:29:16.12,Default,,0,0,0,,letters from A to Z and alphas\Nconsists of what of those followed
Dialogue: 0,0:29:16.12,0:29:19.44,Default,,0,0,0,,either by more alphas or by\Nabsent on the empty token.
Dialogue: 0,0:29:19.44,0:29:21.72,Default,,0,0,0,,JAMIE: Okay. So how'd you\Nactually write the parsers then.
Dialogue: 0,0:29:21.72,0:29:24.72,Default,,0,0,0,,NICK: Right? And so in Haskell\Nalpha is a value
Dialogue: 0,0:29:24.72,0:29:27.56,Default,,0,0,0,,of type parser char since\Nit pauses a character.
Dialogue: 0,0:29:27.56,0:29:31.60,Default,,0,0,0,,And here we simply give\Nthe alternative between each of the chars.
Dialogue: 0,0:29:31.60,0:29:35.56,Default,,0,0,0,,The alphas parser returns a list of\Nchars by first parsing an alpha,
Dialogue: 0,0:29:35.56,0:29:37.40,Default,,0,0,0,,and then appending it to the results
Dialogue: 0,0:29:37.40,0:29:39.76,Default,,0,0,0,,of more alphas\Nor just the empty list.
Dialogue: 0,0:29:39.76,0:29:43.32,Default,,0,0,0,,JAMIE: Right. So how does that\Nstrange cons thing work?
Dialogue: 0,0:29:43.32,0:29:47.80,Default,,0,0,0,,NICK: Okay. So parsers are applictive\Nso we can lift normal functions
Dialogue: 0,0:29:47.80,0:29:51.16,Default,,0,0,0,,and constructors like cons\Nso that they can work on parsers.
Dialogue: 0,0:29:51.16,0:29:54.28,Default,,0,0,0,,So here the pure cons\Njust makes the function
Dialogue: 0,0:29:54.28,0:29:58.36,Default,,0,0,0,,work at the parser level. And then\Nthe app, which is the star will
Dialogue: 0,0:29:58.36,0:30:02.20,Default,,0,0,0,,ensure that Px is parsed\Nfirst followed by Pxs.
Dialogue: 0,0:30:02.20,0:30:04.64,Default,,0,0,0,,And then it's put\Ntogether with cons.
Dialogue: 0,0:30:04.64,0:30:06.72,Default,,0,0,0,,JAMIE: That doesn't seem like\Nsomething you can execute.
Dialogue: 0,0:30:06.72,0:30:09.80,Default,,0,0,0,,NICK: Well, if you want to\Nactually run one of these parsers
Dialogue: 0,0:30:09.80,0:30:14.12,Default,,0,0,0,,on an input string Xs, then you\Nuse the run parser function that
Dialogue: 0,0:30:14.12,0:30:17.48,Default,,0,0,0,,will take the string and return\Nthe parse result if it can.
Dialogue: 0,0:30:17.48,0:30:20.24,Default,,0,0,0,,JAMIE: Right. So those combinators\Nseem really verbose
Dialogue: 0,0:30:20.24,0:30:24.32,Default,,0,0,0,,I usually just use EBNF like this,\Nwhere you'd use a character class
Dialogue: 0,0:30:24.32,0:30:26.68,Default,,0,0,0,,and a plus, and it gets\Nrid of a lot of the bloat.
Dialogue: 0,0:30:26.68,0:30:29.52,Default,,0,0,0,,NICK: Yeah, sure. That makes\Nsense. Well, you can also do
Dialogue: 0,0:30:29.52,0:30:33.76,Default,,0,0,0,,this with combinators as well.\NHere's what you do with alphas.
Dialogue: 0,0:30:33.76,0:30:37.40,Default,,0,0,0,,We're using one of which will\Ntake one of the A to Z in
Dialogue: 0,0:30:37.40,0:30:39.20,Default,,0,0,0,,the ranges you've done. And the plus
Dialogue: 0,0:30:39.20,0:30:41.44,Default,,0,0,0,,says that you simply\Nwant some of those.
Dialogue: 0,0:30:41.44,0:30:44.92,Default,,0,0,0,,JAMIE: Ah, that's neat. Okay. So\Nhow are oneOf and some implemented?
Dialogue: 0,0:30:44.92,0:30:48.44,Default,,0,0,0,,NICK: Well, there also in terms of\Nsimple Combinators oneOf is,
Dialogue: 0,0:30:48.44,0:30:52.60,Default,,0,0,0,,in terms of the primitive satisfy\Nand satisfy takes a primitive,
Dialogue: 0,0:30:52.60,0:30:56.12,Default,,0,0,0,,takes a predicate and accepts\Nan input character that satisfies it.
Dialogue: 0,0:30:56.12,0:31:00.04,Default,,0,0,0,,For oneOf we simply want it to be\Nan element of a given list Cs.
Dialogue: 0,0:31:00.04,0:31:02.04,Default,,0,0,0,,Some can actually be\Nimplemented in terms of
Dialogue: 0,0:31:02.04,0:31:04.32,Default,,0,0,0,,what we've seen\Nso far. Can you see how?
Dialogue: 0,0:31:04.32,0:31:08.44,Default,,0,0,0,,JAMIE: Sure. Let me see. I think\Nif I took the alphas example,
Dialogue: 0,0:31:08.44,0:31:12.76,Default,,0,0,0,,I could reverse engineer it. So\NI guess if I factor this alpha out
Dialogue: 0,0:31:12.76,0:31:14.52,Default,,0,0,0,,then that would give me some,
Dialogue: 0,0:31:14.52,0:31:18.80,Default,,0,0,0,,so I'd replace alphas and PX\Nand then alphas with some PX.
Dialogue: 0,0:31:18.80,0:31:21.56,Default,,0,0,0,,NICK: Yeah, that's right. And\Nyou could furthermore factor out
Dialogue: 0,0:31:21.56,0:31:23.92,Default,,0,0,0,,what's inside\Nthe brackets to have both an
Dialogue: 0,0:31:23.92,0:31:26.68,Default,,0,0,0,,implementation of some and many.
Dialogue: 0,0:31:26.68,0:31:30.40,Default,,0,0,0,,JAMIE: Right. So some is\Nthe BNF plus then many is the star
Dialogue: 0,0:31:32.08,0:31:35.16,Default,,0,0,0,,using parse combinators surely\Nhas a performance impact.
Dialogue: 0,0:31:35.16,0:31:37.88,Default,,0,0,0,,NICK: Right. Yes. So there's\Ndefinitely some overhead to using
Dialogue: 0,0:31:37.88,0:31:39.60,Default,,0,0,0,,these kinds of combinators.\NBut on the other hand,
Dialogue: 0,0:31:39.60,0:31:42.72,Default,,0,0,0,,if you represent these\Ncombinators as a deep embedding
Dialogue: 0,0:31:42.72,0:31:44.96,Default,,0,0,0,,where the Combinators are\Nall data constructors,
Dialogue: 0,0:31:44.96,0:31:46.56,Default,,0,0,0,,then you can do things\Nlike grammar analysis,
Dialogue: 0,0:31:46.56,0:31:48.56,Default,,0,0,0,,which is driven by various laws,
Dialogue: 0,0:31:48.56,0:31:51.08,Default,,0,0,0,,such as the applictive\Nand alternative laws.
Dialogue: 0,0:31:51.08,0:31:53.00,Default,,0,0,0,,JAMIE: I guess you could\Noptimize it that way.
Dialogue: 0,0:31:53.00,0:31:55.04,Default,,0,0,0,,I think it's easier to\Nunderstand performance by
Dialogue: 0,0:31:55.04,0:31:56.76,Default,,0,0,0,,thinking of an underlying\Nstate machine.
Dialogue: 0,0:31:56.76,0:31:58.04,Default,,0,0,0,,NICK: What do you mean?
Dialogue: 0,0:31:58.04,0:32:01.00,Default,,0,0,0,,JAMIE: Well, you can represent\Nparsers as a machine with one
Dialogue: 0,0:32:01.00,0:32:03.44,Default,,0,0,0,,stack for intermediate results\Nand another for handling failure.
Dialogue: 0,0:32:03.44,0:32:06.08,Default,,0,0,0,,And then you parse by executing\Ninstructions that interact
Dialogue: 0,0:32:06.08,0:32:08.80,Default,,0,0,0,,with these stacks when they're\Ngiven some input stream.
Dialogue: 0,0:32:08.80,0:32:12.40,Default,,0,0,0,,So I guess we would take your\Nprevious parser as an example.
Dialogue: 0,0:32:12.40,0:32:18.28,Default,,0,0,0,,So here it would be.\NNICK: Whoa, is that really still Haskell?
Dialogue: 0,0:32:18.36,0:32:22.12,Default,,0,0,0,,JAMIE: Yeah, sure. This is clearly\Njust a recursive machine reading,
Dialogue: 0,0:32:22.12,0:32:24.28,Default,,0,0,0,,alphabetical characters,\Nsetting up failure handlers
Dialogue: 0,0:32:24.28,0:32:26.20,Default,,0,0,0,,before recursing again\Nand combining elements of the stack.
Dialogue: 0,0:32:26.20,0:32:27.60,Default,,0,0,0,,What's there not to understand?
Dialogue: 0,0:32:27.60,0:32:30.52,Default,,0,0,0,,Isn't this how you were\Ntaught to use Haskell?
Dialogue: 0,0:32:30.52,0:32:33.32,Default,,0,0,0,,NICK: Well, I you'll have to go\Na bit slower than that for me.
Dialogue: 0,0:32:33.32,0:32:37.72,Default,,0,0,0,,JAMIE: Right? Sure. So just read\Nthose dollars as semi-colons and
Dialogue: 0,0:32:37.72,0:32:40.36,Default,,0,0,0,,your favorite imperative language.\NThen alpha is similar to yours.
Dialogue: 0,0:32:40.36,0:32:42.00,Default,,0,0,0,,It's just an instruction\Nthat verifies a
Dialogue: 0,0:32:42.00,0:32:43.68,Default,,0,0,0,,predicate on the next input token,
Dialogue: 0,0:32:43.68,0:32:47.76,Default,,0,0,0,,and then continues with another\Ninstruction K and alphas performs,
Dialogue: 0,0:32:47.76,0:32:49.88,Default,,0,0,0,,alpha and then leaves the\Nresult on the stack.
Dialogue: 0,0:32:49.88,0:32:52.48,Default,,0,0,0,,It then does a catch block\Nto handle any failure.
Dialogue: 0,0:32:52.48,0:32:55.12,Default,,0,0,0,,And inside this block,\Nalphas is run again,
Dialogue: 0,0:32:55.12,0:32:57.00,Default,,0,0,0,,which leaves its result\Non the stack too.
Dialogue: 0,0:32:57.00,0:32:59.56,Default,,0,0,0,,And the two results are\Ncombined with left two cons.
Dialogue: 0,0:32:59.56,0:33:02.72,Default,,0,0,0,,Then things are free to carry on\Nwith the next instruction K.
Dialogue: 0,0:33:02.72,0:33:05.84,Default,,0,0,0,,But if failure happens, then\Nthe first instructions about
Dialogue: 0,0:33:05.84,0:33:08.44,Default,,0,0,0,,second block before the case\Ncheck that the input
Dialogue: 0,0:33:08.44,0:33:10.32,Default,,0,0,0,,hasn't changed since\Nstarting to catch.
Dialogue: 0,0:33:11.60,0:33:14.12,Default,,0,0,0,,And the case instruction then\Nuses that information to either
Dialogue: 0,0:33:14.12,0:33:17.40,Default,,0,0,0,,fail or combine out for the empty list\Nbefore continuing with that same K.
Dialogue: 0,0:33:17.40,0:33:19.92,Default,,0,0,0,,NICK: Oh, I see. So your\Nrepresentation is much
Dialogue: 0,0:33:19.92,0:33:22.20,Default,,0,0,0,,more explicit about\Ncontrol flow than mine.
Dialogue: 0,0:33:22.20,0:33:24.84,Default,,0,0,0,,JAMIE: Yeah. Analyzing\Nthe control from my machine is quite
Dialogue: 0,0:33:24.84,0:33:27.88,Default,,0,0,0,,straightforward. I think it's just\Na lot more complex in your case.
Dialogue: 0,0:33:27.88,0:33:29.32,Default,,0,0,0,,NICK: Yeah. That's true. The control
Dialogue: 0,0:33:29.32,0:33:30.64,Default,,0,0,0,,flow for the grammar isn't obvious
Dialogue: 0,0:33:30.64,0:33:33.40,Default,,0,0,0,,at all, until you start looking\Nat something like derivatives.
Dialogue: 0,0:33:33.40,0:33:37.00,Default,,0,0,0,,JAMIE: Okay. Hang on. I think\NI can see what's happening here.
Dialogue: 0,0:33:37.00,0:33:39.60,Default,,0,0,0,,The representation that\NI have is the same as yours.
Dialogue: 0,0:33:39.60,0:33:43.44,Default,,0,0,0,,It's just been transformed into\NCPS continuation parsing style.
Dialogue: 0,0:33:43.44,0:33:45.28,Default,,0,0,0,,That's what makes\Nthe control flow explicit.
Dialogue: 0,0:33:45.28,0:33:47.92,Default,,0,0,0,,Basically each instruction\Ntakes us an argument,
Dialogue: 0,0:33:47.92,0:33:49.60,Default,,0,0,0,,the next instruction executes.
Dialogue: 0,0:33:49.60,0:33:52.24,Default,,0,0,0,,And this is interpreted\Nby passing around two
Dialogue: 0,0:33:52.24,0:33:54.88,Default,,0,0,0,,continuations at run time. The\Ngood continuation and the bad one.
Dialogue: 0,0:33:54.88,0:33:57.88,Default,,0,0,0,,NICK: Of course. So if you\Ncan convert between the
Dialogue: 0,0:33:57.88,0:34:00.24,Default,,0,0,0,,two representations, then you'll be\Nable to get both the high level
Dialogue: 0,0:34:00.24,0:34:03.56,Default,,0,0,0,,optimizations and grammar\Nanalysis of my approach and
Dialogue: 0,0:34:03.56,0:34:06.28,Default,,0,0,0,,the low level optimizations\Nand control flow analysis of yours.
Dialogue: 0,0:34:06.28,0:34:09.40,Default,,0,0,0,,You get the best of both worlds.\NThere's a problem though.
Dialogue: 0,0:34:09.40,0:34:11.40,Default,,0,0,0,,The machine you showed\Nme before is untyped.
Dialogue: 0,0:34:11.40,0:34:13.72,Default,,0,0,0,,How can we convince ourselves\Nthat the translation
Dialogue: 0,0:34:13.72,0:34:17.36,Default,,0,0,0,,is working properly? My\NCombinator tree is fully typed.
Dialogue: 0,0:34:17.36,0:34:21.12,Default,,0,0,0,,JAMIE: Well, my stack represents\Nwhat's already been computed, right?
Dialogue: 0,0:34:21.12,0:34:23.24,Default,,0,0,0,,I guess in your world, that\Ncorresponds to combinators
Dialogue: 0,0:34:23.24,0:34:26.08,Default,,0,0,0,,that have already been executed\Nand each Combinator will
Dialogue: 0,0:34:26.08,0:34:29.28,Default,,0,0,0,,push exactly one thing to\Nthe stack. If it's successful.
Dialogue: 0,0:34:29.64,0:34:31.96,Default,,0,0,0,,NICK: So what if we can propagate\Nmy type information into
Dialogue: 0,0:34:31.96,0:34:34.80,Default,,0,0,0,,a type level stack. Here,\Nlet me show you what I mean.
Dialogue: 0,0:34:34.92,0:34:38.56,Default,,0,0,0,,So Halt is basically produces\Na machine that expects
Dialogue: 0,0:34:38.56,0:34:41.12,Default,,0,0,0,,an A on an empty stack\Nand returns that A.
Dialogue: 0,0:34:41.12,0:34:44.20,Default,,0,0,0,,JAMIE: Whoa whoa whoa! Wait.\NHow does that get implemented?
Dialogue: 0,0:34:44.20,0:34:47.68,Default,,0,0,0,,NICK: I see you just use an H\Nlist. It's a heterogeneous list
Dialogue: 0,0:34:47.68,0:34:49.68,Default,,0,0,0,,so that the values can\Nhave different types.
Dialogue: 0,0:34:49.68,0:34:52.76,Default,,0,0,0,,The types of each elements are\Nkept in a type level list.
Dialogue: 0,0:34:52.76,0:34:54.92,Default,,0,0,0,,And this list is\Nthe same as the one that
Dialogue: 0,0:34:54.92,0:34:56.64,Default,,0,0,0,,will appear in our\Ninstruction types.
Dialogue: 0,0:34:56.64,0:34:59.68,Default,,0,0,0,,JAMIE: Oh, right. Okay.\NThanks for that, carry on.
Dialogue: 0,0:34:59.68,0:35:02.72,Default,,0,0,0,,NICK: Where was I? Okay,\Nso push take some X and
Dialogue: 0,0:35:02.72,0:35:05.48,Default,,0,0,0,,the machine that expects X\Nand Xs and produces a machine
Dialogue: 0,0:35:05.48,0:35:09.88,Default,,0,0,0,,that expects just Xs. And pop\Ntakes the machine that expects
Dialogue: 0,0:35:09.88,0:35:12.44,Default,,0,0,0,,only the stack Xs\Nand produces a machine
Dialogue: 0,0:35:12.44,0:35:14.84,Default,,0,0,0,,that expects an X on\Ntop of the stack Xs.
Dialogue: 0,0:35:14.84,0:35:18.16,Default,,0,0,0,,JAMIE: Right? I think I see. So\Nthe continuation machine expects
Dialogue: 0,0:35:18.16,0:35:20.88,Default,,0,0,0,,a stack of a certain type\Nand then the instruction
Dialogue: 0,0:35:20.88,0:35:24.60,Default,,0,0,0,,will adapt that stack to fit.\NI guess that compiling combinators
Dialogue: 0,0:35:24.60,0:35:27.24,Default,,0,0,0,,to a machine means taking\Na machine that accepts the result and
Dialogue: 0,0:35:27.24,0:35:29.20,Default,,0,0,0,,makes progress towards\Nsome final goal.
Dialogue: 0,0:35:29.20,0:35:31.76,Default,,0,0,0,,So that's something like this then.
Dialogue: 0,0:35:31.76,0:35:35.76,Default,,0,0,0,,CompileSub will take a parser\Ncontaining returning an A and
Dialogue: 0,0:35:35.76,0:35:39.00,Default,,0,0,0,,then a machine that accepts\Nthat A along with some X's and
Dialogue: 0,0:35:39.00,0:35:40.40,Default,,0,0,0,,then we can build\Na machine that requires
Dialogue: 0,0:35:40.40,0:35:41.84,Default,,0,0,0,,just that Xs in\Norder to continue.
Dialogue: 0,0:35:41.84,0:35:44.20,Default,,0,0,0,,And the final continuation\Nis going to be Halt.
Dialogue: 0,0:35:44.20,0:35:46.72,Default,,0,0,0,,It takes the one element on\Nthe stack and gives it back.
Dialogue: 0,0:35:46.72,0:35:50.44,Default,,0,0,0,,NICK: Right. So how would\Nyou translate combinators?
Dialogue: 0,0:35:50.44,0:35:54.08,Default,,0,0,0,,So for example, the pure, which\Nhas type A to parser A and app,
Dialogue: 0,0:35:54.08,0:35:57.00,Default,,0,0,0,,which has type parser A to B\Nto parser A to parser B.
Dialogue: 0,0:35:57.00,0:35:59.36,Default,,0,0,0,,JAMIE: Oh, easy,\Nsomething like this.
Dialogue: 0,0:35:59.36,0:36:01.20,Default,,0,0,0,,So for pure that's just the push\Ninstruction, right.
Dialogue: 0,0:36:01.20,0:36:03.68,Default,,0,0,0,,With some N that will\Ncontinue on afterwards.
Dialogue: 0,0:36:03.68,0:36:06.92,Default,,0,0,0,,And then for app, we just\Nneed to compile PF and
Dialogue: 0,0:36:06.92,0:36:10.68,Default,,0,0,0,,then we'll compile PX. And after\Nthat, we combine the two results
Dialogue: 0,0:36:10.68,0:36:14.00,Default,,0,0,0,,that are on the stack with function\Napplication using lift two.
Dialogue: 0,0:36:14.44,0:36:18.88,Default,,0,0,0,,NICK: Oh, neat. So what about\Nthe and then variant of app where
Dialogue: 0,0:36:18.88,0:36:21.48,Default,,0,0,0,,discard the first argument,\Nrather than applying a function,
Dialogue: 0,0:36:21.48,0:36:23.92,Default,,0,0,0,,something like parser A\Nto parser B to parser B?
Dialogue: 0,0:36:23.92,0:36:26.80,Default,,0,0,0,,JAMIE: Oh, sure. All you need\Nto do is pop up to pass in the
Dialogue: 0,0:36:26.80,0:36:30.28,Default,,0,0,0,,first result so you compile P\Nthen you pop that was off and
Dialogue: 0,0:36:30.28,0:36:32.32,Default,,0,0,0,,then you compile Q\Nand then carry on with M.
Dialogue: 0,0:36:32.32,0:36:34.44,Default,,0,0,0,,NICK: Oh, neat. So I can see\Nhow this might work out.
Dialogue: 0,0:36:34.44,0:36:37.68,Default,,0,0,0,,You know, now that we can\Nsee this as using CPS,
Dialogue: 0,0:36:37.68,0:36:40.44,Default,,0,0,0,,it kind of reminds me of some\Nwork that my PhD student,
Dialogue: 0,0:36:40.44,0:36:42.72,Default,,0,0,0,,Matt Pickering has been\Ndoing lately on staging.
Dialogue: 0,0:36:42.72,0:36:45.00,Default,,0,0,0,,Actually, there's a paper being\Npresented at the Haskell symposium
Dialogue: 0,0:36:45.00,0:36:46.80,Default,,0,0,0,,about it coming up in\Njust a couple of days.
Dialogue: 0,0:36:46.80,0:36:48.92,Default,,0,0,0,,JAMIE: So what staging exactly?
Dialogue: 0,0:36:48.92,0:36:51.64,Default,,0,0,0,,NICK: Alright. Well, so staging\Nas a form of meta programming,
Dialogue: 0,0:36:51.64,0:36:55.76,Default,,0,0,0,,where you can perform work on\Nstatically known results ahead of
Dialogue: 0,0:36:55.76,0:36:57.84,Default,,0,0,0,,time leaving only\Ndynamic information
Dialogue: 0,0:36:57.84,0:37:00.00,Default,,0,0,0,,that run time it's\Nbasically giving you...
Dialogue: 0,0:37:00.00,0:37:02.16,Default,,0,0,0,,fine grained control over evaluation\Nin your compiler.
Dialogue: 0,0:37:02.20,0:37:03.88,Default,,0,0,0,,In our case the shape of the machine
Dialogue: 0,0:37:03.96,0:37:06.24,Default,,0,0,0,,for Parser and its\Ncombinators is static.
Dialogue: 0,0:37:06.24,0:37:07.96,Default,,0,0,0,,In other words, it's\Nknown by the compiler.
Dialogue: 0,0:37:08.52,0:37:10.28,Default,,0,0,0,,JAMIE WILLIS: I think\NI understand so this means
Dialogue: 0,0:37:10.28,0:37:11.44,Default,,0,0,0,,we can perform that translation
Dialogue: 0,0:37:11.44,0:37:13.20,Default,,0,0,0,,from combinations to machine,
Dialogue: 0,0:37:13.20,0:37:15.68,Default,,0,0,0,,and evaluate most of\Nit, at compile time.
Dialogue: 0,0:37:16.00,0:37:17.60,Default,,0,0,0,,I've heard of template Haskell,
Dialogue: 0,0:37:17.68,0:37:19.16,Default,,0,0,0,,but that's untyped right.
Dialogue: 0,0:37:19.32,0:37:21.24,Default,,0,0,0,,It seems a bit of a waste\Nof all the hard work
Dialogue: 0,0:37:21.32,0:37:22.64,Default,,0,0,0,,we did to make everything\Ntyped?
Dialogue: 0,0:37:22.64,0:37:24.24,Default,,0,0,0,,NICOLAS: Yeah, indeed and I guess
Dialogue: 0,0:37:24.24,0:37:26.32,Default,,0,0,0,,you haven't heard of typed template Haskell.
Dialogue: 0,0:37:26.52,0:37:30.40,Default,,0,0,0,,Unlike template Haskell\Nwhere you build AST's with
Dialogue: 0,0:37:30.48,0:37:32.44,Default,,0,0,0,,typed template Haskell\Nyou can only work with
Dialogue: 0,0:37:32.44,0:37:34.92,Default,,0,0,0,,well typed terms which\Nensures that the processes is safe,
Dialogue: 0,0:37:35.12,0:37:37.60,Default,,0,0,0,,For example, if you\Nhave some term E of type A,
Dialogue: 0,0:37:37.68,0:37:39.36,Default,,0,0,0,,then it could be quoted\Nto get the code
Dialogue: 0,0:37:39.36,0:37:41.60,Default,,0,0,0,,that represents E at\Nrun time,
Dialogue: 0,0:37:41.68,0:37:43.48,Default,,0,0,0,,quoting, which is of type code A.
Dialogue: 0,0:37:43.60,0:37:45.40,Default,,0,0,0,,If you want to splice\Nor run some code
Dialogue: 0,0:37:45.48,0:37:47.68,Default,,0,0,0,,you simply use the anti\Nquotes by adding a dollar
Dialogue: 0,0:37:47.76,0:37:50.32,Default,,0,0,0,,to the front so for some\Ncode C of type code A
Dialogue: 0,0:37:50.40,0:37:53.16,Default,,0,0,0,,Splice C gives back\Na value of type A.
Dialogue: 0,0:37:53.76,0:37:56.16,Default,,0,0,0,,JAMIE: Oh, so what I have to do,\Nis code to the parts
Dialogue: 0,0:37:56.16,0:37:57.64,Default,,0,0,0,,that are gonna happen at run time.
Dialogue: 0,0:37:57.64,0:37:58.84,Default,,0,0,0,,NICOLAS: Yep.
Dialogue: 0,0:37:58.88,0:38:00.40,Default,,0,0,0,,JAMIE: OK, so let's have a look
Dialogue: 0,0:38:00.44,0:38:01.88,Default,,0,0,0,,at the machine state the where it's interpreted
Dialogue: 0,0:38:01.96,0:38:03.08,Default,,0,0,0,,and see what we can\Nuncover.
Dialogue: 0,0:38:03.48,0:38:06.92,Default,,0,0,0,,So quickly, let's look at how we actually\Nevaluate the machine,
Dialogue: 0,0:38:06.92,0:38:08.68,Default,,0,0,0,,normally with the run\Nmachine function.
Dialogue: 0,0:38:09.00,0:38:10.84,Default,,0,0,0,,So, we're going to\Nprovide some machine
Dialogue: 0,0:38:10.92,0:38:12.52,Default,,0,0,0,,state gamma to the eval function,
Dialogue: 0,0:38:12.52,0:38:13.76,Default,,0,0,0,,and that's going to interpret
Dialogue: 0,0:38:13.76,0:38:15.68,Default,,0,0,0,,the meaning of each instruction.
Dialogue: 0,0:38:15.84,0:38:17.92,Default,,0,0,0,,So, all gamma is is just a
Dialogue: 0,0:38:18.52,0:38:20.40,Default,,0,0,0,,our heterogeneous open\Nstack along with a return
Dialogue: 0,0:38:20.48,0:38:22.96,Default,,0,0,0,,continuation\Nfor recursion a stack
Dialogue: 0,0:38:23.00,0:38:25.44,Default,,0,0,0,,for failure handlers\Nand the input xs itself.
Dialogue: 0,0:38:25.84,0:38:27.20,Default,,0,0,0,,And so the bit that we can actually
Dialogue: 0,0:38:27.24,0:38:29.24,Default,,0,0,0,,stage about this would\Nbe the eval function,
Dialogue: 0,0:38:29.76,0:38:30.80,Default,,0,0,0,,because it's the machine
Dialogue: 0,0:38:30.88,0:38:32.60,Default,,0,0,0,,that's done at compile time, right.
Dialogue: 0,0:38:33.00,0:38:35.84,Default,,0,0,0,,So, if I just add code around it,
Dialogue: 0,0:38:36.24,0:38:38.80,Default,,0,0,0,,then that makes\Nthe function from machine
Dialogue: 0,0:38:38.80,0:38:40.80,Default,,0,0,0,,state to final value code
Dialogue: 0,0:38:40.84,0:38:42.84,Default,,0,0,0,,and that, that'll be done at run time.
Dialogue: 0,0:38:43.24,0:38:45.32,Default,,0,0,0,,And you can break this into\Na compile time function
Dialogue: 0,0:38:45.32,0:38:46.72,Default,,0,0,0,,that takes code and returns code
Dialogue: 0,0:38:46.76,0:38:48.36,Default,,0,0,0,,that's fairly straightforward,
Dialogue: 0,0:38:48.76,0:38:51.24,Default,,0,0,0,,but we should get to\Nmore than this, right.
Dialogue: 0,0:38:51.88,0:38:54.40,Default,,0,0,0,,So the machines take gammas\Nalways the same shape,
Dialogue: 0,0:38:54.56,0:38:57.12,Default,,0,0,0,,so we should be able to get rid\Nof that at compile time too.
Dialogue: 0,0:38:57.84,0:39:00.60,Default,,0,0,0,,So if I push the code\Ninto the gamma,
Dialogue: 0,0:39:01.12,0:39:03.28,Default,,0,0,0,,then we can ensure it\Nonly exist at a compile time.
Dialogue: 0,0:39:03.80,0:39:06.80,Default,,0,0,0,,Yeah so run time will produce\Na function with four arguments,
Dialogue: 0,0:39:06.84,0:39:09.56,Default,,0,0,0,,one for each component,\Nbut the actual records gone.
Dialogue: 0,0:39:10.80,0:39:12.96,Default,,0,0,0,,There's sort of this, gonna\Nbe more we can do now.
Dialogue: 0,0:39:13.76,0:39:15.24,Default,,0,0,0,,NICOLAS: Well,\Nthe fact that, H list.
Dialogue: 0,0:39:16.12,0:39:18.72,Default,,0,0,0,,In ops has the type Xs implies,
Dialogue: 0,0:39:19.00,0:39:21.88,Default,,0,0,0,,but it must have those, shape that\Nwe can do at compile time.
Dialogue: 0,0:39:22.20,0:39:23.92,Default,,0,0,0,,And that's determined by instructions
Dialogue: 0,0:39:23.92,0:39:25.24,Default,,0,0,0,,also known at compile time.
Dialogue: 0,0:39:25.28,0:39:28.00,Default,,0,0,0,,So you could push the code\Ninside the H list.
Dialogue: 0,0:39:28.60,0:39:31.28,Default,,0,0,0,,JAMIE: I see, so, if I map
Dialogue: 0,0:39:31.56,0:39:33.72,Default,,0,0,0,,the code over the values in the H list,
Dialogue: 0,0:39:34.48,0:39:37.80,Default,,0,0,0,,then the H list itself is only\Ngoing to exist at compile time,
Dialogue: 0,0:39:38.12,0:39:39.84,Default,,0,0,0,,and the values exist at run time.
Dialogue: 0,0:39:40.60,0:39:43.16,Default,,0,0,0,,And I guess the structure,\Nthe handle stack is
Dialogue: 0,0:39:43.20,0:39:45.48,Default,,0,0,0,,the same it's determined by\Nthe instructions as well.
Dialogue: 0,0:39:46.04,0:39:49.48,Default,,0,0,0,,So I guess we can operate that\Nlist at compile time too.
Dialogue: 0,0:39:50.52,0:39:52.56,Default,,0,0,0,,So, with all things considered,
Dialogue: 0,0:39:52.64,0:39:54.08,Default,,0,0,0,,I guess the only thing\Nwe don't really know
Dialogue: 0,0:39:54.08,0:39:55.48,Default,,0,0,0,,at compile time is\Nwhat the input is,
Dialogue: 0,0:39:55.56,0:39:58.40,Default,,0,0,0,,and specifically what each\Ncontinuation is at any given point.
Dialogue: 0,0:39:58.80,0:40:00.00,Default,,0,0,0,,Everything else is gone
Dialogue: 0,0:40:00.28,0:40:01.84,Default,,0,0,0,,NICOLAS: Exactly and that's why we
Dialogue: 0,0:40:01.92,0:40:03.36,Default,,0,0,0,,like staging so much.
Dialogue: 0,0:40:03.48,0:40:06.00,Default,,0,0,0,,JAMIE: Awesome, so here's what\Nthe staged evaluation
Dialogue: 0,0:40:06.24,0:40:07.88,Default,,0,0,0,,for push and halt\Nlook like then.
Dialogue: 0,0:40:08.04,0:40:10.84,Default,,0,0,0,,So, halt will take\Nthe operand stack out of gamma
Dialogue: 0,0:40:10.84,0:40:12.24,Default,,0,0,0,,and extract the top element
Dialogue: 0,0:40:13.28,0:40:15.08,Default,,0,0,0,,and splice it into some code
Dialogue: 0,0:40:15.08,0:40:17.52,Default,,0,0,0,,that builds it just for\Nthat value at run time,
Dialogue: 0,0:40:18.28,0:40:20.08,Default,,0,0,0,,and eval push there aren't\Nactually any quotes
Dialogue: 0,0:40:20.12,0:40:23.04,Default,,0,0,0,,in the body at all,\N so it must purely happen at compile time.
Dialogue: 0,0:40:23.08,0:40:24.16,Default,,0,0,0,,That's really cool.
Dialogue: 0,0:40:24.56,0:40:27.04,Default,,0,0,0,,So, I guess let's\Npush
Dialogue: 0,0:40:27.08,0:40:28.16,Default,,0,0,0,,an example through this mechanism
Dialogue: 0,0:40:28.16,0:40:29.60,Default,,0,0,0,,and see what code it generates.
Dialogue: 0,0:40:30.92,0:40:32.56,Default,,0,0,0,,Wow, this is, this is quite cool,
Dialogue: 0,0:40:32.56,0:40:34.96,Default,,0,0,0,,so I guess we can see that\Nnone of the abstractions
Dialogue: 0,0:40:34.96,0:40:36.88,Default,,0,0,0,,from the combinators in\Nthe machine are here at all.
Dialogue: 0,0:40:37.04,0:40:40.56,Default,,0,0,0,,It's literally just a couple of\Nfunctions, taking this argument,
Dialogue: 0,0:40:40.56,0:40:42.48,Default,,0,0,0,,this good continuation\Nthe bad continuation.
Dialogue: 0,0:40:42.80,0:40:45.92,Default,,0,0,0,,And some input and it'll\Nall thread around together,
Dialogue: 0,0:40:45.96,0:40:47.16,Default,,0,0,0,,this is, this is awesome.
Dialogue: 0,0:40:47.20,0:40:49.00,Default,,0,0,0,,NICOLAS: Yeah, it is,\Nit's really good.
Dialogue: 0,0:40:49.32,0:40:50.64,Default,,0,0,0,,But there is a small problem.
Dialogue: 0,0:40:50.80,0:40:53.40,Default,,0,0,0,,Most parser combinators\Nsuch as parsec
Dialogue: 0,0:40:53.40,0:40:56.32,Default,,0,0,0,,this combinator called bind,\Nwhich is usually used
Dialogue: 0,0:40:56.36,0:40:58.36,Default,,0,0,0,,to implement context\Nsensitive parsing
Dialogue: 0,0:40:58.56,0:41:00.92,Default,,0,0,0,,the stuff that was previously parsed
Dialogue: 0,0:41:01.00,0:41:02.00,Default,,0,0,0,,can influence the grammar,
Dialogue: 0,0:41:02.00,0:41:03.60,Default,,0,0,0,,that is used to parse the rest.
Dialogue: 0,0:41:03.88,0:41:06.08,Default,,0,0,0,,The trouble is that I don't\Nthink this can be staged.
Dialogue: 0,0:41:07.72,0:41:08.80,Default,,0,0,0,,JAMIE: That's a pain,
Dialogue: 0,0:41:08.80,0:41:11.04,Default,,0,0,0,,I mean do you really need\Nto create a whole new parser
Dialogue: 0,0:41:11.04,0:41:12.16,Default,,0,0,0,,so that we can't inspect,
Dialogue: 0,0:41:12.16,0:41:13.96,Default,,0,0,0,,what sort of things do you\Nactually use it for.
Dialogue: 0,0:41:14.12,0:41:16.52,Default,,0,0,0,,NICOLAS: I suppose, most of the time\Nthe grammar is static,
Dialogue: 0,0:41:16.52,0:41:17.80,Default,,0,0,0,,and bind is used to select
Dialogue: 0,0:41:17.80,0:41:19.60,Default,,0,0,0,,the part of the grammar\Nthat's already known.
Dialogue: 0,0:41:20.40,0:41:22.40,Default,,0,0,0,,JAMIE: Oh, well we've already\Nseen an operation
Dialogue: 0,0:41:22.48,0:41:24.00,Default,,0,0,0,,like that right?\N it was it was case.
Dialogue: 0,0:41:24.08,0:41:26.00,Default,,0,0,0,,So both of the outcomes\Nare known statically,
Dialogue: 0,0:41:26.32,0:41:29.00,Default,,0,0,0,,but you don't know which path\Nis taken until run time.
Dialogue: 0,0:41:29.36,0:41:30.40,Default,,0,0,0,,NICOLAS: Interesting.
Dialogue: 0,0:41:30.48,0:41:33.32,Default,,0,0,0,,I wonder if this corresponds\Nto Marco's work on selected functors,
Dialogue: 0,0:41:33.40,0:41:35.68,Default,,0,0,0,,it seems to behave similarly\Nto his branch operation
Dialogue: 0,0:41:35.88,0:41:39.12,Default,,0,0,0,,which arbitrates between two\Nbranches depending on a coproduct.
Dialogue: 0,0:41:40.20,0:41:41.68,Default,,0,0,0,,JAMIE: Yeah, I think that\Nsounds about right.
Dialogue: 0,0:41:41.84,0:41:44.56,Default,,0,0,0,,NICOLAS: Great, so if you give up bind\Nand work with selectors
Dialogue: 0,0:41:44.64,0:41:47.64,Default,,0,0,0,,instead we can use staging,\Nand that makes things really fast.
Dialogue: 0,0:41:49.32,0:41:50.68,Default,,0,0,0,,JAMIE: Let me\Nquickly whip something up
Dialogue: 0,0:41:50.68,0:41:52.92,Default,,0,0,0,,and we can see how it performs\Non some benchmarks, I made earlier.
Dialogue: 0,0:41:56.40,0:41:59.00,Default,,0,0,0,,NICOLAS: Wow. Kids these days are really\Nfast at programming things.
Dialogue: 0,0:41:59.72,0:42:02.60,Default,,0,0,0,,JAMIE: Perfect. It works first\Ntime that's unusual
Dialogue: 0,0:42:02.68,0:42:04.16,Default,,0,0,0,,It must be there's strong types.
Dialogue: 0,0:42:04.20,0:42:05.52,Default,,0,0,0,,Right here's the results.
Dialogue: 0,0:42:05.84,0:42:07.68,Default,,0,0,0,,So, this graph is showing us
Dialogue: 0,0:42:07.68,0:42:09.72,Default,,0,0,0,,that actually compared\Nto the other combinator
Dialogue: 0,0:42:09.80,0:42:12.32,Default,,0,0,0,,libraries we're about three\Nor four times faster,
Dialogue: 0,0:42:12.36,0:42:13.72,Default,,0,0,0,,and we're even beating happy
Dialogue: 0,0:42:13.72,0:42:15.36,Default,,0,0,0,,that's a parser generator library.
Dialogue: 0,0:42:15.40,0:42:17.20,Default,,0,0,0,,NICOLAS: Wow, that's\Nreally good performance.
Dialogue: 0,0:42:17.60,0:42:18.84,Default,,0,0,0,,JAMIE: Yeah, this is great.
Dialogue: 0,0:42:18.92,0:42:20.36,Default,,0,0,0,,Maybe we should write\Na paper about this.
Dialogue: 0,0:42:20.76,0:42:22.84,Default,,0,0,0,,NICOLAS: Well, you're pretty good\Nat coding things quickly
Dialogue: 0,0:42:22.92,0:42:25.72,Default,,0,0,0,,and I'm pretty good at writing\Npapers quickly, so here you go.
Dialogue: 0,0:42:29.08,0:42:31.56,Default,,0,0,0,,Cool. I'm gonna stop\Nrecording now I think.
Dialogue: 0,0:42:32.12,0:42:38.60,Default,,0,0,0,,BACKGROUND CLAPPING
Dialogue: 0,0:42:39.60,0:42:41.64,Default,,0,0,0,,ALAN JEFFREY: OK, thank you, Jamie and Nic.
Dialogue: 0,0:42:42.24,0:42:45.36,Default,,0,0,0,,So if you want to\Njoin the authors for
Dialogue: 0,0:42:45.48,0:42:47.88,Default,,0,0,0,,a Q&A in the New York time zone.
Dialogue: 0,0:42:48.28,0:42:51.16,Default,,0,0,0,,Then you can click on\Nthe link in the Clowdr room,
Dialogue: 0,0:43:00.56,0:43:03.04,Default,,0,0,0,,Hello and welcome back to
Dialogue: 0,0:43:03.04,0:43:06.24,Default,,0,0,0,,the second session for ICFP 2020.
Dialogue: 0,0:43:06.24,0:43:09.88,Default,,0,0,0,,And our next talk is going to\Nbe, Kindly Bent to Free Us,
Dialogue: 0,0:43:10.04,0:43:12.68,Default,,0,0,0,,and it's going to be presented\Nby Gabriel Radanne.
Dialogue: 0,0:43:13.68,0:43:14.88,Default,,0,0,0,,GABRIEL RADANNE: Hi everyone
Dialogue: 0,0:43:14.92,0:43:16.00,Default,,0,0,0,,so I'm Gabriel Radanne
Dialogue: 0,0:43:16.00,0:43:17.52,Default,,0,0,0,,and I'm going to talk to you
Dialogue: 0,0:43:17.52,0:43:20.40,Default,,0,0,0,,about memory safety\Nfor a little while.
Dialogue: 0,0:43:20.44,0:43:25.00,Default,,0,0,0,,Here is a report provided\Nby the Chromium team
Dialogue: 0,0:43:25.08,0:43:28.12,Default,,0,0,0,,about high severity\Nsecurity bugs in chromium,
Dialogue: 0,0:43:28.28,0:43:30.32,Default,,0,0,0,,and you can see that\Nalmost two thirds
Dialogue: 0,0:43:30.32,0:43:34.48,Default,,0,0,0,,of the bugs in chromium\Nare memory related,
Dialogue: 0,0:43:34.52,0:43:38.16,Default,,0,0,0,,and one third of the bugs, are simple\Nuse after free errors.
Dialogue: 0,0:43:38.76,0:43:39.84,Default,,0,0,0,,So you could say OK.
Dialogue: 0,0:43:39.84,0:43:43.20,Default,,0,0,0,,Chromium is written in\Na mix of C and C++
Dialogue: 0,0:43:43.24,0:43:44.88,Default,,0,0,0,,and surely these don't happen
Dialogue: 0,0:43:44.88,0:43:47.36,Default,,0,0,0,,in high level typed languages. Right.
Dialogue: 0,0:43:49.12,0:43:50.68,Default,,0,0,0,,Let's write OCaml code.
Dialogue: 0,0:43:51.92,0:43:57.04,Default,,0,0,0,,Here is a small example of code\Nwhere we open a database,
Dialogue: 0,0:43:57.36,0:44:01.20,Default,,0,0,0,,we write a grade database of grades,
Dialogue: 0,0:44:01.48,0:44:05.00,Default,,0,0,0,,we write some grade into\Nthe database so that's great,
Dialogue: 0,0:44:05.20,0:44:07.04,Default,,0,0,0,,we close the database, then we try
Dialogue: 0,0:44:07.12,0:44:11.16,Default,,0,0,0,,to read the literature\Ngrade, and print it.
Dialogue: 0,0:44:11.68,0:44:16.80,Default,,0,0,0,,The OCaml type checker\Nwill happily type check
Dialogue: 0,0:44:16.80,0:44:18.72,Default,,0,0,0,,and compile this program,
Dialogue: 0,0:44:18.96,0:44:22.32,Default,,0,0,0,,and later on we'll have\Nruntime error. So,
Dialogue: 0,0:44:24.84,0:44:29.36,Default,,0,0,0,,there are various ways to, deal with\Nthis kind of errors,
Dialogue: 0,0:44:29.56,0:44:32.12,Default,,0,0,0,,and today I'm going to present Affe,
Dialogue: 0,0:44:32.20,0:44:34.20,Default,,0,0,0,,which is an ML-like language
Dialogue: 0,0:44:34.52,0:44:37.52,Default,,0,0,0,,that prevents precisely\Nthis kind of error.
Dialogue: 0,0:44:38.00,0:44:40.52,Default,,0,0,0,,Here is the same program\Nwritten in Affe.
Dialogue: 0,0:44:41.56,0:44:44.04,Default,,0,0,0,,It looks very much like the ML program
Dialogue: 0,0:44:44.04,0:44:45.76,Default,,0,0,0,,the program from before,
Dialogue: 0,0:44:46.04,0:44:48.16,Default,,0,0,0,,except this time when we\Nreach the last line
Dialogue: 0,0:44:48.24,0:44:53.04,Default,,0,0,0,,the type checker will refuse\Nthis program at compile time.
Dialogue: 0,0:44:53.48,0:44:56.60,Default,,0,0,0,,We have a few\Nspecialties in Affe.
Dialogue: 0,0:44:56.72,0:45:02.68,Default,,0,0,0,,The first one is that we use\Nkinds, to determine usage.
Dialogue: 0,0:45:02.76,0:45:07.00,Default,,0,0,0,,Here is a grade database\Nof type database,
Dialogue: 0,0:45:07.28,0:45:09.96,Default,,0,0,0,,the database is kind of linear.
Dialogue: 0,0:45:10.04,0:45:13.36,Default,,0,0,0,,So this resource\Nmust be used linearly,
Dialogue: 0,0:45:13.52,0:45:15.96,Default,,0,0,0,,and when it's closed, you\Ndon't use it anymore.
Dialogue: 0,0:45:17.24,0:45:20.72,Default,,0,0,0,,On the contrary, here we\Nhave the math string
Dialogue: 0,0:45:20.84,0:45:22.56,Default,,0,0,0,,and strings are unrestricted.
Dialogue: 0,0:45:22.72,0:45:26.40,Default,,0,0,0,,And so you can you can use them\Nin unrestricted fashions.
Dialogue: 0,0:45:29.44,0:45:34.28,Default,,0,0,0,,Furthermore, we have borrows,\Nas present in Rust
Dialogue: 0,0:45:34.44,0:45:36.28,Default,,0,0,0,,and other languages.\NBorrows allow
Dialogue: 0,0:45:36.36,0:45:39.04,Default,,0,0,0,,to do imperative programming\Nvery conveniently
Dialogue: 0,0:45:39.04,0:45:40.96,Default,,0,0,0,,and that's why we use them here.
Dialogue: 0,0:45:41.48,0:45:44.76,Default,,0,0,0,,Finally, the final\Nspecialty of Affe
Dialogue: 0,0:45:44.84,0:45:46.84,Default,,0,0,0,,is that we have complete\Ntype inference.
Dialogue: 0,0:45:46.92,0:45:48.36,Default,,0,0,0,,Before I used
Dialogue: 0,0:45:50.12,0:45:51.80,Default,,0,0,0,,a type annotation here
Dialogue: 0,0:45:51.84,0:45:56.20,Default,,0,0,0,,to make\Nit easier to read.
Dialogue: 0,0:45:56.36,0:46:01.32,Default,,0,0,0,,But I don't need to. The\Ntype is completely inferred.
Dialogue: 0,0:46:03.20,0:46:06.52,Default,,0,0,0,,To present Affe, I'm going to\Ngo through various of its features,
Dialogue: 0,0:46:06.60,0:46:08.84,Default,,0,0,0,,and I'm going to start with linearity.
Dialogue: 0,0:46:09.24,0:46:11.56,Default,,0,0,0,,As I said before\Nkinds determine usage.
Dialogue: 0,0:46:12.44,0:46:17.04,Default,,0,0,0,,We have three kinds: linear resources\Nmust be used exactly once.
Dialogue: 0,0:46:17.88,0:46:22.96,Default,,0,0,0,,Affine resources must be used\Nat most once.
Dialogue: 0,0:46:23.20,0:46:26.44,Default,,0,0,0,,An unrestricted\Nobject can be used
Dialogue: 0,0:46:26.44,0:46:29.48,Default,,0,0,0,,arbitrary many times\Nfrom zero to infinity.
Dialogue: 0,0:46:29.56,0:46:31.08,Default,,0,0,0,,Here are a few examples.
Dialogue: 0,0:46:31.60,0:46:33.40,Default,,0,0,0,,We have a database type of
Dialogue: 0,0:46:33.48,0:46:38.72,Default,,0,0,0,,kind Lin, a string type\Nof kind Unrestricted.
Dialogue: 0,0:46:39.24,0:46:41.40,Default,,0,0,0,,We can also have parameterized kinds.
Dialogue: 0,0:46:41.48,0:46:42.84,Default,,0,0,0,,For example, a list.
Dialogue: 0,0:46:43.36,0:46:45.04,Default,,0,0,0,,As the kind of content,
Dialogue: 0,0:46:45.20,0:46:46.88,Default,,0,0,0,,if we have a list of database.
Dialogue: 0,0:46:47.12,0:46:49.40,Default,,0,0,0,,Then this list must be used linearly.
Dialogue: 0,0:46:49.80,0:46:51.12,Default,,0,0,0,,If we have a list of strings,
Dialogue: 0,0:46:51.12,0:46:54.16,Default,,0,0,0,,it can be used in\Nan unrestricted fashion
Dialogue: 0,0:46:55.40,0:46:58.76,Default,,0,0,0,,to use these kind of parameters,
Dialogue: 0,0:46:58.80,0:47:00.44,Default,,0,0,0,,We have kind constraints.
Dialogue: 0,0:47:00.48,0:47:04.84,Default,,0,0,0,,So here we\Nhave the type of a function
Dialogue: 0,0:47:04.88,0:47:06.92,Default,,0,0,0,,that creates a list which takes an element
Dialogue: 0,0:47:07.00,0:47:12.00,Default,,0,0,0,,and replicates it multiple\Ntimes to create a list.
Dialogue: 0,0:47:13.24,0:47:15.48,Default,,0,0,0,,Since the element is\Ngoing to be replicated.
Dialogue: 0,0:47:15.96,0:47:17.72,Default,,0,0,0,,Then naturally,
Dialogue: 0,0:47:18.20,0:47:20.12,Default,,0,0,0,,its content must be unrestricted.
Dialogue: 0,0:47:20.12,0:47:23.44,Default,,0,0,0,,And that's exactly what\Nthis constraint says.
Dialogue: 0,0:47:24.92,0:47:27.12,Default,,0,0,0,,Finally, we also use subkinding,
Dialogue: 0,0:47:27.52,0:47:30.88,Default,,0,0,0,,kind Un is smaller than Aff\Nwhich is smaller than Lin.
Dialogue: 0,0:47:31.04,0:47:36.04,Default,,0,0,0,,And that means that if a function\Nonly expect linear objects,
Dialogue: 0,0:47:36.32,0:47:38.56,Default,,0,0,0,,we can pass it unrestricted objects.
Dialogue: 0,0:47:38.64,0:47:40.24,Default,,0,0,0,,The reason is that if something
Dialogue: 0,0:47:40.24,0:47:41.96,Default,,0,0,0,,can be used in unrestricted fashion,
Dialogue: 0,0:47:41.96,0:47:44.32,Default,,0,0,0,,in particular, it can\Nbe used linearly
Dialogue: 0,0:47:46.76,0:47:48.76,Default,,0,0,0,,This is the base of our language,
Dialogue: 0,0:47:48.84,0:47:51.96,Default,,0,0,0,,and we're going to\Nuse it to build up everything else.
Dialogue: 0,0:47:52.00,0:47:54.92,Default,,0,0,0,,And in particular,\Nfunctions and closures.
Dialogue: 0,0:47:56.68,0:48:01.40,Default,,0,0,0,,Here's a piece of code where\Nwe open the grade database.
Dialogue: 0,0:48:01.44,0:48:05.64,Default,,0,0,0,,Then we create a function\Nthat logs some message
Dialogue: 0,0:48:05.72,0:48:07.24,Default,,0,0,0,,and then closes the database.
Dialogue: 0,0:48:07.56,0:48:09.88,Default,,0,0,0,,As you can see, we\Nhave a capture here,
Dialogue: 0,0:48:10.64,0:48:13.20,Default,,0,0,0,,the closure of the login\Nfunction captures
Dialogue: 0,0:48:13.20,0:48:17.96,Default,,0,0,0,,a grade database and grade,\Na grade database is linear,
Dialogue: 0,0:48:18.04,0:48:19.80,Default,,0,0,0,,it must be used exactly once.
Dialogue: 0,0:48:20.20,0:48:24.64,Default,,0,0,0,,And so, the log function must\Nalso be called exactly once.
Dialogue: 0,0:48:25.52,0:48:28.40,Default,,0,0,0,,If we ask the Affe typechecker
Dialogue: 0,0:48:28.44,0:48:32.72,Default,,0,0,0,,it's going to give us\Nthis type, string arrow
Dialogue: 0,0:48:32.84,0:48:35.36,Default,,0,0,0,,Annotated by Lin to unit,
Dialogue: 0,0:48:35.68,0:48:38.76,Default,,0,0,0,,and the annotation on\Nthe arrow indicates
Dialogue: 0,0:48:38.84,0:48:41.96,Default,,0,0,0,,the usage of this function.
Dialogue: 0,0:48:42.00,0:48:45.00,Default,,0,0,0,,It indicates that the login closure\Nmust be called exactly once.
Dialogue: 0,0:48:48.24,0:48:50.68,Default,,0,0,0,,If you're wanting to\Nmake everything here.
Dialogue: 0,0:48:50.96,0:48:52.92,Default,,0,0,0,,This annotation,
Dialogue: 0,0:48:53.08,0:48:55.40,Default,,0,0,0,,does not say anything\Nabout the argument.
Dialogue: 0,0:48:55.40,0:48:58.64,Default,,0,0,0,,Here the argument is of type\Nstring so it's unrestricted,
Dialogue: 0,0:48:58.72,0:49:00.56,Default,,0,0,0,,you can do whatever\Nyou want with it.
Dialogue: 0,0:49:00.96,0:49:04.76,Default,,0,0,0,,The arrow and in particular\Nthis linear arrow
Dialogue: 0,0:49:04.84,0:49:06.92,Default,,0,0,0,,is not the lollipop from linear logic.
Dialogue: 0,0:49:07.64,0:49:10.96,Default,,0,0,0,,It only says something\Nabout the function itself
Dialogue: 0,0:49:12.72,0:49:14.44,Default,,0,0,0,,All right, so we can do
Dialogue: 0,0:49:15.12,0:49:17.48,Default,,0,0,0,,Nice functional\Nprogramming with all this.
Dialogue: 0,0:49:18.08,0:49:19.56,Default,,0,0,0,,Let's look about imperative.
Dialogue: 0,0:49:19.80,0:49:22.16,Default,,0,0,0,,Let's look at imperative\Nprogramming,
Dialogue: 0,0:49:22.16,0:49:25.04,Default,,0,0,0,,and for that we need\Nborrows and regions
Dialogue: 0,0:49:26.64,0:49:28.64,Default,,0,0,0,,as in Rust and other languages,
Dialogue: 0,0:49:28.64,0:49:33.04,Default,,0,0,0,,a borrow is a temporary\Nloan of a resource.
Dialogue: 0,0:49:33.28,0:49:35.76,Default,,0,0,0,,And we have two types\Nof  borrow.
Dialogue: 0,0:49:35.76,0:49:39.08,Default,,0,0,0,,Shared borrows for\Nobserving the resource
Dialogue: 0,0:49:39.16,0:49:42.92,Default,,0,0,0,,and Exclusive borrows\Nfor modifying the resource.
Dialogue: 0,0:49:44.92,0:49:47.68,Default,,0,0,0,,Here is an example of\Na correct use of borrow.
Dialogue: 0,0:49:48.92,0:49:53.08,Default,,0,0,0,,We start by looking up\Ntwo grades concurrently.
Dialogue: 0,0:49:53.08,0:49:55.56,Default,,0,0,0,,This is a read action so we use
Dialogue: 0,0:49:55.60,0:49:58.60,Default,,0,0,0,,a shared borrow for observing the data.
Dialogue: 0,0:50:00.00,0:50:02.52,Default,,0,0,0,,Since it's shared,
Dialogue: 0,0:50:02.56,0:50:06.04,Default,,0,0,0,,we can look up two things at\Nthe same time concurrently,
Dialogue: 0,0:50:06.08,0:50:09.28,Default,,0,0,0,,and in particular the kind\Nof this is unrestricted.
Dialogue: 0,0:50:09.72,0:50:11.80,Default,,0,0,0,,Once we are done with looking up
Dialogue: 0,0:50:11.88,0:50:15.20,Default,,0,0,0,,these two grades\Nand making their average,
Dialogue: 0,0:50:15.24,0:50:20.04,Default,,0,0,0,,we can write in the database\Nusing an exclusive borrow
Dialogue: 0,0:50:21.88,0:50:25.00,Default,,0,0,0,,and exclusive are, as\NI said, exclusive
Dialogue: 0,0:50:25.04,0:50:28.12,Default,,0,0,0,,and they are, in particular,\Nof kind affine.
Dialogue: 0,0:50:28.56,0:50:31.72,Default,,0,0,0,,There are a few rules\Nto use this borrows.
Dialogue: 0,0:50:31.76,0:50:35.04,Default,,0,0,0,,The first rule is that\Nwe cannot use
Dialogue: 0,0:50:35.08,0:50:39.12,Default,,0,0,0,,a borrow and the resource\Nitself at the same time.
Dialogue: 0,0:50:39.12,0:50:43.80,Default,,0,0,0,,Here, the function is\Ncalled with the resource,
Dialogue: 0,0:50:43.80,0:50:46.36,Default,,0,0,0,,and a borrow, and that's not allowed
Dialogue: 0,0:50:46.52,0:50:48.24,Default,,0,0,0,,and the type checker will reject this.
Dialogue: 0,0:50:50.24,0:50:53.36,Default,,0,0,0,,A second rule is that\Nwe cannot use an
Dialogue: 0,0:50:53.36,0:50:57.32,Default,,0,0,0,,exclusive borrow and any\Nother borrow, so here,
Dialogue: 0,0:50:57.32,0:51:00.20,Default,,0,0,0,,I have an exclusive\Nborrow and another borrow,
Dialogue: 0,0:51:00.52,0:51:03.48,Default,,0,0,0,,and the type checker\Nwill again reject this.
Dialogue: 0,0:51:05.04,0:51:08.44,Default,,0,0,0,,Finally, a borrow must not escape.
Dialogue: 0,0:51:08.84,0:51:12.84,Default,,0,0,0,,Here we have\Na declaration of database
Dialogue: 0,0:51:13.08,0:51:17.24,Default,,0,0,0,,and then pair composed\Nwhich contains a borrow.
Dialogue: 0,0:51:17.32,0:51:20.32,Default,,0,0,0,,And then we try to leak the borrow
Dialogue: 0,0:51:20.32,0:51:23.00,Default,,0,0,0,,while the database is still\Ncaptured inside the function.
Dialogue: 0,0:51:23.64,0:51:25.60,Default,,0,0,0,,This is not allowed\Nbecause the borrow
Dialogue: 0,0:51:25.60,0:51:28.00,Default,,0,0,0,,is escaping its region.
Dialogue: 0,0:51:28.64,0:51:32.68,Default,,0,0,0,,And here is the region,\Ndelimiting a borrow.
Dialogue: 0,0:51:33.08,0:51:36.04,Default,,0,0,0,,So the regions are\Nalmost lexical scoping
Dialogue: 0,0:51:36.04,0:51:39.28,Default,,0,0,0,,with a few tweaks\Nand the way we check
Dialogue: 0,0:51:39.56,0:51:43.40,Default,,0,0,0,,for this kind of escape is\Nby using indexed kinds
Dialogue: 0,0:51:43.48,0:51:47.16,Default,,0,0,0,,Before I said the kinds were\Nunrestricted, affine, and linear.
Dialogue: 0,0:51:47.48,0:51:48.68,Default,,0,0,0,,Actually there is a bit more
Dialogue: 0,0:51:48.72,0:51:50.72,Default,,0,0,0,,they are zero-indexed by the nesting.
Dialogue: 0,0:51:51.28,0:51:54.80,Default,,0,0,0,,And here the grade, the borrow
Dialogue: 0,0:51:54.80,0:52:00.20,Default,,0,0,0,,of the database is in\Na second nesting,
Dialogue: 0,0:52:00.44,0:52:04.08,Default,,0,0,0,,so it's annotated by Un-two.
Dialogue: 0,0:52:04.36,0:52:09.36,Default,,0,0,0,,Whereas, the region around it\Nis at the nesting level one.
Dialogue: 0,0:52:09.88,0:52:12.68,Default,,0,0,0,,And so we will simply check\Ntwo is bigger than one,
Dialogue: 0,0:52:12.68,0:52:14.28,Default,,0,0,0,,so the borrow cannot escape.
Dialogue: 0,0:52:14.68,0:52:17.12,Default,,0,0,0,,And the type checker will\Nagain reject this.
Dialogue: 0,0:52:18.40,0:52:21.00,Default,,0,0,0,,Alright so we have borrows,\Nwe have closures, we have functions,
Dialogue: 0,0:52:21.08,0:52:23.04,Default,,0,0,0,,we have linearity. Let's\Nput everything together.
Dialogue: 0,0:52:24.56,0:52:27.40,Default,,0,0,0,,Here is the API for the database
Dialogue: 0,0:52:27.48,0:52:30.08,Default,,0,0,0,,that I've used since\Nthe beginning of this talk.
Dialogue: 0,0:52:30.40,0:52:33.04,Default,,0,0,0,,The type database is of kind linear,
Dialogue: 0,0:52:33.80,0:52:36.36,Default,,0,0,0,,we have defined functions,\Nthat take a borrow.
Dialogue: 0,0:52:37.16,0:52:43.20,Default,,0,0,0,,With its kind, and take\Nthe string and return an integer.
Dialogue: 0,0:52:43.96,0:52:47.88,Default,,0,0,0,,We have the add function that\Ntakes an exclusive borrow.
Dialogue: 0,0:52:48.12,0:52:50.60,Default,,0,0,0,,a string, an integer\Nand returns units.
Dialogue: 0,0:52:50.92,0:52:53.72,Default,,0,0,0,,And since the functions\Nare curried,
Dialogue: 0,0:52:53.76,0:52:57.28,Default,,0,0,0,,you can, here the database borrow
Dialogue: 0,0:52:57.36,0:52:59.16,Default,,0,0,0,,is captured later on\Nand so the functions
Dialogue: 0,0:52:59.20,0:53:03.20,Default,,0,0,0,,are annotated with\Nthe kind that is captured here.
Dialogue: 0,0:53:06.24,0:53:09.64,Default,,0,0,0,,Here is a simple use of this API,
Dialogue: 0,0:53:10.04,0:53:12.44,Default,,0,0,0,,as I said, which was\Npresented before.
Dialogue: 0,0:53:12.48,0:53:16.68,Default,,0,0,0,,So we have, two concurrent\NLookups,
Dialogue: 0,0:53:16.76,0:53:21.76,Default,,0,0,0,,grade Db, of the grade\NDB of two grade that math and compsci.
Dialogue: 0,0:53:22.36,0:53:24.08,Default,,0,0,0,,And then we compute the average.
Dialogue: 0,0:53:24.84,0:53:27.08,Default,,0,0,0,,We can factorize a little bit the
Dialogue: 0,0:53:27.88,0:53:29.24,Default,,0,0,0,,lookup aspect
Dialogue: 0,0:53:29.32,0:53:33.92,Default,,0,0,0,,by creating a grade function\Nthat captures a database,
Dialogue: 0,0:53:33.96,0:53:37.92,Default,,0,0,0,,and look up the topic\Nor the subjects of the grade.
Dialogue: 0,0:53:38.80,0:53:43.36,Default,,0,0,0,,And here we repeat\Nthe argument subject and subject.
Dialogue: 0,0:53:43.44,0:53:45.76,Default,,0,0,0,,so we can simply partially\Napply a function,
Dialogue: 0,0:53:45.92,0:53:50.96,Default,,0,0,0,,and it will compute the borrows\Nand the kinds accordingly.
Dialogue: 0,0:53:51.72,0:53:53.48,Default,,0,0,0,,And finally we can even go further
Dialogue: 0,0:53:53.56,0:53:58.00,Default,,0,0,0,,and use a function\Nabstraction to pull
Dialogue: 0,0:53:58.40,0:54:01.08,Default,,0,0,0,,the function computing\Nthe average outside
Dialogue: 0,0:54:01.16,0:54:03.68,Default,,0,0,0,,by taking a list of subjects
Dialogue: 0,0:54:04.08,0:54:07.88,Default,,0,0,0,,and applying a partially\Napplied function to map over the list,
Dialogue: 0,0:54:07.92,0:54:10.56,Default,,0,0,0,,and so on and so forth,\Nand use any other functions
Dialogue: 0,0:54:10.72,0:54:14.08,Default,,0,0,0,,as we would want to\Nin a functional language
Dialogue: 0,0:54:20.40,0:54:23.44,Default,,0,0,0,,The type checker will\Nannotate the region
Dialogue: 0,0:54:23.72,0:54:26.68,Default,,0,0,0,,as we would expect, here we are
Dialogue: 0,0:54:26.84,0:54:29.64,Default,,0,0,0,,the disjoint region\Nfor the shared borrow
Dialogue: 0,0:54:29.68,0:54:33.00,Default,,0,0,0,,and the exclusive borrow
Dialogue: 0,0:54:33.08,0:54:35.60,Default,,0,0,0,,and they are perfectly disjoint.
Dialogue: 0,0:54:35.84,0:54:37.32,Default,,0,0,0,,Finally, as we said before,
Dialogue: 0,0:54:37.32,0:54:38.92,Default,,0,0,0,,we have no type annotations,
Dialogue: 0,0:54:38.96,0:54:42.00,Default,,0,0,0,,so even if I used the average.
Dialogue: 0,0:54:42.32,0:54:46.04,Default,,0,0,0,,Even if I lifted\Nthe average function, I
Dialogue: 0,0:54:46.04,0:54:47.40,Default,,0,0,0,,I still have no type annotation
Dialogue: 0,0:54:47.48,0:54:49.52,Default,,0,0,0,,here we have complete\Ntype inference.
Dialogue: 0,0:54:50.32,0:54:53.56,Default,,0,0,0,,Alright so let's look a little bit
Dialogue: 0,0:54:53.60,0:54:56.28,Default,,0,0,0,,under the hood at\Ninference and constraints.
Dialogue: 0,0:54:56.68,0:55:00.16,Default,,0,0,0,,The first step is to\Nelaborate the regions.
Dialogue: 0,0:55:00.56,0:55:03.28,Default,,0,0,0,,By using the information provided
Dialogue: 0,0:55:03.44,0:55:06.84,Default,,0,0,0,,by the position of the borrow,\Nthe scopes of the borrows
Dialogue: 0,0:55:07.00,0:55:08.92,Default,,0,0,0,,and the borrowing rules I presented,
Dialogue: 0,0:55:08.96,0:55:11.00,Default,,0,0,0,,which allow us to\Ncompletely determine
Dialogue: 0,0:55:11.04,0:55:13.68,Default,,0,0,0,,the biggest region\Nwe could use.
Dialogue: 0,0:55:14.08,0:55:16.68,Default,,0,0,0,,The second step is to\Ngenerate constraints,
Dialogue: 0,0:55:17.28,0:55:20.88,Default,,0,0,0,,which encode type,\Nlinearity and borrowing checks.
Dialogue: 0,0:55:21.56,0:55:24.36,Default,,0,0,0,,And to check that
Dialogue: 0,0:55:24.48,0:55:26.84,Default,,0,0,0,,nothing escapes that shouldn't.
Dialogue: 0,0:55:26.84,0:55:30.00,Default,,0,0,0,,This constraint system\Nis customized to encode.
Dialogue: 0,0:55:30.00,0:55:34.40,Default,,0,0,0,,the rule we want\Nand based on HM(X).
Dialogue: 0,0:55:34.40,0:55:36.96,Default,,0,0,0,,Finally, we solve the constraints
Dialogue: 0,0:55:36.96,0:55:39.96,Default,,0,0,0,,using custom algorithms\Nthat we provide,
Dialogue: 0,0:55:39.96,0:55:47.12,Default,,0,0,0,,and we obtain principal type schemes\Nfor all the functions in our program.
Dialogue: 0,0:55:47.12,0:55:50.80,Default,,0,0,0,,So this principal type\Nscheme can sometimes still
Dialogue: 0,0:55:50.80,0:55:52.32,Default,,0,0,0,,be a little bit complicated,
Dialogue: 0,0:55:52.32,0:55:58.24,Default,,0,0,0,,and so we use the subkinding rules\Nconsidering positive and negative positions
Dialogue: 0,0:55:58.24,0:56:03.40,Default,,0,0,0,,to simplify the type further down.
Dialogue: 0,0:56:03.40,0:56:10.24,Default,,0,0,0,,Alright, and so we obtain, finally,\Nsimplified type schemes.
Dialogue: 0,0:56:10.64,0:56:14.16,Default,,0,0,0,,To summarize, I presented\Nthe Affe language,
Dialogue: 0,0:56:14.16,0:56:19.16,Default,,0,0,0,,a prototype is available\Nat this address online.
Dialogue: 0,0:56:19.60,0:56:23.24,Default,,0,0,0,,We've provided Linearity,\NClosure, Borrows and Regions,
Dialogue: 0,0:56:23.24,0:56:24.44,Default,,0,0,0,,to provide good support
Dialogue: 0,0:56:24.44,0:56:27.08,Default,,0,0,0,,for both imperative\Nand functional programming,
Dialogue: 0,0:56:27.08,0:56:29.44,Default,,0,0,0,,we support managed\Nand unmanaged objects,
Dialogue: 0,0:56:29.44,0:56:32.96,Default,,0,0,0,,and principal type inference,\Nwhich is something very remarkable,
Dialogue: 0,0:56:32.96,0:56:35.80,Default,,0,0,0,,for a type system supporting borrows.
Dialogue: 0,0:56:35.80,0:56:40.64,Default,,0,0,0,,The downside is that so far we do\Nnot support flow sensitivity,
Dialogue: 0,0:56:40.64,0:56:45.76,Default,,0,0,0,,we can emulate this a bit,\Nbut it has no proper support,
Dialogue: 0,0:56:46.12,0:56:49.12,Default,,0,0,0,,and we do not yet have\Na concurrency story
Dialogue: 0,0:56:49.12,0:56:51.12,Default,,0,0,0,,so that's something\Nwe're working on.
Dialogue: 0,0:56:51.12,0:56:54.24,Default,,0,0,0,,In the paper you can\Nfind many examples
Dialogue: 0,0:56:54.24,0:56:58.64,Default,,0,0,0,,to show that we can indeed support\Nmany types of programming,
Dialogue: 0,0:56:58.64,0:57:01.48,Default,,0,0,0,,both functional imperative.
Dialogue: 0,0:57:01.48,0:57:08.08,Default,,0,0,0,,On the theory side, we provide\Na syntax-directed type system for Affe,
Dialogue: 0,0:57:08.08,0:57:12.72,Default,,0,0,0,,how to encode into\Nan ML-style type-system,
Dialogue: 0,0:57:12.72,0:57:16.68,Default,,0,0,0,,we provide the formal account\Nof the semantics and proof of soundness,
Dialogue: 0,0:57:16.68,0:57:19.20,Default,,0,0,0,,and an inference algorithm for Affe,
Dialogue: 0,0:57:19.20,0:57:25.64,Default,,0,0,0,,which provide values, novel\Ncontribution in particular
Dialogue: 0,0:57:25.64,0:57:28.76,Default,,0,0,0,,an extension to HM(X),\Na novel constraint system
Dialogue: 0,0:57:28.76,0:57:33.44,Default,,0,0,0,,and its constraint simplification algorithm\Nand proof of completeness.
Dialogue: 0,0:57:33.44,0:57:35.20,Default,,0,0,0,,That's all I have.\NThank you very much.
Dialogue: 0,0:57:35.20,0:57:40.20,Default,,0,0,0,,(AUDIENCE APPLAUSE)
Dialogue: 0,0:57:42.56,0:57:44.60,Default,,0,0,0,,ALAN JEFFREY: So, thank you Gabriel.
Dialogue: 0,0:57:44.60,0:57:49.72,Default,,0,0,0,,So, if you want to join\Nthe authors for a live Q&A,
Dialogue: 0,0:57:49.72,0:57:54.72,Default,,0,0,0,,click on the link in\Nthe Clowdr room for this paper.
Dialogue: 0,0:58:00.12,0:58:04.76,Default,,0,0,0,,Hello and welcome back to\Nthe second session of ICFP 2020.
Dialogue: 0,0:58:05.20,0:58:07.56,Default,,0,0,0,,And our next paper is going to be
Dialogue: 0,0:58:07.56,0:58:11.68,Default,,0,0,0,,'Sealing Pointer-based Optimizations\Nbehind Pure Functions',
Dialogue: 0,0:58:11.68,0:58:15.12,Default,,0,0,0,,and it's going to be\Npresented by Daniel Selsam.
Dialogue: 0,0:58:15.12,0:58:16.12,Default,,0,0,0,,DANIEL SELSAM: Everybody,
Dialogue: 0,0:58:16.12,0:58:19.20,Default,,0,0,0,,my name is Daniel Selsam\Nfrom Microsoft Research.
Dialogue: 0,0:58:19.20,0:58:23.36,Default,,0,0,0,,I'll be presenting joint work with\NSimon Hudon from Carnegie Mellon,
Dialogue: 0,0:58:23.36,0:58:27.04,Default,,0,0,0,,and my colleague Leonardo de\NMoura from Microsoft Research.
Dialogue: 0,0:58:27.04,0:58:28.44,Default,,0,0,0,,Our paper is titled,
Dialogue: 0,0:58:28.44,0:58:32.64,Default,,0,0,0,,'Sealing Pointer-based Optimizations\Nbehind Pure Functions'.
Dialogue: 0,0:58:32.64,0:58:34.56,Default,,0,0,0,,Now, functional programming
Dialogue: 0,0:58:34.56,0:58:37.84,Default,,0,0,0,,really shines for\Ninteractive theorem provers.
Dialogue: 0,0:58:37.84,0:58:39.32,Default,,0,0,0,,For many reasons.
Dialogue: 0,0:58:39.32,0:58:42.36,Default,,0,0,0,,It's easy to encode terms\Nwith inductive types,
Dialogue: 0,0:58:42.36,0:58:46.64,Default,,0,0,0,,and this is actually\Nsurprisingly cumbersome in C++.
Dialogue: 0,0:58:46.64,0:58:50.20,Default,,0,0,0,,It's easy to traverse terms\Nwith higher-order combinators,
Dialogue: 0,0:58:50.20,0:58:55.08,Default,,0,0,0,,for example, it's easy to write\Nfunctions that replace sub-terms
Dialogue: 0,0:58:55.08,0:58:58.20,Default,,0,0,0,,of terms, or find sub-terms\Nmatching patterns.
Dialogue: 0,0:58:58.20,0:59:02.32,Default,,0,0,0,,And it's easy to backtrack using\Npersistent data-structures.
Dialogue: 0,0:59:02.32,0:59:05.96,Default,,0,0,0,,So, we can just snapshot the world,
Dialogue: 0,0:59:05.96,0:59:09.92,Default,,0,0,0,,try tactic one in that\Nworld and if it fails,
Dialogue: 0,0:59:09.92,0:59:12.92,Default,,0,0,0,,in constant time and no\Nextra programming effort,
Dialogue: 0,0:59:12.92,0:59:16.84,Default,,0,0,0,,we can just roll back\Nthe world to the snapshot
Dialogue: 0,0:59:16.84,0:59:21.12,Default,,0,0,0,,before we started tac1 and then\Ntry the second tactic in it.
Dialogue: 0,0:59:21.12,0:59:24.04,Default,,0,0,0,,And as we would expect, most\Ninteractive theorem provers
Dialogue: 0,0:59:24.04,0:59:26.92,Default,,0,0,0,,are written in functional\Nprogramming languages.
Dialogue: 0,0:59:26.92,0:59:31.36,Default,,0,0,0,,So, Isabelle/HOL is written in\NPoly/ML, Coq is written in OCaml,
Dialogue: 0,0:59:31.36,0:59:33.76,Default,,0,0,0,,Agda and Idris are\Nwritten in Haskell
Dialogue: 0,0:59:33.76,0:59:38.76,Default,,0,0,0,,and Lean3 was written in C++\Nat great spiritual cost,
Dialogue: 0,0:59:38.76,0:59:42.64,Default,,0,0,0,,but Lean4 is being\Nrewritten in Lean4 itself,
Dialogue: 0,0:59:42.64,0:59:45.60,Default,,0,0,0,,which is a functional\Nprogramming language.
Dialogue: 0,0:59:45.60,0:59:48.88,Default,,0,0,0,,But while functional programming\Nshines in this domain,
Dialogue: 0,0:59:48.88,0:59:52.16,Default,,0,0,0,,pure languages suffer\Na critical limitation
Dialogue: 0,0:59:52.16,0:59:55.08,Default,,0,0,0,,that we call Purity's Achilles Heal.
Dialogue: 0,0:59:55.08,0:59:58.84,Default,,0,0,0,,Which is that, "Traversing\Na term requires time proportional
Dialogue: 0,0:59:58.84,1:00:03.44,Default,,0,0,0,,to the tree size of the term,\Nas opposed to its graph size,
Dialogue: 0,1:00:03.44,1:00:08.00,Default,,0,0,0,,which causes exponential blowup\Nin theory and in practice."
Dialogue: 0,1:00:08.00,1:00:10.16,Default,,0,0,0,,And here's a little illustration.
Dialogue: 0,1:00:10.16,1:00:15.12,Default,,0,0,0,,On the left, there's a term\Nwhose DAG representation
Dialogue: 0,1:00:15.12,1:00:19.96,Default,,0,0,0,,has only four nodes, and in fact,\Nhas only four nodes in memory,
Dialogue: 0,1:00:19.96,1:00:23.28,Default,,0,0,0,,but when you view it as a tree, it\Nhas two to the four minus one node.
Dialogue: 0,1:00:23.28,1:00:27.36,Default,,0,0,0,,So, exponentially more nodes\Nin its tree representation
Dialogue: 0,1:00:27.36,1:00:29.92,Default,,0,0,0,,than in its graph representation.
Dialogue: 0,1:00:29.92,1:00:33.36,Default,,0,0,0,,And perhaps a surprising\Nempirical finding
Dialogue: 0,1:00:33.36,1:00:35.84,Default,,0,0,0,,is that terms with\Nastronomic tree sizes
Dialogue: 0,1:00:35.84,1:00:39.56,Default,,0,0,0,,are actually extremely common in\Ninteractive theorem provers.
Dialogue: 0,1:00:39.56,1:00:43.28,Default,,0,0,0,,So, it's well known that even\Nbasic operations can produce them.
Dialogue: 0,1:00:43.28,1:00:50.44,Default,,0,0,0,,So unifying two terms, where\Nthe function symbol has arity n,
Dialogue: 0,1:00:50.44,1:00:55.56,Default,,0,0,0,,can produce a term whose\Ntree size is two to the n.
Dialogue: 0,1:00:55.64,1:00:58.44,Default,,0,0,0,,But this is a somewhat\Ncontrived example.
Dialogue: 0,1:00:58.44,1:01:02.60,Default,,0,0,0,,But in reality, terms are often\Nthe result of long chains
Dialogue: 0,1:01:02.60,1:01:06.80,Default,,0,0,0,,of somewhat arbitrary user-written\Nmeta programs or tactics.
Dialogue: 0,1:01:06.80,1:01:10.60,Default,,0,0,0,,And at least in Lean's\Nmathematical library - Mathlib,
Dialogue: 0,1:01:10.60,1:01:14.84,Default,,0,0,0,,it's not uncommon for a proof\Nthat has only 20,000 nodes
Dialogue: 0,1:01:14.84,1:01:16.56,Default,,0,0,0,,in its DAG representation
Dialogue: 0,1:01:16.56,1:01:20.64,Default,,0,0,0,,to have over 2 billion nodes\Nin its tree representation.
Dialogue: 0,1:01:20.64,1:01:24.88,Default,,0,0,0,,And many performance issues in Coq\Nand Lean going back many years
Dialogue: 0,1:01:24.88,1:01:28.40,Default,,0,0,0,,have been the result of improper\Nhandling of such terms
Dialogue: 0,1:01:28.40,1:01:32.04,Default,,0,0,0,,despite having the needed\Nimpure tools at hand.
Dialogue: 0,1:01:32.04,1:01:35.16,Default,,0,0,0,,Basically, the exponential\Nblow up is so severe
Dialogue: 0,1:01:35.16,1:01:38.88,Default,,0,0,0,,that if a single module\Never traverses a term
Dialogue: 0,1:01:38.88,1:01:41.20,Default,,0,0,0,,with insufficiently precise caching
Dialogue: 0,1:01:41.20,1:01:44.52,Default,,0,0,0,,is very likely going\Nto be a bottleneck.
Dialogue: 0,1:01:44.52,1:01:48.12,Default,,0,0,0,,And now we can talk\Nabout our contribution.
Dialogue: 0,1:01:48.12,1:01:53.12,Default,,0,0,0,,So, we present a new way to, quote,\N'Seal' the needed optimizations -
Dialogue: 0,1:01:53.32,1:01:57.16,Default,,0,0,0,,the optimizations that you need to\Ntraverse terms in linear time.
Dialogue: 0,1:01:57.16,1:01:59.32,Default,,0,0,0,,We show how to seal\Nthese optimizations
Dialogue: 0,1:01:59.32,1:02:02.00,Default,,0,0,0,,behind pure functional interfaces.
Dialogue: 0,1:02:02.00,1:02:04.60,Default,,0,0,0,,And here's the main idea.
Dialogue: 0,1:02:04.60,1:02:07.16,Default,,0,0,0,,We start with a pure\Nreference implementation
Dialogue: 0,1:02:07.16,1:02:10.32,Default,,0,0,0,,of something that we want to optimize,
Dialogue: 0,1:02:10.32,1:02:13.96,Default,,0,0,0,,we find sufficient conditions\Nfor a particular optimization
Dialogue: 0,1:02:13.96,1:02:16.80,Default,,0,0,0,,to respect the reference\Nimplementation,
Dialogue: 0,1:02:16.80,1:02:20.00,Default,,0,0,0,,we then create a new primitive\Nthat takes these conditions
Dialogue: 0,1:02:20.00,1:02:23.24,Default,,0,0,0,,as 'preconditions'\Nusing dependent types
Dialogue: 0,1:02:23.24,1:02:27.24,Default,,0,0,0,,and otherwise is given the nominal\Npure reference implementation.
Dialogue: 0,1:02:27.24,1:02:31.52,Default,,0,0,0,,And then we just compile this\Nprimitive into the optimized version.
Dialogue: 0,1:02:31.52,1:02:34.08,Default,,0,0,0,,And a simple meta theoretic argument
Dialogue: 0,1:02:34.08,1:02:37.00,Default,,0,0,0,,establishes that\Nsince it was proved -
Dialogue: 0,1:02:37.00,1:02:41.40,Default,,0,0,0,,since the preconditions were approved,\Nthe optimization is settled.
Dialogue: 0,1:02:41.40,1:02:43.32,Default,,0,0,0,,And we show how to do\Nthis for several common
Dialogue: 0,1:02:43.32,1:02:47.08,Default,,0,0,0,,low-level optimizations,\Nincluding pointer equality tests,
Dialogue: 0,1:02:47.08,1:02:50.04,Default,,0,0,0,,and even direct\Npointer-address manipulations.
Dialogue: 0,1:02:50.04,1:02:52.08,Default,,0,0,0,,And we show how to use\Nthese new primitives
Dialogue: 0,1:02:52.08,1:02:53.72,Default,,0,0,0,,to traverse terms in linear time,
Dialogue: 0,1:02:53.72,1:02:56.72,Default,,0,0,0,,which is the problem\Nwe set out to solve.
Dialogue: 0,1:02:56.72,1:02:59.60,Default,,0,0,0,,So, perhaps the simplest\Npointer optimization
Dialogue: 0,1:02:59.60,1:03:04.28,Default,,0,0,0,,is just short-circuiting equality\Ntests using pointer equality.
Dialogue: 0,1:03:04.28,1:03:06.16,Default,,0,0,0,,And the idea is simple:
Dialogue: 0,1:03:06.16,1:03:09.56,Default,,0,0,0,,If two terms x and y have\Nthe same memory address,
Dialogue: 0,1:03:09.56,1:03:11.64,Default,,0,0,0,,they must be structurally equal.
Dialogue: 0,1:03:11.64,1:03:16.84,Default,,0,0,0,,So, you can skip the potentially\Nexponentially expensive
Dialogue: 0,1:03:16.92,1:03:19.76,Default,,0,0,0,,structural equality test\Nand just return true.
Dialogue: 0,1:03:19.76,1:03:21.88,Default,,0,0,0,,And the challenge here is\Nthat this optimization
Dialogue: 0,1:03:21.88,1:03:26.40,Default,,0,0,0,,is only sound in general\Nfor reflexive relations.
Dialogue: 0,1:03:26.44,1:03:28.76,Default,,0,0,0,,And the solution is somewhat simple:
Dialogue: 0,1:03:28.76,1:03:33.68,Default,,0,0,0,,Allow the optimization any relation\Nthat you can prove is reflexive.
Dialogue: 0,1:03:33.68,1:03:35.52,Default,,0,0,0,,Which brings us to our\Nfirst new primitive
Dialogue: 0,1:03:35.52,1:03:38.00,Default,,0,0,0,,which we call, 'withPtrEq'.
Dialogue: 0,1:03:38.00,1:03:42.72,Default,,0,0,0,,And now, withPtrEq takes two\Nterms x and y of type alpha,
Dialogue: 0,1:03:42.72,1:03:47.88,Default,,0,0,0,,and a thunk, k, that takes\Na unit type and returns Bool.
Dialogue: 0,1:03:47.88,1:03:54.24,Default,,0,0,0,,And the precondition, h,\Nis a proof that if x=y,
Dialogue: 0,1:03:54.24,1:03:57.48,Default,,0,0,0,,then this thunk, k, is\Ngoing to return true.
Dialogue: 0,1:03:57.48,1:04:00.76,Default,,0,0,0,,And then the overall primitive\NwithPtrEq returns Bool,
Dialogue: 0,1:04:00.76,1:04:05.40,Default,,0,0,0,,and it's pure reference implementation\Njust simply evaluates the thunk.
Dialogue: 0,1:04:05.40,1:04:08.36,Default,,0,0,0,,And now, the compiler will\Ntreat this as opaque
Dialogue: 0,1:04:08.36,1:04:10.96,Default,,0,0,0,,until reaching the low-level IR.
Dialogue: 0,1:04:10.96,1:04:15.36,Default,,0,0,0,,At which point it will\Nexpand a call to withPtrEq,
Dialogue: 0,1:04:15.36,1:04:18.28,Default,,0,0,0,,to the following\Npseudo code snippet:
Dialogue: 0,1:04:18.28,1:04:22.32,Default,,0,0,0,,It first checks of the pointer\Naddresses are the same of x and y,
Dialogue: 0,1:04:22.32,1:04:25.88,Default,,0,0,0,,if they are it returns true,\Notherwise it evaluates it up.
Dialogue: 0,1:04:25.88,1:04:29.16,Default,,0,0,0,,And the precondition, h,\Nguarantees that this version
Dialogue: 0,1:04:29.16,1:04:33.28,Default,,0,0,0,,respects the pure version\Nby a very simple argument.
Dialogue: 0,1:04:33.28,1:04:37.24,Default,,0,0,0,,Now, withPtrEq alone already\Ncan yield exponential speedups
Dialogue: 0,1:04:37.24,1:04:40.40,Default,,0,0,0,,on pointer-equal terms trivially.
Dialogue: 0,1:04:40.40,1:04:44.80,Default,,0,0,0,,But small deviations from\Npointer-equal from pointer-equality
Dialogue: 0,1:04:44.80,1:04:46.64,Default,,0,0,0,,remove the benefit entirely.
Dialogue: 0,1:04:46.64,1:04:49.80,Default,,0,0,0,,So, this is\Nan illustration of two terms
Dialogue: 0,1:04:49.80,1:04:54.68,Default,,0,0,0,,that share memory pointer\Nshare an enormous tower,
Dialogue: 0,1:04:54.68,1:04:56.28,Default,,0,0,0,,but their heads are\Nactually different.
Dialogue: 0,1:04:56.28,1:05:00.80,Default,,0,0,0,,So, they are not themselves PtrEq,\Neven though their children are.
Dialogue: 0,1:05:00.80,1:05:04.04,Default,,0,0,0,,So, a single call to withPtrEq
Dialogue: 0,1:05:04.04,1:05:06.08,Default,,0,0,0,,will just see that they're\Nnot pointer-equal,
Dialogue: 0,1:05:06.08,1:05:10.08,Default,,0,0,0,,and fall back on recursive\Nstructural equality.
Dialogue: 0,1:05:10.08,1:05:14.52,Default,,0,0,0,,Obviously, what we want is to\Ncall withPtrEq recursively
Dialogue: 0,1:05:14.52,1:05:18.00,Default,,0,0,0,,on the children, and we can do that.
Dialogue: 0,1:05:18.00,1:05:19.60,Default,,0,0,0,,The construction is\Nsomewhat elaborate,
Dialogue: 0,1:05:19.60,1:05:23.64,Default,,0,0,0,,but it's entirely mechanizable,\Nrequires no new primitives,
Dialogue: 0,1:05:23.64,1:05:28.16,Default,,0,0,0,,and the paper goes into\Nthe details for those who are curious.
Dialogue: 0,1:05:28.16,1:05:32.00,Default,,0,0,0,,Now we're almost ready to\Ntraverse terms in linear-time.
Dialogue: 0,1:05:32.00,1:05:34.92,Default,,0,0,0,,Consider the naive\Nexponential time algorithm
Dialogue: 0,1:05:34.92,1:05:39.96,Default,,0,0,0,,to evaluate a simple arithmetic\Nterm into a natural number.
Dialogue: 0,1:05:39.96,1:05:41.68,Default,,0,0,0,,So, then here we have a term type
Dialogue: 0,1:05:41.68,1:05:44.88,Default,,0,0,0,,that has two constructors\None and add.
Dialogue: 0,1:05:44.88,1:05:47.08,Default,,0,0,0,,So, we can just evaluate\Nthis into a map
Dialogue: 0,1:05:47.08,1:05:49.52,Default,,0,0,0,,by mapping one to the numeral one,
Dialogue: 0,1:05:49.52,1:05:54.16,Default,,0,0,0,,and by evaluating add t1,\Nt2, by first evaluating t1,
Dialogue: 0,1:05:54.16,1:05:57.48,Default,,0,0,0,,and evaluating t2, and adding\Nthe results together.
Dialogue: 0,1:05:57.48,1:06:01.08,Default,,0,0,0,,Now, we're gonna show how to use\NwithPtrEq the recursive version,
Dialogue: 0,1:06:01.08,1:06:05.00,Default,,0,0,0,,to build a linear-time\Nversion of this algorithm.
Dialogue: 0,1:06:05.00,1:06:07.00,Default,,0,0,0,,We need two additional components,
Dialogue: 0,1:06:07.00,1:06:09.32,Default,,0,0,0,,we need constant-time\Nintrusive hashing,
Dialogue: 0,1:06:09.32,1:06:11.92,Default,,0,0,0,,and we need something that we\Ncall 'sharing the common data'
Dialogue: 0,1:06:11.92,1:06:14.12,Default,,0,0,0,,which I'll discuss shortly.
Dialogue: 0,1:06:14.12,1:06:18.76,Default,,0,0,0,,So, it's almost hard to believe\Nbut even just computing the hash
Dialogue: 0,1:06:18.76,1:06:22.04,Default,,0,0,0,,of a tower requires\Nexponential time.
Dialogue: 0,1:06:22.04,1:06:25.92,Default,,0,0,0,,But hashing, unlike equality,\Nis a unary function.
Dialogue: 0,1:06:25.92,1:06:29.48,Default,,0,0,0,,So, in principal, we can compute it\Nonce and just store it somewhere.
Dialogue: 0,1:06:29.48,1:06:31.40,Default,,0,0,0,,Which brings us to\Nthis folklore trick,
Dialogue: 0,1:06:31.40,1:06:34.12,Default,,0,0,0,,which we call intrusive hashing,
Dialogue: 0,1:06:34.12,1:06:38.40,Default,,0,0,0,,which is to simply extend\Nthe term type itself
Dialogue: 0,1:06:38.40,1:06:40.48,Default,,0,0,0,,to store the hashes of the terms
Dialogue: 0,1:06:40.48,1:06:43.08,Default,,0,0,0,,as extra arguments to\Nthe constructors.
Dialogue: 0,1:06:43.08,1:06:46.60,Default,,0,0,0,,So, here the third argument\Nto add is an adder,
Dialogue: 0,1:06:46.60,1:06:49.84,Default,,0,0,0,,which is just our type that\Nrepresents hashes in this case,
Dialogue: 0,1:06:49.84,1:06:53.48,Default,,0,0,0,,and we can write a fast\Nconstant-time hash function
Dialogue: 0,1:06:53.48,1:06:56.72,Default,,0,0,0,,that simply projects\Nout of this hash field.
Dialogue: 0,1:06:56.72,1:06:59.04,Default,,0,0,0,,And we can write a smart constructor
Dialogue: 0,1:06:59.04,1:07:02.64,Default,,0,0,0,,that internally calls\Nthe built in constructor,
Dialogue: 0,1:07:02.64,1:07:04.84,Default,,0,0,0,,but will compute\Nthe hash automatically
Dialogue: 0,1:07:04.84,1:07:08.56,Default,,0,0,0,,using the fast hash on the children.
Dialogue: 0,1:07:08.56,1:07:12.28,Default,,0,0,0,,Now, Lean4 has reference counting\Nand disruptive-updates,
Dialogue: 0,1:07:12.28,1:07:15.36,Default,,0,0,0,,so, we can actually use\Nimperative hash tables
Dialogue: 0,1:07:15.36,1:07:19.24,Default,,0,0,0,,and get the desired expected\NO(1) lookup time.
Dialogue: 0,1:07:19.24,1:07:21.84,Default,,0,0,0,,But, if your language does\Nnot have this feature,
Dialogue: 0,1:07:21.84,1:07:25.52,Default,,0,0,0,,then you can still use functional\Nor persistent hash tables,
Dialogue: 0,1:07:25.52,1:07:29.40,Default,,0,0,0,,and then all of the same\Nconstructions applied,
Dialogue: 0,1:07:29.40,1:07:34.40,Default,,0,0,0,,but every time we say linear really\Nmeans quasi-linear for you.
Dialogue: 0,1:07:34.92,1:07:42.52,Default,,0,0,0,,Now, the semi-naive traversal,\Nwe call evalFastEqFastHash.
Dialogue: 0,1:07:42.52,1:07:47.92,Default,,0,0,0,,Which is to use the recursive\NwithPtrEq test for the equality,
Dialogue: 0,1:07:47.96,1:07:51.84,Default,,0,0,0,,and to also cache using\Nthe constant-time
Dialogue: 0,1:07:51.84,1:07:55.08,Default,,0,0,0,,intrusive cache and a hash cache.
Dialogue: 0,1:07:55.08,1:07:58.36,Default,,0,0,0,,Now, this is already linear\Ntime on this example,
Dialogue: 0,1:07:58.36,1:08:01.20,Default,,0,0,0,,strictly because of\Nthe recursive withPtrEq.
Dialogue: 0,1:08:01.20,1:08:03.88,Default,,0,0,0,,And because of\Nthe intrusive hash cache,
Dialogue: 0,1:08:03.88,1:08:09.20,Default,,0,0,0,,is also linear time on this\Nexample, in expectation because,
Dialogue: 0,1:08:09.28,1:08:12.92,Default,,0,0,0,,with high probability the hashes\Nare going to be different,
Dialogue: 0,1:08:12.92,1:08:15.64,Default,,0,0,0,,and in the small chance\Nthat they're the same,
Dialogue: 0,1:08:15.64,1:08:20.52,Default,,0,0,0,,they're very unlikely to be the same\Nagain for the children and so on.
Dialogue: 0,1:08:20.52,1:08:24.20,Default,,0,0,0,,But this semi-naive algorithm
Dialogue: 0,1:08:24.20,1:08:27.16,Default,,0,0,0,,is still exponential\Ntime on this example,
Dialogue: 0,1:08:27.16,1:08:32.32,Default,,0,0,0,,where we have two structurally equal\Nterms that are pointer disjoint.
Dialogue: 0,1:08:32.32,1:08:35.00,Default,,0,0,0,,And this brings us to\Nsharing the common data.
Dialogue: 0,1:08:35.00,1:08:37.52,Default,,0,0,0,,So, with low-level\Npointer manipulations,
Dialogue: 0,1:08:37.52,1:08:41.44,Default,,0,0,0,,we can, quote, 'share\Nthe common data' in linear-time.
Dialogue: 0,1:08:41.44,1:08:45.28,Default,,0,0,0,,And what we mean by that is\Nto take a term like this
Dialogue: 0,1:08:45.28,1:08:49.48,Default,,0,0,0,,that has multiple sub-terms\Nthat are structurally equal,
Dialogue: 0,1:08:49.48,1:08:50.96,Default,,0,0,0,,but pointer disjoint,
Dialogue: 0,1:08:50.96,1:08:55.32,Default,,0,0,0,,and simply share the common\Ndata or contact to the term
Dialogue: 0,1:08:55.32,1:09:00.60,Default,,0,0,0,,and produce the term such that\Nequality implies pointer-equality
Dialogue: 0,1:09:00.68,1:09:03.20,Default,,0,0,0,,of all sub-terms inside the term.
Dialogue: 0,1:09:03.20,1:09:07.28,Default,,0,0,0,,And now in the paper, we\Nintroduce additional primitives
Dialogue: 0,1:09:07.28,1:09:11.00,Default,,0,0,0,,that allow writing pure\Nversions of this procedure
Dialogue: 0,1:09:11.00,1:09:13.48,Default,,0,0,0,,from first principles\Nin linear time.
Dialogue: 0,1:09:13.48,1:09:16.36,Default,,0,0,0,,But, as part of the Lean runtime,
Dialogue: 0,1:09:16.36,1:09:19.68,Default,,0,0,0,,we already have a high performance\Nversion of this procedure
Dialogue: 0,1:09:19.68,1:09:21.80,Default,,0,0,0,,that applies to objects of any type.
Dialogue: 0,1:09:21.80,1:09:25.00,Default,,0,0,0,,So, there's no additional trust\Nrequired to simply expose it.
Dialogue: 0,1:09:25.00,1:09:28.96,Default,,0,0,0,,So, we present a new\Nprimitive shareCommon
Dialogue: 0,1:09:28.96,1:09:31.64,Default,,0,0,0,,that is just the identity function
Dialogue: 0,1:09:31.64,1:09:34.96,Default,,0,0,0,,whose reference implementation\Nis just the identity function,
Dialogue: 0,1:09:34.96,1:09:37.32,Default,,0,0,0,,it actually takes no\Nadditional preconditions.
Dialogue: 0,1:09:37.32,1:09:38.52,Default,,0,0,0,,But under the hood,
Dialogue: 0,1:09:38.52,1:09:41.52,Default,,0,0,0,,it's going to share the common\N- use the runtime support
Dialogue: 0,1:09:41.52,1:09:45.20,Default,,0,0,0,,to share the common data inside x.
Dialogue: 0,1:09:45.20,1:09:49.12,Default,,0,0,0,,And finally, we have a robust\Nlinear-time traversal,
Dialogue: 0,1:09:49.12,1:09:52.24,Default,,0,0,0,,which we are - to be\Noverly pedantic,
Dialogue: 0,1:09:52.24,1:09:57.04,Default,,0,0,0,,call evalFastEqFastHashShareCommon,\Nand the idea is simple,
Dialogue: 0,1:09:57.04,1:10:00.80,Default,,0,0,0,,we first share the common data\Nwhich takes linear-time,
Dialogue: 0,1:10:00.80,1:10:03.76,Default,,0,0,0,,and then we call evalFastEqFastHash,
Dialogue: 0,1:10:03.76,1:10:08.92,Default,,0,0,0,,which is linear-time as long as\Nthe data is being maximally shared.
Dialogue: 0,1:10:09.60,1:10:12.00,Default,,0,0,0,,And our motto in general\Nis if terms are equal,
Dialogue: 0,1:10:12.00,1:10:14.00,Default,,0,0,0,,they should be pointer-equal,
Dialogue: 0,1:10:14.00,1:10:17.36,Default,,0,0,0,,and they will definitely be\Npointer-equal after shareCommon.
Dialogue: 0,1:10:17.44,1:10:21.20,Default,,0,0,0,,And if terms are not equal,\Ntheir constant-time hashes
Dialogue: 0,1:10:21.20,1:10:24.36,Default,,0,0,0,,should not be equal\Nwith high probability.
Dialogue: 0,1:10:24.36,1:10:27.16,Default,,0,0,0,,Now, the paper covers\Nmany extensions
Dialogue: 0,1:10:27.16,1:10:29.36,Default,,0,0,0,,and alternatives to this approach.
Dialogue: 0,1:10:29.36,1:10:31.96,Default,,0,0,0,,I'll go through a couple\Nexamples very briefly.
Dialogue: 0,1:10:31.96,1:10:34.56,Default,,0,0,0,,So, we can have\Na pointer equality test
Dialogue: 0,1:10:34.56,1:10:37.56,Default,,0,0,0,,without requiring\Nreflexivity as follows.
Dialogue: 0,1:10:37.56,1:10:42.12,Default,,0,0,0,,Here's a primitive withPtrEqResult\Nthat takes two terms x and y.
Dialogue: 0,1:10:42.12,1:10:44.16,Default,,0,0,0,,And instead of a thunk, k,
Dialogue: 0,1:10:44.16,1:10:47.28,Default,,0,0,0,,it's a continuation that gets\Nto see an optional proof
Dialogue: 0,1:10:47.28,1:10:48.72,Default,,0,0,0,,that x equals y.
Dialogue: 0,1:10:48.72,1:10:50.44,Default,,0,0,0,,But instead of returning a Bool in,
Dialogue: 0,1:10:50.44,1:10:53.56,Default,,0,0,0,,it returns an element\Nof any type beta.
Dialogue: 0,1:10:53.56,1:10:55.12,Default,,0,0,0,,And now the precondition we need
Dialogue: 0,1:10:55.12,1:10:57.48,Default,,0,0,0,,is that no matter what\Nproof we give it,
Dialogue: 0,1:10:57.48,1:10:59.16,Default,,0,0,0,,or what optional proof we give it,
Dialogue: 0,1:10:59.16,1:11:02.08,Default,,0,0,0,,this continuation is gonna\Nreturn the same value.
Dialogue: 0,1:11:02.08,1:11:06.04,Default,,0,0,0,,And the reference implementation\Njust calls it on none.
Dialogue: 0,1:11:06.04,1:11:09.08,Default,,0,0,0,,But at runtime, if x\Nand y are pointer-equal,
Dialogue: 0,1:11:09.08,1:11:12.20,Default,,0,0,0,,we call it with\Nthe proof of reflexivity.
Dialogue: 0,1:11:12.20,1:11:16.60,Default,,0,0,0,,And we can also support direct\Npointer address manipulation
Dialogue: 0,1:11:16.60,1:11:19.56,Default,,0,0,0,,with the new primitive withPtrAddr,
Dialogue: 0,1:11:19.56,1:11:23.52,Default,,0,0,0,,which takes a term x whose\Naddress we wanna inspect
Dialogue: 0,1:11:23.52,1:11:28.56,Default,,0,0,0,,and it takes a continuation, k, that\Nis going to look at that address
Dialogue: 0,1:11:28.56,1:11:32.00,Default,,0,0,0,,and again, return an element\Nof an arbitrary type beta.
Dialogue: 0,1:11:32.00,1:11:33.88,Default,,0,0,0,,And the precondition we need here
Dialogue: 0,1:11:33.88,1:11:38.92,Default,,0,0,0,,is that no matter what address we\Ngive k, k returns the same value.
Dialogue: 0,1:11:38.92,1:11:40.96,Default,,0,0,0,,And then the reference\Nimplementation
Dialogue: 0,1:11:40.96,1:11:45.00,Default,,0,0,0,,just evaluates k at\Nan arbitrary value, zero,
Dialogue: 0,1:11:45.00,1:11:49.32,Default,,0,0,0,,whereas the optimized\Nversion will evaluate k
Dialogue: 0,1:11:49.32,1:11:51.68,Default,,0,0,0,,on the actual memory address of x.
Dialogue: 0,1:11:51.68,1:11:55.84,Default,,0,0,0,,And the proof very\Ntrivially implies that
Dialogue: 0,1:11:55.84,1:12:00.24,Default,,0,0,0,,the optimized version is\Nfunctionally indistinguishable
Dialogue: 0,1:12:00.24,1:12:02.72,Default,,0,0,0,,from the pure reference\Nimplementation.
Dialogue: 0,1:12:02.72,1:12:05.40,Default,,0,0,0,,Perhaps the surprising\Npart of this is that
Dialogue: 0,1:12:05.40,1:12:07.80,Default,,0,0,0,,this precondition\Nisn't too restrictive.
Dialogue: 0,1:12:07.80,1:12:10.28,Default,,0,0,0,,And we show in the paper\Nthat indeed we can do
Dialogue: 0,1:12:10.28,1:12:14.84,Default,,0,0,0,,many many sophisticated\Nconstructions using withPtrAddr.
Dialogue: 0,1:12:14.84,1:12:18.60,Default,,0,0,0,,And in fact, combining\NwithPtrEqResult and withPtrAddr,
Dialogue: 0,1:12:18.60,1:12:22.16,Default,,0,0,0,,we can implement pointer\Ncaches from first principals,
Dialogue: 0,1:12:22.16,1:12:26.40,Default,,0,0,0,,and we can implement shareCommon\Nfrom first principals, and so forth.
Dialogue: 0,1:12:26.40,1:12:31.40,Default,,0,0,0,,We recommend the\NFastEqFastHashShareCommon approach
Dialogue: 0,1:12:31.40,1:12:34.72,Default,,0,0,0,,in general. It gives very good performance in\Nall our use cases in practice,
Dialogue: 0,1:12:34.72,1:12:36.24,Default,,0,0,0,,it's simple,
Dialogue: 0,1:12:36.24,1:12:39.72,Default,,0,0,0,,and the other constructions are\Nsignificantly more elaborate
Dialogue: 0,1:12:39.72,1:12:41.12,Default,,0,0,0,,for very little payoff.
Dialogue: 0,1:12:41.12,1:12:44.84,Default,,0,0,0,,And thank you, that's all\Nwe have time for today.
Dialogue: 0,1:12:44.84,1:12:49.84,Default,,0,0,0,,(AUDIENCE APPLAUSE)
Dialogue: 0,1:12:52.16,1:12:53.92,Default,,0,0,0,,ALAN JEFFREY: Alright,\Nthank you, Daniel.
Dialogue: 0,1:12:53.92,1:12:59.84,Default,,0,0,0,,So, if you're interested in joining\Nthe authors for a live Q&A,
Dialogue: 0,1:12:59.92,1:13:01.72,Default,,0,0,0,,and you're in the New York time zone,
Dialogue: 0,1:13:01.72,1:13:06.72,Default,,0,0,0,,then click on the link in\Nthe Clowdr page for this paper.
Dialogue: 0,1:13:12.28,1:13:15.64,Default,,0,0,0,,Welcome back to ICFP 2020,
Dialogue: 0,1:13:15.64,1:13:19.56,Default,,0,0,0,,where the next paper is going to\Nbe, "Effects for Efficiency:
Dialogue: 0,1:13:19.56,1:13:22.40,Default,,0,0,0,,Asymptotic Speedup with\NFirst-Class Control,"
Dialogue: 0,1:13:22.80,1:13:27.40,Default,,0,0,0,,and it's going to be presented\Nby Daniel HillerstrÃ¶m.
Dialogue: 0,1:13:27.40,1:13:29.52,Default,,0,0,0,,DANIEL HILLERSTRÃM: Hi, my\Nname is Daniel HillerstrÃ¶m,
Dialogue: 0,1:13:29.52,1:13:31.76,Default,,0,0,0,,and I'd like to tell you about\Nsome recent work I've done
Dialogue: 0,1:13:31.80,1:13:33.72,Default,,0,0,0,,with Sam Lindley and John Longley,
Dialogue: 0,1:13:33.72,1:13:35.80,Default,,0,0,0,,on how the presence of\Nfirst-class control
Dialogue: 0,1:13:35.80,1:13:39.20,Default,,0,0,0,,your language can speed up\Nimplementations of some programs.
Dialogue: 0,1:13:39.20,1:13:40.40,Default,,0,0,0,,I'll dive right in.
Dialogue: 0,1:13:40.40,1:13:43.08,Default,,0,0,0,,The purpose of this work is\Nreally to explore space.
Dialogue: 0,1:13:43.08,1:13:44.20,Default,,0,0,0,,The space I have in mind here
Dialogue: 0,1:13:44.20,1:13:46.60,Default,,0,0,0,,is the design space of\Nprogramming languages.
Dialogue: 0,1:13:46.60,1:13:49.36,Default,,0,0,0,,When studying the expressiveness\Nof some language feature,
Dialogue: 0,1:13:49.36,1:13:50.76,Default,,0,0,0,,like first class control,
Dialogue: 0,1:13:50.76,1:13:53.60,Default,,0,0,0,,it is customary to consider\Nlanguage with the said feature,
Dialogue: 0,1:13:53.60,1:13:56.12,Default,,0,0,0,,and then the fragment\Nmodulo that feature.
Dialogue: 0,1:13:56.12,1:13:58.92,Default,,0,0,0,,Then we could pose questions along\Ndifferent dimensions success,
Dialogue: 0,1:13:59.00,1:14:00.00,Default,,0,0,0,,computability...
Dialogue: 0,1:14:00.48,1:14:02.32,Default,,0,0,0,, complexity\Nand programmability.
Dialogue: 0,1:14:02.32,1:14:05.24,Default,,0,0,0,,However, any type of question\Nis really only interesting
Dialogue: 0,1:14:05.24,1:14:07.64,Default,,0,0,0,,if the setting involves\Nhigher types,
Dialogue: 0,1:14:07.64,1:14:09.48,Default,,0,0,0,,because to a fair approximation,
Dialogue: 0,1:14:09.48,1:14:11.64,Default,,0,0,0,,we can regard all\Nreasonable languages,
Dialogue: 0,1:14:11.64,1:14:15.00,Default,,0,0,0,,with first-order types\Nas being equi-expressive.
Dialogue: 0,1:14:15.00,1:14:17.56,Default,,0,0,0,,So in this work, we are in\Nthe realm of higher types,
Dialogue: 0,1:14:17.56,1:14:18.72,Default,,0,0,0,,and we show that in this realm,
Dialogue: 0,1:14:18.72,1:14:20.76,Default,,0,0,0,,the presence of first\Nclass control can improve
Dialogue: 0,1:14:20.76,1:14:23.88,Default,,0,0,0,,the asymptotic run time\Nof some programs.
Dialogue: 0,1:14:23.88,1:14:26.16,Default,,0,0,0,,To show this, we consider\Nthis generic count problem
Dialogue: 0,1:14:26.16,1:14:27.76,Default,,0,0,0,,which asks us to implement\Nthe third-order function
Dialogue: 0,1:14:27.76,1:14:29.80,Default,,0,0,0,,satisfying this type signature.
Dialogue: 0,1:14:29.80,1:14:32.04,Default,,0,0,0,,Let's unpack the type.
Dialogue: 0,1:14:32.04,1:14:35.24,Default,,0,0,0,,The first order function\Nparameter is called a point.
Dialogue: 0,1:14:35.24,1:14:36.56,Default,,0,0,0,,It is a functional representation
Dialogue: 0,1:14:36.56,1:14:39.36,Default,,0,0,0,,of a boolean value vector of size N.
Dialogue: 0,1:14:39.36,1:14:41.84,Default,,0,0,0,,The second order parameter\Nis a predicate function,
Dialogue: 0,1:14:41.84,1:14:43.52,Default,,0,0,0,,which operates on points.
Dialogue: 0,1:14:43.52,1:14:45.64,Default,,0,0,0,,It is an encoding of\Nsome search problem,
Dialogue: 0,1:14:45.64,1:14:47.76,Default,,0,0,0,,and it yields true\Nor false depending on
Dialogue: 0,1:14:47.76,1:14:50.84,Default,,0,0,0,,where it is satisfied\Nby its provided point.
Dialogue: 0,1:14:50.84,1:14:54.48,Default,,0,0,0,,Finally, any faithful implementation\Nof this type signature
Dialogue: 0,1:14:54.48,1:14:56.72,Default,,0,0,0,,ultimately returns\Nthe number of points
Dialogue: 0,1:14:56.72,1:15:00.08,Default,,0,0,0,,satisfying a given predicate,\Nor in other words,
Dialogue: 0,1:15:00.08,1:15:03.76,Default,,0,0,0,,it counts to number of times\Na given predicate returns true.
Dialogue: 0,1:15:03.76,1:15:06.76,Default,,0,0,0,,We fix our base language\Nto be simple typed PCF
Dialogue: 0,1:15:06.80,1:15:09.08,Default,,0,0,0,,and extended with effect handlers.
Dialogue: 0,1:15:09.08,1:15:12.76,Default,,0,0,0,,Our concrete choice of control\Noperator is not essential.
Dialogue: 0,1:15:12.76,1:15:14.92,Default,,0,0,0,,Any first class control\Noperator will do,
Dialogue: 0,1:15:14.92,1:15:17.08,Default,,0,0,0,,however effect handlers\Nstill provide a particular
Dialogue: 0,1:15:17.08,1:15:18.96,Default,,0,0,0,,structured form of\Ndelimited control,
Dialogue: 0,1:15:18.96,1:15:22.72,Default,,0,0,0,,which makes them convenient\Nfor the purpose of this work.
Dialogue: 0,1:15:22.72,1:15:24.68,Default,,0,0,0,,Then we first show that there\Nexists an implementation
Dialogue: 0,1:15:24.68,1:15:27.00,Default,,0,0,0,,of that generic count in PCF\Nfor the effect handlers,
Dialogue: 0,1:15:27.00,1:15:29.76,Default,,0,0,0,,whose asymptotic worst\Ncase runtime behavior
Dialogue: 0,1:15:29.76,1:15:32.44,Default,,0,0,0,,is two to the N.
Dialogue: 0,1:15:32.44,1:15:35.00,Default,,0,0,0,,Then we show that every\Nimplementation of generic count
Dialogue: 0,1:15:35.00,1:15:38.56,Default,,0,0,0,,in pure PCF has at least\Nasymptotic runtime behavior
Dialogue: 0,1:15:38.56,1:15:41.08,Default,,0,0,0,,N two to the N.
Dialogue: 0,1:15:41.08,1:15:42.28,Default,,0,0,0,,That is to say there exist
Dialogue: 0,1:15:42.28,1:15:44.08,Default,,0,0,0,,a strict asymptotic efficiency gap
Dialogue: 0,1:15:44.08,1:15:46.60,Default,,0,0,0,,between PCF and PCF\Nwith effect handlers,
Dialogue: 0,1:15:46.60,1:15:49.40,Default,,0,0,0,,due to the presence of first\Nclass control in the latter.
Dialogue: 0,1:15:49.40,1:15:50.72,Default,,0,0,0,,In this talk, I will not provide you
Dialogue: 0,1:15:50.72,1:15:53.00,Default,,0,0,0,,with the actual proof of this.
Dialogue: 0,1:15:53.00,1:15:54.92,Default,,0,0,0,,Instead, I'll aim to\Ngive you the intuition
Dialogue: 0,1:15:54.92,1:15:57.36,Default,,0,0,0,,for why this result is true.
Dialogue: 0,1:15:57.36,1:16:00.92,Default,,0,0,0,,I will elaborate a bit\Non our methodology.
Dialogue: 0,1:16:00.92,1:16:03.48,Default,,0,0,0,,We impose one important rule,\Nnamely that the type signature
Dialogue: 0,1:16:03.48,1:16:05.60,Default,,0,0,0,,of generic count is fixed.
Dialogue: 0,1:16:05.60,1:16:08.92,Default,,0,0,0,,That is no implementation in\NPCF or PCF with effect handlers
Dialogue: 0,1:16:08.92,1:16:12.88,Default,,0,0,0,,is allowed to change the type\Nsignature of generic count.
Dialogue: 0,1:16:12.88,1:16:15.32,Default,,0,0,0,,A consequence of this rule,\Nis that it's not possible
Dialogue: 0,1:16:15.32,1:16:18.68,Default,,0,0,0,,to translate PCF with effect\Nhandlers into PCF,
Dialogue: 0,1:16:18.68,1:16:22.20,Default,,0,0,0,,say by way of an interpreter\Nor CPS translation.
Dialogue: 0,1:16:22.20,1:16:24.92,Default,,0,0,0,,This way we really get to\Nstudy the essence of the power
Dialogue: 0,1:16:24.92,1:16:27.68,Default,,0,0,0,,provided by effect\Nhandlers. Moreover
Dialogue: 0,1:16:27.68,1:16:30.08,Default,,0,0,0,,this rule is also reminiscent\Nof the restriction
Dialogue: 0,1:16:30.08,1:16:32.20,Default,,0,0,0,,that programs are\Nfaced by every day,
Dialogue: 0,1:16:32.20,1:16:33.92,Default,,0,0,0,,when programming\Nagainst an interface.
Dialogue: 0,1:16:33.92,1:16:36.72,Default,,0,0,0,,So we do consider this to\Nbe a reasonable rule.
Dialogue: 0,1:16:36.72,1:16:39.44,Default,,0,0,0,,With this in mind, let's look\Nat the following example predicate
Dialogue: 0,1:16:39.44,1:16:42.52,Default,,0,0,0,,called EX and its\Ninduced computation tree model.
Dialogue: 0,1:16:42.52,1:16:45.04,Default,,0,0,0,,The predicate takes a point as input
Dialogue: 0,1:16:45.04,1:16:47.16,Default,,0,0,0,,and applies this point to zero,
Dialogue: 0,1:16:47.16,1:16:50.16,Default,,0,0,0,,or queries to see if\Ncomponent has the point.
Dialogue: 0,1:16:50.16,1:16:51.96,Default,,0,0,0,,This is reflected in the tree model,
Dialogue: 0,1:16:51.96,1:16:55.88,Default,,0,0,0,,by the first interior node,\Nwhich reads question mark zero.
Dialogue: 0,1:16:55.88,1:16:58.20,Default,,0,0,0,,I'm using the question\Nmark prefix here
Dialogue: 0,1:16:58.20,1:17:02.00,Default,,0,0,0,,to denote invocations\Nor queries of points.
Dialogue: 0,1:17:02.00,1:17:04.52,Default,,0,0,0,,And I'm using\Nexclamation mark prefix
Dialogue: 0,1:17:04.52,1:17:08.84,Default,,0,0,0,,to denote answers or return\Nvalues of predicates.
Dialogue: 0,1:17:08.84,1:17:13.36,Default,,0,0,0,,Now note how the structure\Nof the computation tree
Dialogue: 0,1:17:13.36,1:17:16.32,Default,,0,0,0,,coincides with all\Nthe possible control flows
Dialogue: 0,1:17:16.32,1:17:17.76,Default,,0,0,0,,of the predicate.
Dialogue: 0,1:17:17.76,1:17:22.36,Default,,0,0,0,,Let's consider a concrete\Nevaluation of this predicate.
Dialogue: 0,1:17:22.36,1:17:26.60,Default,,0,0,0,,Supposed we apply to a point\Nwhose zeroth component is true.
Dialogue: 0,1:17:26.88,1:17:31.84,Default,,0,0,0,,First component is false,\Nand second component is true.
Dialogue: 0,1:17:32.20,1:17:34.04,Default,,0,0,0,,Evaluation begins in the predicate,
Dialogue: 0,1:17:34.04,1:17:37.08,Default,,0,0,0,,and eventually queries the\Nzeroth component of the point,
Dialogue: 0,1:17:37.08,1:17:38.52,Default,,0,0,0,,which is true,
Dialogue: 0,1:17:38.52,1:17:41.84,Default,,0,0,0,,meaning that we'll take\Nthe left branch down the tree
Dialogue: 0,1:17:41.84,1:17:44.00,Default,,0,0,0,,this corresponds to\Ncontinuing evaluation
Dialogue: 0,1:17:44.00,1:17:47.04,Default,,0,0,0,,of the then branch in the predicate.
Dialogue: 0,1:17:47.04,1:17:50.24,Default,,0,0,0,,Eventually, the predicate will\Nquery the first component
Dialogue: 0,1:17:50.24,1:17:51.88,Default,,0,0,0,,of the point, which is false,
Dialogue: 0,1:17:51.88,1:17:54.60,Default,,0,0,0,,meaning we will take\Nthe right branch down the tree,
Dialogue: 0,1:17:54.60,1:17:56.44,Default,,0,0,0,,and then, at some\Npoint, the predicate
Dialogue: 0,1:17:56.44,1:17:59.24,Default,,0,0,0,,will query the second\Ncomponent, which is true,
Dialogue: 0,1:17:59.24,1:18:01.52,Default,,0,0,0,,meaning we take the left\Nbranch down at the tree,
Dialogue: 0,1:18:01.52,1:18:04.32,Default,,0,0,0,,and we now hit a leaf node\Nwith the answer true,
Dialogue: 0,1:18:04.32,1:18:06.40,Default,,0,0,0,,meaning that for this\Nparticular point,
Dialogue: 0,1:18:06.40,1:18:08.52,Default,,0,0,0,,the predicate will\Nyield the answer true.
Dialogue: 0,1:18:08.52,1:18:11.28,Default,,0,0,0,,Now, this particular predicate\Nbelongs to a certain class
Dialogue: 0,1:18:11.28,1:18:14.08,Default,,0,0,0,,of predicates that admit\Ncanonical models.
Dialogue: 0,1:18:14.08,1:18:17.88,Default,,0,0,0,,We call such predicates N-standard.
Dialogue: 0,1:18:17.88,1:18:20.96,Default,,0,0,0,,A tree model is N-standard\Nif it is a perfect binary tree
Dialogue: 0,1:18:20.96,1:18:23.76,Default,,0,0,0,,of height N, in addition\Nwe also require that
Dialogue: 0,1:18:23.76,1:18:25.40,Default,,0,0,0,,the tree contains a query,
Dialogue: 0,1:18:25.40,1:18:28.20,Default,,0,0,0,,and that no sub tree\Nrepeats any query.
Dialogue: 0,1:18:28.20,1:18:29.84,Default,,0,0,0,,We say that a predicate\Nis N standard
Dialogue: 0,1:18:29.84,1:18:31.76,Default,,0,0,0,,if its model is N standard.
Dialogue: 0,1:18:31.76,1:18:35.96,Default,,0,0,0,,For example, the predicate\NEX is three standard.
Dialogue: 0,1:18:35.96,1:18:38.00,Default,,0,0,0,,For the initial analysis,\Nwe restrict our attention
Dialogue: 0,1:18:38.00,1:18:39.60,Default,,0,0,0,,to N standard predicates.
Dialogue: 0,1:18:39.60,1:18:42.12,Default,,0,0,0,,This restriction serves to\Nsimplify the analysis,
Dialogue: 0,1:18:42.12,1:18:43.68,Default,,0,0,0,,but it also provides us an instance
Dialogue: 0,1:18:43.68,1:18:44.68,Default,,0,0,0,,where the efficiency gap
Dialogue: 0,1:18:44.68,1:18:47.04,Default,,0,0,0,,between PCF and PCF\Nwith effect handles
Dialogue: 0,1:18:47.04,1:18:49.84,Default,,0,0,0,,manifests as clearly as possible.
Dialogue: 0,1:18:49.84,1:18:50.84,Default,,0,0,0,,This restriction will enable us
Dialogue: 0,1:18:50.84,1:18:53.48,Default,,0,0,0,,to give a crisp implementation\Nof generic count
Dialogue: 0,1:18:53.48,1:18:55.32,Default,,0,0,0,,with effect handlers.
Dialogue: 0,1:18:55.32,1:18:57.72,Default,,0,0,0,,OK, let's consider how\None might go about
Dialogue: 0,1:18:57.72,1:19:01.28,Default,,0,0,0,,and implement generic\Ncount with effect handlers.
Dialogue: 0,1:19:01.28,1:19:03.64,Default,,0,0,0,,First, we need to take\Nthe predicate as input.
Dialogue: 0,1:19:03.64,1:19:06.92,Default,,0,0,0,,And we have to apply this\Npredicate to a point.
Dialogue: 0,1:19:06.92,1:19:09.44,Default,,0,0,0,,We represent this point\Nas the invocation
Dialogue: 0,1:19:09.44,1:19:12.32,Default,,0,0,0,,of an abstract operation\Ncalled Branch.
Dialogue: 0,1:19:12.32,1:19:14.12,Default,,0,0,0,,The only thing we know about Branch
Dialogue: 0,1:19:14.12,1:19:17.72,Default,,0,0,0,,is that it's going to ultimately\Nreturn a boolean value.
Dialogue: 0,1:19:17.72,1:19:19.80,Default,,0,0,0,,And also, given\Nthe interpretation of Branch,
Dialogue: 0,1:19:19.80,1:19:23.00,Default,,0,0,0,,we must wrap the entire\Ncomputation in a handler.
Dialogue: 0,1:19:23.00,1:19:24.80,Default,,0,0,0,,A handler consists of two parts,
Dialogue: 0,1:19:24.80,1:19:27.36,Default,,0,0,0,,a value clause that\Ntells it what to do
Dialogue: 0,1:19:27.36,1:19:30.80,Default,,0,0,0,,with the return value\Nor the answer of a predicate.
Dialogue: 0,1:19:30.80,1:19:33.68,Default,,0,0,0,,So if the answer is true, then\Nwe're going to return one,
Dialogue: 0,1:19:33.68,1:19:37.16,Default,,0,0,0,,and if the answer is false,\Nwe're going to return zero.
Dialogue: 0,1:19:37.16,1:19:39.72,Default,,0,0,0,,Then the second part is\Nan operation clause,
Dialogue: 0,1:19:39.72,1:19:42.20,Default,,0,0,0,,specifically a clause for\Nthe branch operation,
Dialogue: 0,1:19:42.20,1:19:44.12,Default,,0,0,0,,which in addition to giving\Naccess to the payload
Dialogue: 0,1:19:44.12,1:19:46.04,Default,,0,0,0,,also gives access to\Nthe continuation
Dialogue: 0,1:19:46.04,1:19:49.52,Default,,0,0,0,,of the Branch operation inside\Nthe predicate computation.
Dialogue: 0,1:19:49.52,1:19:52.12,Default,,0,0,0,,This is a first class entity,
Dialogue: 0,1:19:52.12,1:19:56.60,Default,,0,0,0,,and what we do is we invoke\Nthe continuation with true first,
Dialogue: 0,1:19:56.60,1:19:59.00,Default,,0,0,0,,and then we invoke it\Nwith false subsequently,
Dialogue: 0,1:19:59.00,1:20:03.24,Default,,0,0,0,,and we sum up the result\Nof those two invocations.
Dialogue: 0,1:20:03.24,1:20:07.36,Default,,0,0,0,,Now, let's consider concrete\Nevaluation of effcount
Dialogue: 0,1:20:07.36,1:20:10.32,Default,,0,0,0,,applied to our example predicate.
Dialogue: 0,1:20:10.32,1:20:12.40,Default,,0,0,0,,The first thing that\Nhappens is the predicate
Dialogue: 0,1:20:12.40,1:20:14.92,Default,,0,0,0,,queries the zeroth\Ncomponent of the point.
Dialogue: 0,1:20:14.92,1:20:18.48,Default,,0,0,0,,This query causes an invocation\Nof the Branch operation.
Dialogue: 0,1:20:18.48,1:20:20.72,Default,,0,0,0,,This invocation causes\Ncontrol to transfer
Dialogue: 0,1:20:20.72,1:20:23.12,Default,,0,0,0,,into the branch clause\Nin the handler
Dialogue: 0,1:20:23.12,1:20:24.20,Default,,0,0,0,,where the first thing we do
Dialogue: 0,1:20:24.20,1:20:27.52,Default,,0,0,0,,is we resume\Nthe continuation with true,
Dialogue: 0,1:20:27.52,1:20:31.28,Default,,0,0,0,,meaning that it is sent down to\Nthe left branch in the tree.
Dialogue: 0,1:20:31.28,1:20:33.72,Default,,0,0,0,,Now, when the predicate\Nqueries the first component
Dialogue: 0,1:20:33.72,1:20:36.68,Default,,0,0,0,,of the point, the very\Nsame thing will happen.
Dialogue: 0,1:20:36.68,1:20:38.68,Default,,0,0,0,,Another invocation of\NBranch will occur
Dialogue: 0,1:20:38.68,1:20:41.52,Default,,0,0,0,,causing control to flow\Ninto the branch clause
Dialogue: 0,1:20:41.52,1:20:44.44,Default,,0,0,0,,in the handler where we resume\Nthe continuation with true,
Dialogue: 0,1:20:44.44,1:20:48.96,Default,,0,0,0,,so it is sent down\Nthe left branch again.
Dialogue: 0,1:20:48.96,1:20:51.80,Default,,0,0,0,,We repeat this same argument\Nwhen the predicate
Dialogue: 0,1:20:51.80,1:20:53.52,Default,,0,0,0,,queries the second component,
Dialogue: 0,1:20:53.52,1:20:56.24,Default,,0,0,0,,so it is sent down the left branch.
Dialogue: 0,1:20:56.56,1:20:58.96,Default,,0,0,0,,Now, we find ourselves\Nourselves at a leaf node,
Dialogue: 0,1:20:58.96,1:21:02.32,Default,,0,0,0,,meaning that we invoke\Nthe value clause in the handler
Dialogue: 0,1:21:02.32,1:21:07.08,Default,,0,0,0,,with the answer false,\Nmeaning that return a zero.
Dialogue: 0,1:21:07.08,1:21:09.28,Default,,0,0,0,,At this stage, the handler\Nis going to backtrack
Dialogue: 0,1:21:09.28,1:21:10.72,Default,,0,0,0,,to the most recent query
Dialogue: 0,1:21:10.72,1:21:14.04,Default,,0,0,0,,and apply the continuation to false,
Dialogue: 0,1:21:14.04,1:21:17.12,Default,,0,0,0,,taking us down the right\Nbranch in the tree.
Dialogue: 0,1:21:17.12,1:21:19.24,Default,,0,0,0,,Now we find ourselves\Nagain at the leaf node,
Dialogue: 0,1:21:19.24,1:21:20.84,Default,,0,0,0,,so we're going to invoke\Nthe value clause,
Dialogue: 0,1:21:20.84,1:21:22.88,Default,,0,0,0,,but this time with the answer true,
Dialogue: 0,1:21:22.88,1:21:26.48,Default,,0,0,0,,meaning that it will return a one.
Dialogue: 0,1:21:26.48,1:21:28.84,Default,,0,0,0,,The handler is now going\Nto sum up the answers
Dialogue: 0,1:21:28.84,1:21:31.84,Default,,0,0,0,,that it got in the sub\Ntree, which is one.
Dialogue: 0,1:21:31.84,1:21:36.20,Default,,0,0,0,,And then it's going to backtrack\Nto the most recent query,
Dialogue: 0,1:21:36.64,1:21:38.28,Default,,0,0,0,,and then the pattern repeats.
Dialogue: 0,1:21:38.28,1:21:40.64,Default,,0,0,0,,So it's going to resume to\Ncontinuation with false,
Dialogue: 0,1:21:40.64,1:21:44.48,Default,,0,0,0,,and then subsequently with true.
Dialogue: 0,1:21:44.48,1:21:46.92,Default,,0,0,0,,So, backtracking here
Dialogue: 0,1:21:46.92,1:21:49.48,Default,,0,0,0,,ensures that every edge in the
Dialogue: 0,1:21:49.48,1:21:53.36,Default,,0,0,0,,computation tree model it's\Nbeen visited exactly once.
Dialogue: 0,1:21:53.36,1:21:54.56,Default,,0,0,0,,So if we generalize a bit.
Dialogue: 0,1:21:54.56,1:21:56.88,Default,,0,0,0,,This means that computation involves
Dialogue: 0,1:21:57.24,1:22:02.24,Default,,0,0,0,,Big O two to the N steps.
Dialogue: 0,1:22:03.00,1:22:05.16,Default,,0,0,0,,Now, in PCF, we don't have effect handlers.
Dialogue: 0,1:22:05.16,1:22:06.64,Default,,0,0,0,,There's no mechanism\Nfor backtracking
Dialogue: 0,1:22:06.64,1:22:08.56,Default,,0,0,0,,for sharing computation.
Dialogue: 0,1:22:08.56,1:22:10.92,Default,,0,0,0,,Therefore, every generic\Ncount function must restart
Dialogue: 0,1:22:10.92,1:22:13.12,Default,,0,0,0,,computation for every point.
Dialogue: 0,1:22:13.12,1:22:15.56,Default,,0,0,0,,Let me try to illustrate\Nwhat this means.
Dialogue: 0,1:22:15.56,1:22:17.48,Default,,0,0,0,,Let's consider some generic\Ncount function
Dialogue: 0,1:22:17.48,1:22:19.84,Default,,0,0,0,,applied to our example predicate,
Dialogue: 0,1:22:19.84,1:22:21.32,Default,,0,0,0,,and let's for simplicity,
Dialogue: 0,1:22:21.32,1:22:23.48,Default,,0,0,0,,assume that this\Ngeneric count function
Dialogue: 0,1:22:23.48,1:22:25.72,Default,,0,0,0,,visits the notes in\Nthe computation tree
Dialogue: 0,1:22:25.72,1:22:28.80,Default,,0,0,0,,in depth first order.
Dialogue: 0,1:22:28.80,1:22:30.08,Default,,0,0,0,,The first thing that happens is that
Dialogue: 0,1:22:30.08,1:22:32.60,Default,,0,0,0,,the predicate queries the zeroth\Ncomponent of the point,
Dialogue: 0,1:22:32.60,1:22:34.56,Default,,0,0,0,,which returns true,
Dialogue: 0,1:22:34.56,1:22:38.32,Default,,0,0,0,,meaning that we descend down\Nthe left branch in the tree.
Dialogue: 0,1:22:38.32,1:22:40.68,Default,,0,0,0,,The same thing happens\Nfor the first component
Dialogue: 0,1:22:40.68,1:22:42.68,Default,,0,0,0,,and the second component.
Dialogue: 0,1:22:42.68,1:22:45.72,Default,,0,0,0,,And so we find ourselves\Nat the first leaf.
Dialogue: 0,1:22:45.72,1:22:48.12,Default,,0,0,0,,From here there is no\Nquick way to get to
Dialogue: 0,1:22:48.12,1:22:51.36,Default,,0,0,0,,the second leaf, because\Nthere is no backtracking
Dialogue: 0,1:22:51.36,1:22:54.40,Default,,0,0,0,,on any means for sharing computation.
Dialogue: 0,1:22:54.40,1:22:57.16,Default,,0,0,0,,So the generic count function\Nhas to go all the way back up
Dialogue: 0,1:22:57.16,1:23:00.68,Default,,0,0,0,,and construct a second point,\Nthat represents the path
Dialogue: 0,1:23:00.68,1:23:03.72,Default,,0,0,0,,to the second leaf, meaning\Nthat we will have to repeat
Dialogue: 0,1:23:03.72,1:23:05.44,Default,,0,0,0,,some work along the way,
Dialogue: 0,1:23:05.44,1:23:08.28,Default,,0,0,0,,in order to finally\Narrive at the second leaf.
Dialogue: 0,1:23:08.28,1:23:10.12,Default,,0,0,0,,And here the situation's the same.
Dialogue: 0,1:23:10.12,1:23:12.08,Default,,0,0,0,,In order to get to the third leaf,
Dialogue: 0,1:23:12.08,1:23:13.76,Default,,0,0,0,,we must go all the way back up,
Dialogue: 0,1:23:13.76,1:23:16.04,Default,,0,0,0,,construct the third point\Nthat represents the path
Dialogue: 0,1:23:16.04,1:23:19.76,Default,,0,0,0,,to the third leaf, repeating\Nwork along the way
Dialogue: 0,1:23:19.76,1:23:24.28,Default,,0,0,0,,in order to finally arrive\Nat the third leaf.
Dialogue: 0,1:23:24.28,1:23:26.40,Default,,0,0,0,,In general,\Nthe generic count function
Dialogue: 0,1:23:26.40,1:23:28.16,Default,,0,0,0,,will have to construct n points
Dialogue: 0,1:23:28.16,1:23:30.48,Default,,0,0,0,,in order to visit each of the leafs.
Dialogue: 0,1:23:30.48,1:23:33.44,Default,,0,0,0,,This means that computation\Ninvolves, at least,
Dialogue: 0,1:23:33.44,1:23:36.52,Default,,0,0,0,,n two to the n steps.
Dialogue: 0,1:23:36.52,1:23:40.08,Default,,0,0,0,,Some might object to PCF as\Na choice of base language,
Dialogue: 0,1:23:40.08,1:23:41.64,Default,,0,0,0,,because it lack characteristic\Nfeatures found,
Dialogue: 0,1:23:41.64,1:23:44.48,Default,,0,0,0,,in say, industrial\Nstrength languages.
Dialogue: 0,1:23:44.48,1:23:46.92,Default,,0,0,0,,However, as shown in the paper,
Dialogue: 0,1:23:46.96,1:23:50.20,Default,,0,0,0,,the efficiency gap remains\Neven under extensions to PCF.
Dialogue: 0,1:23:50.20,1:23:52.52,Default,,0,0,0,,Specifically, we consider\Nadding mutable static
Dialogue: 0,1:23:52.52,1:23:54.48,Default,,0,0,0,,and exceptions into the picture,
Dialogue: 0,1:23:54.48,1:23:56.92,Default,,0,0,0,,we consider them\Nseparately and together,
Dialogue: 0,1:23:56.92,1:23:58.92,Default,,0,0,0,,and I will claim that once\Nwe've put them together
Dialogue: 0,1:23:58.92,1:24:01.40,Default,,0,0,0,,our base language forms\Na prototypical core,
Dialogue: 0,1:24:01.40,1:24:02.88,Default,,0,0,0,,of an industrial strength language,
Dialogue: 0,1:24:02.88,1:24:05.08,Default,,0,0,0,,like OCaml or Java.
Dialogue: 0,1:24:05.08,1:24:07.04,Default,,0,0,0,,Furthermore, in\Nthe paper we also discuss
Dialogue: 0,1:24:07.04,1:24:09.16,Default,,0,0,0,,how to relax\Nthe standard restriction.
Dialogue: 0,1:24:09.16,1:24:11.36,Default,,0,0,0,,That is so the predicate models
Dialogue: 0,1:24:11.36,1:24:14.00,Default,,0,0,0,,no longer needs to be\Nperfect binary trees,
Dialogue: 0,1:24:14.00,1:24:15.88,Default,,0,0,0,,and we can account\Nfor repeat queries
Dialogue: 0,1:24:15.88,1:24:17.92,Default,,0,0,0,,and we don't even need to\Nquery all the components
Dialogue: 0,1:24:17.92,1:24:20.00,Default,,0,0,0,,of a point.
Dialogue: 0,1:24:20.00,1:24:23.60,Default,,0,0,0,,We also consider how to extend\Nthe problem to search,
Dialogue: 0,1:24:23.60,1:24:26.84,Default,,0,0,0,,that is, instead of returning\Nthe number of times,
Dialogue: 0,1:24:26.84,1:24:28.88,Default,,0,0,0,,this predicate will\Nsatisfy return to points
Dialogue: 0,1:24:28.88,1:24:31.84,Default,,0,0,0,,that satisfy the predicate.
Dialogue: 0,1:24:31.84,1:24:33.88,Default,,0,0,0,,We showed that the same\N asymptotic bound applies
Dialogue: 0,1:24:33.88,1:24:35.60,Default,,0,0,0,,to the search problem.
Dialogue: 0,1:24:35.60,1:24:37.96,Default,,0,0,0,,We also conducted\Nempirical evaluation.
Dialogue: 0,1:24:40.32,1:24:44.68,Default,,0,0,0,,In summary, the takeaway is\Nthat control operators admit,
Dialogue: 0,1:24:44.68,1:24:46.56,Default,,0,0,0,,asymptotically more\Nefficient implementations
Dialogue: 0,1:24:46.56,1:24:48.56,Default,,0,0,0,,of some programs,
Dialogue: 0,1:24:48.56,1:24:50.08,Default,,0,0,0,,and the intuition\Nfor why that is true
Dialogue: 0,1:24:50.08,1:24:52.72,Default,,0,0,0,,is because control operators\Nenable computation
Dialogue: 0,1:24:52.72,1:24:55.04,Default,,0,0,0,,to be shared while backtracking.
Dialogue: 0,1:24:55.04,1:24:57.00,Default,,0,0,0,,And as for future work, we\Nwould like to consider
Dialogue: 0,1:24:57.00,1:25:00.20,Default,,0,0,0,,how linear handlers fit\Ninto the picture.
Dialogue: 0,1:25:00.20,1:25:02.56,Default,,0,0,0,,So linear handlers are\Na special form of handlers
Dialogue: 0,1:25:02.56,1:25:06.64,Default,,0,0,0,,that only allow the continuation\Nto to be invoked once.
Dialogue: 0,1:25:06.64,1:25:09.08,Default,,0,0,0,,It is not clear that our\Ncurrent proof techniques
Dialogue: 0,1:25:09.08,1:25:10.48,Default,,0,0,0,,will adapt readily\Nto the situation,
Dialogue: 0,1:25:10.48,1:25:11.76,Default,,0,0,0,,with the linear handlers.
Dialogue: 0,1:25:11.76,1:25:14.16,Default,,0,0,0,,So, it would be interesting\Nto investigate.
Dialogue: 0,1:25:14.16,1:25:15.92,Default,,0,0,0,,Another thing that would be\Ninteresting to investigate
Dialogue: 0,1:25:15.92,1:25:16.92,Default,,0,0,0,,would be a richer type system.
Dialogue: 0,1:25:16.92,1:25:18.64,Default,,0,0,0,,Say, one that features\Neffect typing,
Dialogue: 0,1:25:18.64,1:25:21.24,Default,,0,0,0,,and how that would\Nimpact the result.
Dialogue: 0,1:25:21.24,1:25:22.80,Default,,0,0,0,,Thank you for tuning in to my talk,
Dialogue: 0,1:25:22.80,1:25:24.20,Default,,0,0,0,,and thank you for your attention.
Dialogue: 0,1:25:24.20,1:25:43.96,Default,,0,0,0,,(LIVELY PIANO MUSIC)
Dialogue: 0,1:25:43.96,1:25:51.04,Default,,0,0,0,,(AUDIENCE APPLAUDS)
Dialogue: 0,1:25:51.04,1:25:53.40,Default,,0,0,0,,ALAN JEFFREY: All right, so,\Nthank you, Daniel.
Dialogue: 0,1:25:53.40,1:25:58.92,Default,,0,0,0,,So, if you want to join\Nthe authors for a live Q&A,
Dialogue: 0,1:25:58.92,1:26:00.56,Default,,0,0,0,,again, you can just\Nclick on the link,
Dialogue: 0,1:26:00.56,1:26:17.60,Default,,0,0,0,,in the Clowdr room.
Dialogue: 0,1:26:17.60,1:26:20.52,Default,,0,0,0,,All right, and now, there is\Ngoing to be a short pause,
Dialogue: 0,1:26:20.52,1:26:22.60,Default,,0,0,0,,and when we come back,\Nwe'll have the next paper,
Dialogue: 0,1:26:22.60,1:26:30.32,Default,,0,0,0,,in Session 2 of ICFP 2020.
Dialogue: 0,1:26:30.32,1:27:08.60,Default,,0,0,0,,(GENTLE LIGHT MUSIC)
Dialogue: 0,1:28:00.92,1:28:04.80,Default,,0,0,0,,Hello, and welcome\Nback to ICFP 2020.
Dialogue: 0,1:28:04.80,1:28:08.36,Default,,0,0,0,,And our next paper is going to\Nbe "Computation Focusing,"
Dialogue: 0,1:28:08.36,1:28:14.52,Default,,0,0,0,,and it's going to be\Npresented by Nick Rioux.
Dialogue: 0,1:28:14.60,1:28:16.00,Default,,0,0,0,,NICK: My name is Nick Rioux,
Dialogue: 0,1:28:16.00,1:28:17.84,Default,,0,0,0,,and this talk is for the paper,
Dialogue: 0,1:28:17.84,1:28:19.20,Default,,0,0,0,,called "Computation Focusing,"
Dialogue: 0,1:28:19.20,1:28:21.72,Default,,0,0,0,,by myself, and my advisor,\NSteve Zdancewic,
Dialogue: 0,1:28:21.72,1:28:24.68,Default,,0,0,0,,at the University of Pennsylvania.
Dialogue: 0,1:28:24.68,1:28:27.12,Default,,0,0,0,,Our paper is all about\Nproving program equivalence.
Dialogue: 0,1:28:27.12,1:28:30.20,Default,,0,0,0,,This is an important way\Nof reasoning about them.
Dialogue: 0,1:28:30.20,1:28:31.72,Default,,0,0,0,,So, whether you have a compiler
Dialogue: 0,1:28:31.72,1:28:33.44,Default,,0,0,0,,that performs CPS translations,
Dialogue: 0,1:28:33.44,1:28:36.28,Default,,0,0,0,,or just some optimizer that\Ndoes function inlining,
Dialogue: 0,1:28:36.28,1:28:37.72,Default,,0,0,0,,in order to justify them,
Dialogue: 0,1:28:37.72,1:28:38.72,Default,,0,0,0,,you're probably going to want
Dialogue: 0,1:28:38.72,1:28:41.72,Default,,0,0,0,,to be able to prove\Nprograms equivalent.
Dialogue: 0,1:28:41.72,1:28:44.20,Default,,0,0,0,,The, sort of, gold\Nstandard of equivalence,
Dialogue: 0,1:28:44.20,1:28:46.16,Default,,0,0,0,,the notion that we care most about,
Dialogue: 0,1:28:46.16,1:28:47.76,Default,,0,0,0,,is called contextual equivalence.
Dialogue: 0,1:28:47.76,1:28:50.00,Default,,0,0,0,,And two programs are\Ncontextually equivalent
Dialogue: 0,1:28:50.00,1:28:52.44,Default,,0,0,0,,when they show the same\Nbehavior in all contexts,
Dialogue: 0,1:28:52.44,1:28:55.20,Default,,0,0,0,,there's no way to\Ndistinguish between them.
Dialogue: 0,1:28:55.20,1:28:56.36,Default,,0,0,0,,But proving this is difficult
Dialogue: 0,1:28:56.36,1:28:58.44,Default,,0,0,0,,because there's so many\Ndifferent possible contexts
Dialogue: 0,1:28:58.44,1:29:00.16,Default,,0,0,0,,that programs could be used in
Dialogue: 0,1:29:00.16,1:29:06.28,Default,,0,0,0,,that we can't really just do\Na case analysis on all of them.
Dialogue: 0,1:29:06.28,1:29:08.32,Default,,0,0,0,,So we need other techniques\Nto prove equivalences
Dialogue: 0,1:29:08.32,1:29:10.04,Default,,0,0,0,,and the CIU theorem does this.
Dialogue: 0,1:29:10.04,1:29:11.20,Default,,0,0,0,,It allows us to,
Dialogue: 0,1:29:11.20,1:29:15.04,Default,,0,0,0,,rather than consider all\Npossible general contexts,
Dialogue: 0,1:29:15.04,1:29:17.16,Default,,0,0,0,,only look at evaluation contexts
Dialogue: 0,1:29:17.16,1:29:20.28,Default,,0,0,0,,paired with closing substitutions,
Dialogue: 0,1:29:20.28,1:29:22.16,Default,,0,0,0,,but there are still\Ndifficulties here.
Dialogue: 0,1:29:22.16,1:29:23.80,Default,,0,0,0,,And in particular in call by value,
Dialogue: 0,1:29:23.80,1:29:25.96,Default,,0,0,0,,there's still many possible\Nevaluation contexts.
Dialogue: 0,1:29:25.96,1:29:28.16,Default,,0,0,0,,So it's difficult to reason\Nabout the interaction
Dialogue: 0,1:29:28.16,1:29:29.88,Default,,0,0,0,,between a term and its context
Dialogue: 0,1:29:29.88,1:29:33.64,Default,,0,0,0,,and call by name has this\Nvery similar dual problem.
Dialogue: 0,1:29:33.64,1:29:36.12,Default,,0,0,0,,So another class of\Nsyntactic proof techniques
Dialogue: 0,1:29:36.20,1:29:39.04,Default,,0,0,0,,includes logical relations\Nand bisimulations.
Dialogue: 0,1:29:39.04,1:29:40.44,Default,,0,0,0,,Logical relations in particular,
Dialogue: 0,1:29:40.44,1:29:43.32,Default,,0,0,0,,give you a really nice high\Nlevel reasoning principles
Dialogue: 0,1:29:43.32,1:29:45.20,Default,,0,0,0,,like relational parametricity,
Dialogue: 0,1:29:45.20,1:29:47.04,Default,,0,0,0,,but there are still\Nsome limitations.
Dialogue: 0,1:29:47.04,1:29:51.24,Default,,0,0,0,,And one of those limitations\Nis that some equivalences
Dialogue: 0,1:29:51.24,1:29:55.20,Default,,0,0,0,,between existential types\Nhave not been easy to prove
Dialogue: 0,1:29:55.20,1:29:58.64,Default,,0,0,0,,in the past using logical relations.
Dialogue: 0,1:29:58.64,1:30:01.52,Default,,0,0,0,,And the problem is essentially\Nthat logical relations
Dialogue: 0,1:30:01.52,1:30:04.12,Default,,0,0,0,,are just more natural to use
Dialogue: 0,1:30:04.12,1:30:07.56,Default,,0,0,0,,to reason about how\Na program produces an output,
Dialogue: 0,1:30:07.60,1:30:11.44,Default,,0,0,0,,than how it uses its input.
Dialogue: 0,1:30:11.44,1:30:13.60,Default,,0,0,0,,So let's look at a particular value
Dialogue: 0,1:30:13.60,1:30:16.92,Default,,0,0,0,,of this existential type.
Dialogue: 0,1:30:16.92,1:30:20.28,Default,,0,0,0,,And let's look at how these\Nvalues of this type are used.
Dialogue: 0,1:30:20.28,1:30:22.72,Default,,0,0,0,,Well, we used existential types\Nby pattern matching on them
Dialogue: 0,1:30:22.72,1:30:23.72,Default,,0,0,0,,to unpack them.
Dialogue: 0,1:30:23.72,1:30:27.76,Default,,0,0,0,,And here we unpack this\Nexistential into a function Y
Dialogue: 0,1:30:27.76,1:30:29.28,Default,,0,0,0,,and this Y is a higher order function.
Dialogue: 0,1:30:29.28,1:30:32.32,Default,,0,0,0,,So we pass another function\NF as input into it.
Dialogue: 0,1:30:32.32,1:30:35.56,Default,,0,0,0,,And F has the type X arrow X,
Dialogue: 0,1:30:35.56,1:30:39.24,Default,,0,0,0,,but this X type is an abstract type.
Dialogue: 0,1:30:39.24,1:30:41.96,Default,,0,0,0,,And so F must be\Nthe identity function.
Dialogue: 0,1:30:41.96,1:30:44.08,Default,,0,0,0,,So with that in mind, let's\Nlook at these two values
Dialogue: 0,1:30:44.08,1:30:46.28,Default,,0,0,0,,of the same existential type.
Dialogue: 0,1:30:46.28,1:30:49.48,Default,,0,0,0,,They contain functions\Nthat themselves
Dialogue: 0,1:30:49.48,1:30:51.92,Default,,0,0,0,,take another function as input F
Dialogue: 0,1:30:51.92,1:30:55.68,Default,,0,0,0,,and they both apply F to\Nmany different values,
Dialogue: 0,1:30:55.68,1:30:58.40,Default,,0,0,0,,checking to see that it does indeed
Dialogue: 0,1:30:58.40,1:31:00.84,Default,,0,0,0,,behave as the identity function.
Dialogue: 0,1:31:00.84,1:31:04.00,Default,,0,0,0,,Since we've already\Nshown that this is true,
Dialogue: 0,1:31:04.00,1:31:07.16,Default,,0,0,0,,we can look at\Nthe functions in these packages
Dialogue: 0,1:31:07.16,1:31:10.16,Default,,0,0,0,,and confirm that they both are\Nalways going to return true,
Dialogue: 0,1:31:10.16,1:31:12.32,Default,,0,0,0,,no matter what.
Dialogue: 0,1:31:12.32,1:31:15.52,Default,,0,0,0,,So, in other words, this means\Nthat they must be equivalent.
Dialogue: 0,1:31:15.52,1:31:17.20,Default,,0,0,0,,But logical relations\Nin bisimulations
Dialogue: 0,1:31:17.20,1:31:19.52,Default,,0,0,0,,struggle to prove this\Nbecause they force you
Dialogue: 0,1:31:19.56,1:31:22.60,Default,,0,0,0,,to come up with some relational\Ninterpretation for X
Dialogue: 0,1:31:22.60,1:31:26.00,Default,,0,0,0,,that somehow relates\Nvalues of Boolean type
Dialogue: 0,1:31:26.00,1:31:28.04,Default,,0,0,0,,to values of Integer type.
Dialogue: 0,1:31:28.04,1:31:31.08,Default,,0,0,0,,But we have no such\Nrelation in mind here.
Dialogue: 0,1:31:31.08,1:31:36.72,Default,,0,0,0,,There's not really a correspondence\Nbetween the values of X
Dialogue: 0,1:31:36.72,1:31:37.72,Default,,0,0,0,,in one of these packages
Dialogue: 0,1:31:37.72,1:31:40.52,Default,,0,0,0,,with values of X in\Nthe other package.
Dialogue: 0,1:31:41.32,1:31:42.32,Default,,0,0,0,,So instead, what we want to do
Dialogue: 0,1:31:42.32,1:31:45.68,Default,,0,0,0,,is look at the possible context\Nthese values may be used in
Dialogue: 0,1:31:45.68,1:31:48.64,Default,,0,0,0,,and exploit the fact that\Nthey're constrained
Dialogue: 0,1:31:48.64,1:31:50.48,Default,,0,0,0,,by their types.
Dialogue: 0,1:31:50.48,1:31:51.76,Default,,0,0,0,,So throughout the rest of the talk,
Dialogue: 0,1:31:51.76,1:31:54.44,Default,,0,0,0,,we're going to look at\Na proof theoretic technique
Dialogue: 0,1:31:54.44,1:31:57.00,Default,,0,0,0,,called focusing and show\Nthat that's actually useful
Dialogue: 0,1:31:57.00,1:31:58.64,Default,,0,0,0,,for reasoning about programs.
Dialogue: 0,1:31:58.64,1:32:02.24,Default,,0,0,0,,In fact, we can use that to\Nprove this equivalence.
Dialogue: 0,1:32:02.24,1:32:04.80,Default,,0,0,0,,Lastly, we'll see why this\Ntechnique might be useful
Dialogue: 0,1:32:04.80,1:32:06.92,Default,,0,0,0,,in compositional\Ncompiler correctness.
Dialogue: 0,1:32:06.92,1:32:08.48,Default,,0,0,0,,For this talk, we're\Ngonna deal with
Dialogue: 0,1:32:08.48,1:32:11.36,Default,,0,0,0,,a call by value language\Nwith predicative polymorphism
Dialogue: 0,1:32:11.36,1:32:12.36,Default,,0,0,0,,in a pure setting,
Dialogue: 0,1:32:12.36,1:32:15.60,Default,,0,0,0,,but the paper goes beyond\Nsome of these restrictions.
Dialogue: 0,1:32:15.60,1:32:16.88,Default,,0,0,0,,So what is focusing?
Dialogue: 0,1:32:16.88,1:32:19.32,Default,,0,0,0,,Well, focusing is\Na proof search technique
Dialogue: 0,1:32:19.32,1:32:21.40,Default,,0,0,0,,that narrows down the search space
Dialogue: 0,1:32:21.40,1:32:24.00,Default,,0,0,0,,when you're trying to find\Na proof of a certain proposition.
Dialogue: 0,1:32:24.00,1:32:25.64,Default,,0,0,0,,And viewed through\Nthe lens of Curry Howard,
Dialogue: 0,1:32:25.64,1:32:27.56,Default,,0,0,0,,you can think of it as\Nmaking things easier
Dialogue: 0,1:32:27.56,1:32:30.00,Default,,0,0,0,,when you're trying to synthesize\Na program of a given type.
Dialogue: 0,1:32:30.76,1:32:32.52,Default,,0,0,0,,So how does focusing\Nnarrow down the search space?
Dialogue: 0,1:32:32.52,1:32:35.88,Default,,0,0,0,,Well, it does that by visiting\Nfewer redundant terms
Dialogue: 0,1:32:35.88,1:32:40.80,Default,,0,0,0,,that are just equivalent to each\Nother via beta or eta laws.
Dialogue: 0,1:32:40.80,1:32:43.28,Default,,0,0,0,,We don't have time to go into\Nfocusing in depth today
Dialogue: 0,1:32:43.56,1:32:44.84,Default,,0,0,0,,but I wanted to give you a flavor
Dialogue: 0,1:32:44.84,1:32:47.76,Default,,0,0,0,,of what focused terms look like.
Dialogue: 0,1:32:47.76,1:32:50.60,Default,,0,0,0,,So let's try and visit\Nall the focused programs
Dialogue: 0,1:32:50.60,1:32:53.96,Default,,0,0,0,,of Boolean to Boolean type.
Dialogue: 0,1:32:53.96,1:32:56.16,Default,,0,0,0,,The first thing that\Nfocusing says we can do
Dialogue: 0,1:32:56.16,1:32:58.60,Default,,0,0,0,,is apply the lambda type constructor
Dialogue: 0,1:32:58.60,1:33:01.24,Default,,0,0,0,,anytime we have a function\Non the right hand side.
Dialogue: 0,1:33:01.24,1:33:04.40,Default,,0,0,0,,So that just any term in our\Nlanguage of function type
Dialogue: 0,1:33:04.40,1:33:06.68,Default,,0,0,0,,is going to be equivalent\Nto some lambda.
Dialogue: 0,1:33:06.68,1:33:09.44,Default,,0,0,0,,And that's true by\Neta in call by name
Dialogue: 0,1:33:09.44,1:33:11.92,Default,,0,0,0,,and in call by value we're\Nalso using normalization.
Dialogue: 0,1:33:11.92,1:33:13.96,Default,,0,0,0,,But if you didn't have normalization
Dialogue: 0,1:33:13.96,1:33:15.72,Default,,0,0,0,,you could still use this technique
Dialogue: 0,1:33:15.72,1:33:20.36,Default,,0,0,0,,you would just have an extra non-terminating\Nterm to consider.
Dialogue: 0,1:33:20.36,1:33:21.84,Default,,0,0,0,,So now we need to consider
Dialogue: 0,1:33:21.84,1:33:24.20,Default,,0,0,0,,what the body of\Nthe lambda might be.
Dialogue: 0,1:33:24.20,1:33:26.00,Default,,0,0,0,,And when we're trying to build that
Dialogue: 0,1:33:26.00,1:33:28.16,Default,,0,0,0,,focusing says that\Nthe first thing we can do
Dialogue: 0,1:33:28.16,1:33:29.76,Default,,0,0,0,,is eagerly pattern match.
Dialogue: 0,1:33:29.76,1:33:31.52,Default,,0,0,0,,Anytime there's\Nsomething in the context
Dialogue: 0,1:33:31.52,1:33:33.24,Default,,0,0,0,,that can be pattern matched on
Dialogue: 0,1:33:33.24,1:33:34.44,Default,,0,0,0,,focusing says we might as well
Dialogue: 0,1:33:34.44,1:33:36.04,Default,,0,0,0,,do that pattern matching right now,
Dialogue: 0,1:33:36.04,1:33:38.44,Default,,0,0,0,,there's no point\Nwaiting until later.
Dialogue: 0,1:33:38.44,1:33:41.12,Default,,0,0,0,,So now we know that all\Nthe terms we're interested in
Dialogue: 0,1:33:41.12,1:33:42.88,Default,,0,0,0,,have a lambda on the outside
Dialogue: 0,1:33:42.88,1:33:46.68,Default,,0,0,0,,and then immediately pattern\Nmatch on it's input.
Dialogue: 0,1:33:46.68,1:33:48.80,Default,,0,0,0,,And what we're left to\Nbuild are the two branches
Dialogue: 0,1:33:48.80,1:33:49.80,Default,,0,0,0,,of the if statement.
Dialogue: 0,1:33:49.80,1:33:50.80,Default,,0,0,0,,Both of these are closed
Dialogue: 0,1:33:50.80,1:33:52.56,Default,,0,0,0,,because focusing knows\Nthat there's no point
Dialogue: 0,1:33:52.56,1:33:56.24,Default,,0,0,0,,in pattern matching on x twice\Nonce we've already done it.
Dialogue: 0,1:33:56.24,1:33:58.92,Default,,0,0,0,,And so we just need to\Nbuild focused programs
Dialogue: 0,1:33:58.92,1:34:00.00,Default,,0,0,0,,of Boolean type.
Dialogue: 0,1:34:00.00,1:34:02.00,Default,,0,0,0,,And it turns out there\Nare only two of those,
Dialogue: 0,1:34:02.00,1:34:03.60,Default,,0,0,0,,true and false.
Dialogue: 0,1:34:03.60,1:34:05.36,Default,,0,0,0,,And so we can use those to build
Dialogue: 0,1:34:05.36,1:34:07.16,Default,,0,0,0,,our four candidate programs here
Dialogue: 0,1:34:07.16,1:34:09.88,Default,,0,0,0,,and turns out that every function\Nof Boolean to Boolean type
Dialogue: 0,1:34:09.88,1:34:11.88,Default,,0,0,0,,needs to be equivalent to
Dialogue: 0,1:34:11.88,1:34:14.04,Default,,0,0,0,,one of these four focused programs.
Dialogue: 0,1:34:14.04,1:34:16.28,Default,,0,0,0,,We've cut out many, many\Nnon-focused programs
Dialogue: 0,1:34:16.28,1:34:19.48,Default,,0,0,0,,such as the identity\Nfunction lambda x.x
Dialogue: 0,1:34:19.48,1:34:21.08,Default,,0,0,0,,but this program is\Nstill represented
Dialogue: 0,1:34:21.08,1:34:25.16,Default,,0,0,0,,in the second bullet point here.
Dialogue: 0,1:34:25.16,1:34:28.12,Default,,0,0,0,,So some properties of focused\Nterms to keep in mind
Dialogue: 0,1:34:28.12,1:34:30.60,Default,,0,0,0,,are that focused terms are\Nalways beta eta normal.
Dialogue: 0,1:34:30.60,1:34:32.52,Default,,0,0,0,,There's no way to beta reduce them
Dialogue: 0,1:34:32.52,1:34:37.68,Default,,0,0,0,,and they can't be eta expanded\Nwithout introducing a redex.
Dialogue: 0,1:34:37.68,1:34:40.96,Default,,0,0,0,,And we characterize\Nthem in our paper
Dialogue: 0,1:34:41.08,1:34:43.08,Default,,0,0,0,,as a restricted type system.
Dialogue: 0,1:34:43.08,1:34:46.20,Default,,0,0,0,,Basically, the usual type\Nrules that you're used to
Dialogue: 0,1:34:46.20,1:34:49.20,Default,,0,0,0,,but restricted to be\Napplied in a certain order
Dialogue: 0,1:34:49.20,1:34:51.04,Default,,0,0,0,,and this gives you strong\Ninversion principles
Dialogue: 0,1:34:51.40,1:34:54.60,Default,,0,0,0,,to do programmatic reasoning.
Dialogue: 0,1:34:54.60,1:34:57.00,Default,,0,0,0,,Lastly, for every focused term,
Dialogue: 0,1:34:57.00,1:34:58.32,Default,,0,0,0,,for every well typed term,
Dialogue: 0,1:34:58.32,1:35:00.28,Default,,0,0,0,,there's some equivalent\Nfocused term.
Dialogue: 0,1:35:00.28,1:35:02.28,Default,,0,0,0,,This is called\Ncomputational completeness
Dialogue: 0,1:35:02.28,1:35:03.84,Default,,0,0,0,,and it's the key property we need
Dialogue: 0,1:35:03.84,1:35:05.52,Default,,0,0,0,,for reasoning about programs
Dialogue: 0,1:35:05.52,1:35:07.16,Default,,0,0,0,,and basically all it says is that
Dialogue: 0,1:35:07.44,1:35:10.88,Default,,0,0,0,,we may have eliminated many\Nredundant representations
Dialogue: 0,1:35:10.88,1:35:13.64,Default,,0,0,0,,of the same program but we\Nhaven't lost anything of value,
Dialogue: 0,1:35:13.64,1:35:16.20,Default,,0,0,0,,there's still some\Nrepresentative focus program
Dialogue: 0,1:35:16.20,1:35:18.80,Default,,0,0,0,,for any other program.
Dialogue: 0,1:35:18.80,1:35:21.44,Default,,0,0,0,,So why are we talking about\Na proof search technique
Dialogue: 0,1:35:21.44,1:35:24.32,Default,,0,0,0,,in a talk about\Ncontextual equivalence?
Dialogue: 0,1:35:24.32,1:35:27.56,Default,,0,0,0,,Well, it turns out that a proof\Nof contextual equivalence
Dialogue: 0,1:35:27.56,1:35:31.12,Default,,0,0,0,,is just a search through\Nall possible contexts
Dialogue: 0,1:35:31.12,1:35:34.16,Default,,0,0,0,,demonstrating the same\Nbehavior for each context.
Dialogue: 0,1:35:34.16,1:35:35.68,Default,,0,0,0,,And so if you think\Nabout it like this
Dialogue: 0,1:35:35.68,1:35:37.64,Default,,0,0,0,,and you apply\Nthe completeness of focusing
Dialogue: 0,1:35:37.64,1:35:40.28,Default,,0,0,0,,then you can see that\Nthere's no need
Dialogue: 0,1:35:40.28,1:35:42.08,Default,,0,0,0,,to search through all\Npossible contexts,
Dialogue: 0,1:35:42.40,1:35:46.20,Default,,0,0,0,,you only need to search\Nthrough focused contexts.
Dialogue: 0,1:35:46.20,1:35:48.28,Default,,0,0,0,,So that leads us to\Na context lemma
Dialogue: 0,1:35:48.28,1:35:49.36,Default,,0,0,0,,which looks a little hairy
Dialogue: 0,1:35:49.36,1:35:50.92,Default,,0,0,0,,but all this is saying is that
Dialogue: 0,1:35:50.92,1:35:52.92,Default,,0,0,0,,to prove two values equivalent
Dialogue: 0,1:35:52.92,1:35:55.76,Default,,0,0,0,,you only need to consider\Nfocused contexts
Dialogue: 0,1:35:55.76,1:35:58.28,Default,,0,0,0,,which are represented\Nby a term, an f,
Dialogue: 0,1:35:58.28,1:36:01.80,Default,,0,0,0,,with a hole x represented\Nas a variable here.
Dialogue: 0,1:36:01.80,1:36:05.40,Default,,0,0,0,,And if v1 and v2 are open then\Nyou need to close them off
Dialogue: 0,1:36:05.40,1:36:07.16,Default,,0,0,0,,with some closing substitutions
Dialogue: 0,1:36:07.16,1:36:09.08,Default,,0,0,0,,but you can assume\Nthat all the values
Dialogue: 0,1:36:09.08,1:36:13.04,Default,,0,0,0,,in those substitutions are focused.
Dialogue: 0,1:36:13.04,1:36:14.40,Default,,0,0,0,,So let's return to the equivalence
Dialogue: 0,1:36:14.40,1:36:16.08,Default,,0,0,0,,that we wanted to prove earlier.
Dialogue: 0,1:36:16.08,1:36:18.72,Default,,0,0,0,,And now we'll apply\Nour focusing lemma.
Dialogue: 0,1:36:18.72,1:36:21.96,Default,,0,0,0,,And this context lemma says,\Nsince these values are closed,
Dialogue: 0,1:36:21.96,1:36:23.92,Default,,0,0,0,,we just need to consider\Nsome context NF
Dialogue: 0,1:36:23.92,1:36:26.12,Default,,0,0,0,,and show that they\Nboth behave the same
Dialogue: 0,1:36:26.12,1:36:31.52,Default,,0,0,0,,when the values are filled in for X.
Dialogue: 0,1:36:31.52,1:36:36.36,Default,,0,0,0,,So what does the fact that\NNF is focused tell us?
Dialogue: 0,1:36:36.36,1:36:41.68,Default,,0,0,0,,Well the hole in NF X\Nhas existential type,
Dialogue: 0,1:36:41.68,1:36:42.88,Default,,0,0,0,,and we know that existential types
Dialogue: 0,1:36:42.88,1:36:44.28,Default,,0,0,0,,can be pattern matched on.
Dialogue: 0,1:36:44.28,1:36:47.92,Default,,0,0,0,,So focusing says let's\Ndo that right away.
Dialogue: 0,1:36:47.92,1:36:50.24,Default,,0,0,0,,Now once we unpack the existential,
Dialogue: 0,1:36:50.24,1:36:52.20,Default,,0,0,0,,we get this function Y,
Dialogue: 0,1:36:52.20,1:36:55.28,Default,,0,0,0,,and the rest of the body\Nof the pattern
Dialogue: 0,1:36:55.28,1:36:58.28,Default,,0,0,0,,after each statement gets to\Ncall Y potentially.
Dialogue: 0,1:36:58.28,1:36:59.96,Default,,0,0,0,,So there's really only two\Nthings that we can do here,
Dialogue: 0,1:36:59.96,1:37:02.88,Default,,0,0,0,,either we call Y or we\Ndon't, and if we don't,
Dialogue: 0,1:37:02.88,1:37:07.36,Default,,0,0,0,,then we can only return\Na constant boolean value.
Dialogue: 0,1:37:07.36,1:37:09.12,Default,,0,0,0,,So there are three possible shapes
Dialogue: 0,1:37:09.12,1:37:12.56,Default,,0,0,0,,of programs here that\Nthis context may take.
Dialogue: 0,1:37:12.56,1:37:14.48,Default,,0,0,0,,We need to show that the two values
Dialogue: 0,1:37:14.48,1:37:15.56,Default,,0,0,0,,behave the same in each of them.
Dialogue: 0,1:37:15.56,1:37:18.68,Default,,0,0,0,,This is easy in the case\Nof the constant boolean
Dialogue: 0,1:37:18.68,1:37:23.48,Default,,0,0,0,,because the context just\Nignores its input.
Dialogue: 0,1:37:23.48,1:37:25.88,Default,,0,0,0,,The interesting case\Nis when we call Y.
Dialogue: 0,1:37:25.88,1:37:28.36,Default,,0,0,0,,And what happens here\Nis that V1
Dialogue: 0,1:37:28.36,1:37:31.72,Default,,0,0,0,,is going to get destructed\Nand substituted in for Y.
Dialogue: 0,1:37:31.72,1:37:33.76,Default,,0,0,0,,And it's gonna get passed in F,
Dialogue: 0,1:37:33.76,1:37:34.76,Default,,0,0,0,,which we've talked about before
Dialogue: 0,1:37:34.76,1:37:36.60,Default,,0,0,0,,must be the identity function.
Dialogue: 0,1:37:36.60,1:37:38.52,Default,,0,0,0,,So if you plug\Nthe identity function into
Dialogue: 0,1:37:38.52,1:37:41.72,Default,,0,0,0,,the functions in V1\Nand V2, and you reduce,
Dialogue: 0,1:37:41.72,1:37:45.00,Default,,0,0,0,,you can see that both\Nof them return true.
Dialogue: 0,1:37:45.00,1:37:51.44,Default,,0,0,0,,So what's left in\Nthe proof is to show that Z
Dialogue: 0,1:37:51.44,1:37:54.24,Default,,0,0,0,,is equal to true in both cases.
Dialogue: 0,1:37:54.24,1:37:57.80,Default,,0,0,0,,And that, combined with\Na small detail
Dialogue: 0,1:37:57.80,1:38:00.00,Default,,0,0,0,,about the proof structure\Nthat you can see
Dialogue: 0,1:38:00.00,1:38:03.24,Default,,0,0,0,,in the paper, let us\Ncomplete this proof.
Dialogue: 0,1:38:03.24,1:38:05.08,Default,,0,0,0,,Now that we've seen\Nprogram equivalence,
Dialogue: 0,1:38:05.08,1:38:07.52,Default,,0,0,0,,let's look at compiler correctness.
Dialogue: 0,1:38:07.76,1:38:09.60,Default,,0,0,0,,One property you might\Nwant about your compiler
Dialogue: 0,1:38:09.60,1:38:13.40,Default,,0,0,0,,is that it preserves\Nall of the abstractions
Dialogue: 0,1:38:13.40,1:38:14.84,Default,,0,0,0,,in the source language.
Dialogue: 0,1:38:15.76,1:38:17.68,Default,,0,0,0,,So to say this more\Nprecisely,
Dialogue: 0,1:38:17.68,1:38:22.16,Default,,0,0,0,,you can say that two terms in the source\Nlanguage are equivalent
Dialogue: 0,1:38:22.16,1:38:24.72,Default,,0,0,0,,implies that after you compile them,
Dialogue: 0,1:38:24.72,1:38:26.92,Default,,0,0,0,,they should still be equivalent.
Dialogue: 0,1:38:26.92,1:38:28.40,Default,,0,0,0,,To prove this, you need to consider
Dialogue: 0,1:38:28.40,1:38:32.68,Default,,0,0,0,,an arbitrary source target\Nlanguage context, C prime,
Dialogue: 0,1:38:32.68,1:38:36.44,Default,,0,0,0,,but we have a source language\Nequivalence to use.
Dialogue: 0,1:38:36.44,1:38:38.84,Default,,0,0,0,,So we need to back translate\Nthe target context
Dialogue: 0,1:38:38.84,1:38:42.28,Default,,0,0,0,,C prime to a source\Nlanguage equivalence.
Dialogue: 0,1:38:42.28,1:38:46.12,Default,,0,0,0,,And the key idea that\Nfocusing helps us with here
Dialogue: 0,1:38:46.12,1:38:48.12,Default,,0,0,0,,is that we don't need\Nto back translate
Dialogue: 0,1:38:48.12,1:38:50.00,Default,,0,0,0,,every single possible\Ntarget context,
Dialogue: 0,1:38:50.00,1:38:54.16,Default,,0,0,0,,we only need the back\Ntranslate the focused ones.
Dialogue: 0,1:38:54.16,1:38:57.16,Default,,0,0,0,,There's a long history of using\Nfocusing in proof theory,
Dialogue: 0,1:38:57.16,1:38:59.36,Default,,0,0,0,,but there's also a related\Nwork here that uses
Dialogue: 0,1:38:59.36,1:39:02.20,Default,,0,0,0,,focusing in the context of\Nprogramming languages.
Dialogue: 0,1:39:02.20,1:39:05.52,Default,,0,0,0,,Especially as a guide to design
Dialogue: 0,1:39:05.52,1:39:08.04,Default,,0,0,0,,features of programming languages.
Dialogue: 0,1:39:08.04,1:39:10.00,Default,,0,0,0,,There's also work that uses focusing
Dialogue: 0,1:39:10.00,1:39:11.84,Default,,0,0,0,,as a normalization\Nprocedure to decide the equivalence of terms
Dialogue: 0,1:39:13.60,1:39:15.92,Default,,0,0,0,,in the simply typed lambda calculus.
Dialogue: 0,1:39:15.92,1:39:17.92,Default,,0,0,0,,Lastly, normalization by evaluation
Dialogue: 0,1:39:17.92,1:39:19.88,Default,,0,0,0,,is pretty relevant\Nbecause it could be used
Dialogue: 0,1:39:19.88,1:39:23.64,Default,,0,0,0,,to prove our completeness\Nof focusing theorem.
Dialogue: 0,1:39:23.64,1:39:25.24,Default,,0,0,0,,There are many different\Ntypes system features
Dialogue: 0,1:39:25.24,1:39:28.44,Default,,0,0,0,,and effects that we might\Nstudy, and we expect
Dialogue: 0,1:39:28.44,1:39:33.84,Default,,0,0,0,,focusing to be a useful tool\Nalong with all of these.
Dialogue: 0,1:39:33.84,1:39:37.08,Default,,0,0,0,,In particular,\Nthe combination of linearity
Dialogue: 0,1:39:37.08,1:39:39.20,Default,,0,0,0,,and focusing is really\Ninteresting to study
Dialogue: 0,1:39:39.20,1:39:40.96,Default,,0,0,0,,because that's where\Nfocusing originated
Dialogue: 0,1:39:40.96,1:39:43.96,Default,,0,0,0,,and because linear\Nlambda calculus terms
Dialogue: 0,1:39:43.96,1:39:45.68,Default,,0,0,0,,have very nice normal forms
Dialogue: 0,1:39:45.68,1:39:48.60,Default,,0,0,0,,that make them easy to reason about.
Dialogue: 0,1:39:48.60,1:39:52.16,Default,,0,0,0,,To recap, our paper\Ncontributes a few things.
Dialogue: 0,1:39:52.16,1:39:54.08,Default,,0,0,0,,First, we formulate focusing
Dialogue: 0,1:39:54.08,1:39:57.48,Default,,0,0,0,,in a call by value language\Nwith predicative polymorphism.
Dialogue: 0,1:39:57.48,1:39:58.52,Default,,0,0,0,,And we provide a proof
Dialogue: 0,1:39:58.52,1:40:01.36,Default,,0,0,0,,of the computational\Ncompleteness theorem.
Dialogue: 0,1:40:01.36,1:40:03.96,Default,,0,0,0,,Then we prove a context lemma
Dialogue: 0,1:40:03.96,1:40:06.16,Default,,0,0,0,,and show that that's useful in turn
Dialogue: 0,1:40:06.16,1:40:08.16,Default,,0,0,0,,to prove various\Nprogram equivalencies
Dialogue: 0,1:40:08.16,1:40:10.48,Default,,0,0,0,,like the one we saw today.
Dialogue: 0,1:40:10.48,1:40:12.68,Default,,0,0,0,,Finally, we showed that\Nfocusing can be used
Dialogue: 0,1:40:12.68,1:40:15.76,Default,,0,0,0,,to prove compositional compiler\Ncorrectness properties,
Dialogue: 0,1:40:15.76,1:40:17.28,Default,,0,0,0,,like full abstraction.
Dialogue: 0,1:40:17.28,1:40:19.32,Default,,0,0,0,,And when we do this\Nfor a simple compiler
Dialogue: 0,1:40:19.32,1:40:22.48,Default,,0,0,0,,from a language that's\Npure into a language
Dialogue: 0,1:40:22.48,1:40:24.20,Default,,0,0,0,,with a simple divergence effect,
Dialogue: 0,1:40:24.20,1:40:27.40,Default,,0,0,0,,that's tracked by an effect system.
Dialogue: 0,1:40:27.40,1:40:29.28,Default,,0,0,0,,That's all for focusing for now.
Dialogue: 0,1:40:29.28,1:40:31.64,Default,,0,0,0,,Thank you.
Dialogue: 0,1:40:31.64,1:40:38.88,Default,,0,0,0,,(APPLAUSE)
Dialogue: 0,1:40:38.88,1:40:41.16,Default,,0,0,0,,ALAN JEFFREY: All right, so,\Nthank you, Nick.
Dialogue: 0,1:40:41.16,1:40:45.40,Default,,0,0,0,,If you're interested in joining\Nthe authors of this paper
Dialogue: 0,1:40:45.40,1:40:48.40,Default,,0,0,0,,for a live Q&A and you're\Nin the New York timezone,
Dialogue: 0,1:40:48.40,1:41:07.80,Default,,0,0,0,,and then you can click on\Nthe link in the Clowdr Room.
Dialogue: 0,1:41:07.80,1:41:10.84,Default,,0,0,0,,And now we're going to have\N a short break,
Dialogue: 0,1:41:10.84,1:41:12.32,Default,,0,0,0,,please come back and join us
Dialogue: 0,1:41:12.32,1:41:30.12,Default,,0,0,0,,for the next paper in this session.
Dialogue: 0,1:41:30.12,1:42:48.36,Default,,0,0,0,,(UPBEAT JAZZY MUSIC)
Dialogue: 0,1:42:48.36,1:43:00.92,Default,,0,0,0,,(MUSIC FADES)
Dialogue: 0,1:43:00.92,1:43:05.88,Default,,0,0,0,,So, welcome back to\Nthe second session of ICFP 2020,
Dialogue: 0,1:43:05.88,1:43:07.84,Default,,0,0,0,,and our next paper is going to be
Dialogue: 0,1:43:07.84,1:43:11.00,Default,,0,0,0,,"Retrofitting\NParallelism into OCaml."
Dialogue: 0,1:43:11.00,1:43:17.08,Default,,0,0,0,,And it's being presented\Nby KC Sivaramakrishnan.
Dialogue: 0,1:43:17.08,1:43:20.52,Default,,0,0,0,,KC: Hi, I'm KC and I'm going\Nto present our work on
Dialogue: 0,1:43:20.52,1:43:23.72,Default,,0,0,0,,retrofitting parallelism into OCaml.
Dialogue: 0,1:43:23.72,1:43:26.56,Default,,0,0,0,,So OCaml is a reasonably\Npopular programming language
Dialogue: 0,1:43:26.56,1:43:29.12,Default,,0,0,0,,that is used by several,\Nnotable industries,
Dialogue: 0,1:43:29.12,1:43:31.56,Default,,0,0,0,,but also widely in the academia.
Dialogue: 0,1:43:31.56,1:43:33.08,Default,,0,0,0,,OCaml language has particularly
Dialogue: 0,1:43:33.08,1:43:36.96,Default,,0,0,0,,found favor for implementing
Dialogue: 0,1:43:37.00,1:43:40.40,Default,,0,0,0,,software verification\Nand static analysis tools
Dialogue: 0,1:43:40.40,1:43:43.24,Default,,0,0,0,,and also low-latency system services
Dialogue: 0,1:43:43.24,1:43:44.88,Default,,0,0,0,,and for all of its strengths
Dialogue: 0,1:43:44.88,1:43:49.64,Default,,0,0,0,,OCaml is one of the few\Nsystems programming languages
Dialogue: 0,1:43:49.64,1:43:53.96,Default,,0,0,0,,that lacks support for multi-core.
Dialogue: 0,1:43:53.96,1:43:57.04,Default,,0,0,0,,To that end multi-core\NOCaml is an ongoing project
Dialogue: 0,1:43:57.04,1:43:58.32,Default,,0,0,0,,which aims to add native support
Dialogue: 0,1:43:58.32,1:44:03.08,Default,,0,0,0,,for concurrency\Nand parallelism in OCaml.
Dialogue: 0,1:44:03.08,1:44:05.96,Default,,0,0,0,,Concurrency in multi-core\NOCaml is added
Dialogue: 0,1:44:05.96,1:44:08.08,Default,,0,0,0,,with the help of effect handlers,
Dialogue: 0,1:44:08.08,1:44:11.04,Default,,0,0,0,,but the focus of this\Nparticular talk is going to be
Dialogue: 0,1:44:11.04,1:44:14.68,Default,,0,0,0,,on parallelism and in\Nparticular, we are going to
Dialogue: 0,1:44:14.68,1:44:17.20,Default,,0,0,0,,look at the details of\Na multi-core capable
Dialogue: 0,1:44:17.20,1:44:21.12,Default,,0,0,0,,garbage collector that we have\Nimplemented for OCaml.
Dialogue: 0,1:44:21.12,1:44:24.44,Default,,0,0,0,,The design space for\Nmulti-core OCaml,
Dialogue: 0,1:44:24.44,1:44:28.40,Default,,0,0,0,,multi-core garbage\Ncollectors is quite wide.
Dialogue: 0,1:44:28.44,1:44:31.36,Default,,0,0,0,,And what makes our\Nwork unique is that
Dialogue: 0,1:44:31.36,1:44:36.40,Default,,0,0,0,,our design is guided by\Nbackwards compatibility concerns
Dialogue: 0,1:44:36.40,1:44:40.12,Default,,0,0,0,,before parallel scalability.
Dialogue: 0,1:44:40.12,1:44:44.72,Default,,0,0,0,,So adding parallelism to\NOCaml has several challenges.
Dialogue: 0,1:44:44.72,1:44:47.72,Default,,0,0,0,,OCaml has millions of lines\Nof code in production
Dialogue: 0,1:44:47.72,1:44:52.40,Default,,0,0,0,,that have been written without\Nexplicit parallelism in mind.
Dialogue: 0,1:44:52.40,1:44:55.16,Default,,0,0,0,,And this core tends to also\Nuse advanced features
Dialogue: 0,1:44:55.16,1:44:57.72,Default,,0,0,0,,such as weak references,\Nephemerons, lazy values
Dialogue: 0,1:44:57.72,1:44:59.92,Default,,0,0,0,,and finalizers, which\Nclosely interact
Dialogue: 0,1:44:59.92,1:45:02.96,Default,,0,0,0,,with the current GC.
Dialogue: 0,1:45:02.96,1:45:06.28,Default,,0,0,0,,OCaml also exposes\Na low level of C API
Dialogue: 0,1:45:06.28,1:45:09.48,Default,,0,0,0,,that allows the developers to\Nwrite very efficient code,
Dialogue: 0,1:45:09.48,1:45:12.32,Default,,0,0,0,,but also bakes in the GC invariants
Dialogue: 0,1:45:12.32,1:45:15.56,Default,,0,0,0,,and the cost of refactoring\Nsequential code
Dialogue: 0,1:45:15.56,1:45:17.68,Default,,0,0,0,,in order to work on\Na parallel run-time
Dialogue: 0,1:45:17.68,1:45:18.92,Default,,0,0,0,,is quite prohibitive.
Dialogue: 0,1:45:18.92,1:45:24.16,Default,,0,0,0,,So that is not something\Nthat we would want to do.
Dialogue: 0,1:45:24.16,1:45:26.68,Default,,0,0,0,,OCaml is also a type-safe language.
Dialogue: 0,1:45:26.68,1:45:30.28,Default,,0,0,0,,The additional parallelism\Nshould break type-safety.
Dialogue: 0,1:45:30.28,1:45:32.68,Default,,0,0,0,,For this, we directly\Nborrow the memory model
Dialogue: 0,1:45:32.68,1:45:36.16,Default,,0,0,0,,that was presented\Nin the PLDI 2018 paper,
Dialogue: 0,1:45:36.16,1:45:38.52,Default,,0,0,0,,Bounding data races\Nin space and time,
Dialogue: 0,1:45:38.52,1:45:41.32,Default,,0,0,0,,which guarantees not\Njust type-safety,
Dialogue: 0,1:45:41.32,1:45:46.00,Default,,0,0,0,,but also other strong\Nproperties about data races.
Dialogue: 0,1:45:46.00,1:45:49.76,Default,,0,0,0,,Developers using OCaml have\Ncome to love and embrace
Dialogue: 0,1:45:49.76,1:45:53.44,Default,,0,0,0,,the low latency and predictable\Nperformance of OCaml.
Dialogue: 0,1:45:53.44,1:45:56.68,Default,,0,0,0,,And this is thanks to the GC design.
Dialogue: 0,1:45:56.68,1:45:58.40,Default,,0,0,0,,Stock OCaml garbage collector
Dialogue: 0,1:45:58.40,1:46:02.04,Default,,0,0,0,,is a non-moving incremental\Nmark-and-sweep GC
Dialogue: 0,1:46:02.04,1:46:06.52,Default,,0,0,0,,where new objects are allocated\Ninto a small minor heap
Dialogue: 0,1:46:06.52,1:46:09.00,Default,,0,0,0,,by bump pointer allocation\Nand survivors are copied
Dialogue: 0,1:46:09.00,1:46:10.48,Default,,0,0,0,,to the major heap.
Dialogue: 0,1:46:10.48,1:46:12.28,Default,,0,0,0,,The major heap is collected\Nwith the incremental
Dialogue: 0,1:46:12.28,1:46:14.96,Default,,0,0,0,,non-moving\Nmark-and-sweep collector.
Dialogue: 0,1:46:14.96,1:46:17.80,Default,,0,0,0,,At the start of a major cycle\Nthere is a small idle phase
Dialogue: 0,1:46:17.80,1:46:20.52,Default,,0,0,0,,after which the roots are\Nincrementally marked,
Dialogue: 0,1:46:20.52,1:46:23.24,Default,,0,0,0,,followed by incrementally\Nmarking the rest of the heap.
Dialogue: 0,1:46:23.24,1:46:24.72,Default,,0,0,0,,And once the marking is done,
Dialogue: 0,1:46:24.72,1:46:27.40,Default,,0,0,0,,any unreachable objects\Nare incrementally swept.
Dialogue: 0,1:46:27.40,1:46:28.40,Default,,0,0,0,,And at the end of sweeping,
Dialogue: 0,1:46:28.40,1:46:31.40,Default,,0,0,0,,we come to the end\Nof our major cycle.
Dialogue: 0,1:46:31.40,1:46:34.56,Default,,0,0,0,,This design has several\Nnice properties.
Dialogue: 0,1:46:34.56,1:46:35.96,Default,,0,0,0,,The allocations into the minor heap,
Dialogue: 0,1:46:35.96,1:46:38.08,Default,,0,0,0,,which are majority of\Nallocations are quite fast,
Dialogue: 0,1:46:38.08,1:46:40.24,Default,,0,0,0,,and we do not have any read barriers
Dialogue: 0,1:46:40.24,1:46:43.76,Default,,0,0,0,,for reading OCaml object fields.
Dialogue: 0,1:46:43.88,1:46:46.32,Default,,0,0,0,,And this design being\Nincremental
Dialogue: 0,1:46:46.32,1:46:51.12,Default,,0,0,0,,also leads to enviable tail\Nlatency performance.
Dialogue: 0,1:46:51.12,1:46:53.40,Default,,0,0,0,,And while we add parallelism\Nto this language,
Dialogue: 0,1:46:53.40,1:46:56.64,Default,,0,0,0,,we would like to keep some\Nof these nice properties
Dialogue: 0,1:46:56.64,1:46:58.88,Default,,0,0,0,,still going.
Dialogue: 0,1:46:58.88,1:47:00.64,Default,,0,0,0,,So we arrive at these\Nfollowing requirements
Dialogue: 0,1:47:00.64,1:47:04.48,Default,,0,0,0,,for retrofitting\Nparallelism onto OCaml.
Dialogue: 0,1:47:04.48,1:47:06.64,Default,,0,0,0,,Firstly, we don't want\Nserial programs to break on
Dialogue: 0,1:47:06.64,1:47:08.20,Default,,0,0,0,,the parallel runtime.
Dialogue: 0,1:47:08.20,1:47:09.68,Default,,0,0,0,,A well typed serial program\Nremains well typed
Dialogue: 0,1:47:09.68,1:47:11.52,Default,,0,0,0,,on the parallel runtime.
Dialogue: 0,1:47:11.52,1:47:15.44,Default,,0,0,0,,And we also do not plan to\Nprovide separate modes
Dialogue: 0,1:47:15.44,1:47:17.72,Default,,0,0,0,,for serial and parallel\Nexecution
Dialogue: 0,1:47:17.72,1:47:20.76,Default,,0,0,0,,as Glasgow Haskell Compiler does.
Dialogue: 0,1:47:20.76,1:47:23.44,Default,,0,0,0,,This is because we want to reduce\Nthe burden of maintenance
Dialogue: 0,1:47:23.44,1:47:26.16,Default,,0,0,0,,on the OCaml developers.
Dialogue: 0,1:47:26.16,1:47:27.68,Default,,0,0,0,,Secondly, we want the performance of
Dialogue: 0,1:47:27.68,1:47:29.72,Default,,0,0,0,,serial programs to be the same,
Dialogue: 0,1:47:29.72,1:47:32.00,Default,,0,0,0,,while running on the parallel\Nruntime in terms of
Dialogue: 0,1:47:32.00,1:47:35.48,Default,,0,0,0,,the running time GC for\Npausetime and memory usage.
Dialogue: 0,1:47:35.48,1:47:38.48,Default,,0,0,0,,And lastly, we want our parallel programs\Nto remain responsive.
Dialogue: 0,1:47:38.48,1:47:41.36,Default,,0,0,0,,And then we want\Nthe parallel programs to be able
Dialogue: 0,1:47:41.36,1:47:43.36,Default,,0,0,0,,to scale with additional cores.
Dialogue: 0,1:47:43.36,1:47:46.12,Default,,0,0,0,,We ordered the priorities this way
Dialogue: 0,1:47:46.12,1:47:48.92,Default,,0,0,0,,because getting responsiveness\Nis much harder
Dialogue: 0,1:47:48.92,1:47:52.24,Default,,0,0,0,,than making our programs go faster.
Dialogue: 0,1:47:52.24,1:47:54.64,Default,,0,0,0,,So with that, we\Ndesigned a multicore
Dialogue: 0,1:47:54.64,1:47:56.84,Default,,0,0,0,,OCaml garbage collector.
Dialogue: 0,1:47:57.68,1:47:59.80,Default,,0,0,0,,And our multicore-aware\Nallocator is based
Dialogue: 0,1:47:59.80,1:48:02.20,Default,,0,0,0,,on the Streamflow allocator,
Dialogue: 0,1:48:02.20,1:48:04.40,Default,,0,0,0,,which uses thread-local\Nsize-segmented free lists
Dialogue: 0,1:48:04.40,1:48:07.28,Default,,0,0,0,,for small objects\Nand resorts to system malloc
Dialogue: 0,1:48:07.28,1:48:09.00,Default,,0,0,0,,for large allocations.
Dialogue: 0,1:48:09.00,1:48:11.92,Default,,0,0,0,,And the performance of\Nthis allocator is better
Dialogue: 0,1:48:11.92,1:48:15.36,Default,,0,0,0,,than OCaml's (INAUDIBLE) allocator
Dialogue: 0,1:48:15.36,1:48:18.00,Default,,0,0,0,,and is on par with the recent
Dialogue: 0,1:48:18.32,1:48:21.16,Default,,0,0,0,,(INAUDIBLE) allocator from OCaml.
Dialogue: 0,1:48:21.72,1:48:25.44,Default,,0,0,0,,And the major heap is\Ncollected with the
Dialogue: 0,1:48:25.44,1:48:27.60,Default,,0,0,0,,mostly concurrent non-moving\Nmark and sweep collector,
Dialogue: 0,1:48:27.60,1:48:29.92,Default,,0,0,0,,based on the VCGC design.
Dialogue: 0,1:48:29.92,1:48:32.60,Default,,0,0,0,,One nice aspect of this\Ndesign is that we only need
Dialogue: 0,1:48:32.60,1:48:38.48,Default,,0,0,0,,a very short barrier at\Nthe end of every major cycle.
Dialogue: 0,1:48:38.48,1:48:39.76,Default,,0,0,0,,And I should, at this point mention
Dialogue: 0,1:48:39.76,1:48:43.40,Default,,0,0,0,,that domains are our\Nunits of parallelism.
Dialogue: 0,1:48:43.40,1:48:45.68,Default,,0,0,0,,And in particular, there\Nis no phase separation
Dialogue: 0,1:48:45.68,1:48:46.72,Default,,0,0,0,,between marking and sweeping
Dialogue: 0,1:48:46.72,1:48:49.56,Default,,0,0,0,,and marking and sweeping phases
Dialogue: 0,1:48:49.56,1:48:52.60,Default,,0,0,0,,between multiple\Ndomains may overlap.
Dialogue: 0,1:48:52.60,1:48:55.36,Default,,0,0,0,,One of the major contributions\Nin this paper is
Dialogue: 0,1:48:55.36,1:48:57.56,Default,,0,0,0,,extending this design\Nto support a variety
Dialogue: 0,1:48:57.56,1:49:02.40,Default,,0,0,0,,of additional features such as\Nweak references, ephemerons,
Dialogue: 0,1:49:03.44,1:49:06.60,Default,,0,0,0,,two different kinds of\Nfinalizers, fibers, lazy values
Dialogue: 0,1:49:06.60,1:49:08.84,Default,,0,0,0,,and so on.
Dialogue: 0,1:49:08.84,1:49:12.00,Default,,0,0,0,,Ephemerons are particularly\Ntricky to get efficiently
Dialogue: 0,1:49:12.00,1:49:14.80,Default,,0,0,0,,implemented in\Nthe concurrent multi-core GC.
Dialogue: 0,1:49:14.80,1:49:17.76,Default,,0,0,0,,Ephemerons themselves are\Ngeneralization of weak references,
Dialogue: 0,1:49:17.76,1:49:19.76,Default,,0,0,0,,and the property that\Nthey bring in is,
Dialogue: 0,1:49:19.76,1:49:21.92,Default,,0,0,0,,they introduce conjunction in\Nthe reachability property
Dialogue: 0,1:49:21.92,1:49:25.76,Default,,0,0,0,,of OCaml in for objects in the heap
Dialogue: 0,1:49:25.76,1:49:28.96,Default,,0,0,0,,And this requires multiple\Nrounds of ephemeron marking
Dialogue: 0,1:49:29.84,1:49:33.52,Default,,0,0,0,,and also marking the heap in\Norder to reach a fixed point.
Dialogue: 0,1:49:33.76,1:49:36.60,Default,,0,0,0,,And in this work,\Nwhat we've shown is
Dialogue: 0,1:49:36.60,1:49:41.36,Default,,0,0,0,,we can implement a cycle\Ndelimited handshaking algorithm
Dialogue: 0,1:49:41.36,1:49:44.16,Default,,0,0,0,,in order to perform\Nthe ephemeron marking,
Dialogue: 0,1:49:44.16,1:49:48.56,Default,,0,0,0,,without requiring a global barrier.
Dialogue: 0,1:49:48.56,1:49:50.44,Default,,0,0,0,,The two different kinds\Nof finalizers in Ocaml
Dialogue: 0,1:49:50.44,1:49:54.84,Default,,0,0,0,,also need two barriers,\None barrier each.
Dialogue: 0,1:49:54.84,1:49:57.72,Default,,0,0,0,,And in the worst case, we need\Nthree barriers per cycle,
Dialogue: 0,1:49:57.72,1:49:59.96,Default,,0,0,0,,a major cycle.
Dialogue: 0,1:49:59.96,1:50:02.40,Default,,0,0,0,,And because this design\Nis quite tricky,
Dialogue: 0,1:50:02.40,1:50:07.04,Default,,0,0,0,,we verify the model of this\Ndesign in the Spin model checker
Dialogue: 0,1:50:07.04,1:50:12.96,Default,,0,0,0,,Next, we come to the issue of\Nwhat to do about minor GCs.
Dialogue: 0,1:50:12.96,1:50:17.80,Default,,0,0,0,,Our initial design was based\Non a Doligez/Leroy '93 collector,
Dialogue: 0,1:50:17.80,1:50:20.36,Default,,0,0,0,,which uses a minor heap per domain,
Dialogue: 0,1:50:20.36,1:50:22.32,Default,,0,0,0,,but it's lazier, on the lines,
Dialogue: 0,1:50:22.32,1:50:27.40,Default,,0,0,0,,of the GC collector from\NMarlow and Peyton Jones, 2011.
Dialogue: 0,1:50:29.96,1:50:31.88,Default,,0,0,0,,So this particular\Ndesign has an invariant
Dialogue: 0,1:50:31.88,1:50:36.08,Default,,0,0,0,,that there are no pointers\Nbetween two minor heaps.
Dialogue: 0,1:50:36.08,1:50:37.44,Default,,0,0,0,,And this allows each domain
Dialogue: 0,1:50:37.44,1:50:41.32,Default,,0,0,0,,to be independently\Ngarbage collected.
Dialogue: 0,1:50:41.80,1:50:45.32,Default,,0,0,0,,And unlike the original\NDoligez/Leroy design,
Dialogue: 0,1:50:45.32,1:50:49.16,Default,,0,0,0,,we allow pointers from\Nthe major to the minor heap.
Dialogue: 0,1:50:49.16,1:50:51.72,Default,,0,0,0,,And the reason why we\Nallow this is two fold.
Dialogue: 0,1:50:51.72,1:50:55.92,Default,,0,0,0,,First, it prevents\Neager promotion, right?
Dialogue: 0,1:50:55.92,1:50:58.28,Default,,0,0,0,,So early promotion is\Na problem where you point
Dialogue: 0,1:50:58.28,1:51:00.00,Default,,0,0,0,,to an object, which is promoted,
Dialogue: 0,1:51:00.40,1:51:02.76,Default,,0,0,0,,which would\Notherwise have not been.
Dialogue: 0,1:51:03.44,1:51:05.84,Default,,0,0,0,,If you hadn't\Nestablished this pointer
Dialogue: 0,1:51:05.84,1:51:08.32,Default,,0,0,0,,and this also mirrors\Nsequential behavior
Dialogue: 0,1:51:09.08,1:51:11.84,Default,,0,0,0,,and unfortunately, what this does is
Dialogue: 0,1:51:12.32,1:51:14.80,Default,,0,0,0,,a particular domain\Nmay follow a pointer
Dialogue: 0,1:51:14.80,1:51:16.52,Default,,0,0,0,,from the major to the minor heap
Dialogue: 0,1:51:16.52,1:51:18.44,Default,,0,0,0,,to remote minor heap.
Dialogue: 0,1:51:19.20,1:51:21.48,Default,,0,0,0,,And this will break\Nthe invariant that we had.
Dialogue: 0,1:51:22.00,1:51:24.60,Default,,0,0,0,,So, what we need to do is\Ninsert a read barrier
Dialogue: 0,1:51:24.60,1:51:27.28,Default,,0,0,0,,on reading OCaml object fields
Dialogue: 0,1:51:27.32,1:51:31.00,Default,,0,0,0,,which detects whether the result\Nof the read is going to be
Dialogue: 0,1:51:31.00,1:51:32.92,Default,,0,0,0,,a value and a remote minor heap
Dialogue: 0,1:51:33.28,1:51:36.76,Default,,0,0,0,,in which case, the domain\Nsensor inter-domain interrupt
Dialogue: 0,1:51:36.76,1:51:39.52,Default,,0,0,0,,requesting the target domain\Nto promote the object
Dialogue: 0,1:51:40.00,1:51:41.88,Default,,0,0,0,,which in turn might perform
Dialogue: 0,1:51:42.24,1:51:44.24,Default,,0,0,0,,a local minor garbage collection.
Dialogue: 0,1:51:45.12,1:51:47.16,Default,,0,0,0,,And then, the execution proceeds.
Dialogue: 0,1:51:48.44,1:51:53.92,Default,,0,0,0,,Recall that I had mentioned that\NOCaml does not have read barriers
Dialogue: 0,1:51:53.92,1:51:56.36,Default,,0,0,0,,and now, this design has\Nintroduced read barriers.
Dialogue: 0,1:51:56.36,1:51:59.52,Default,,0,0,0,,So, the first challenge is that we\Nneed these read barriers to be
Dialogue: 0,1:51:59.52,1:52:02.76,Default,,0,0,0,,implemented efficiently for\Nperformance backwards compatibility.
Dialogue: 0,1:52:03.88,1:52:06.24,Default,,0,0,0,,And in the paper, we showed\Nthat we can do this
Dialogue: 0,1:52:06.24,1:52:09.16,Default,,0,0,0,,with a clever bit of\Nvirtual memory mapping and
Dialogue: 0,1:52:09.20,1:52:11.68,Default,,0,0,0,,a series of bit-twiddling tricks,
Dialogue: 0,1:52:11.68,1:52:15.08,Default,,0,0,0,,using which, we have brought\Ndown the read barrier to
Dialogue: 0,1:52:15.08,1:52:16.72,Default,,0,0,0,,three x86 instructions.
Dialogue: 0,1:52:16.72,1:52:19.84,Default,,0,0,0,,And the proof of correctness of\Nthis is available in the paper.
Dialogue: 0,1:52:20.64,1:52:21.64,Default,,0,0,0,,And the...
Dialogue: 0,1:52:22.32,1:52:23.84,Default,,0,0,0,,Because these
Dialogue: 0,1:52:24.44,1:52:26.20,Default,,0,0,0,,read faults are going to be so rare
Dialogue: 0,1:52:26.20,1:52:28.52,Default,,0,0,0,,the branch predictor correctly\Npredicts the branch
Dialogue: 0,1:52:28.52,1:52:30.60,Default,,0,0,0,,almost every read.
Dialogue: 0,1:52:30.88,1:52:32.88,Default,,0,0,0,,So, the performance impact of
Dialogue: 0,1:52:32.88,1:52:35.52,Default,,0,0,0,,these additional instructions is\Nminimal on sequential code.
Dialogue: 0,1:52:36.72,1:52:39.60,Default,,0,0,0,,Unfortunately though,\Nthe introduction of the read barriers
Dialogue: 0,1:52:39.60,1:52:41.00,Default,,0,0,0,,breaks the C API.
Dialogue: 0,1:52:41.96,1:52:43.80,Default,,0,0,0,,And consider this example where
Dialogue: 0,1:52:43.80,1:52:46.80,Default,,0,0,0,,we have two domains, each\Nof which is reading
Dialogue: 0,1:52:46.80,1:52:50.68,Default,,0,0,0,,a major heap object which\Npoints to the other domain.
Dialogue: 0,1:52:51.32,1:52:53.28,Default,,0,0,0,,So, at this point, this domain
Dialogue: 0,1:52:53.80,1:52:58.12,Default,,0,0,0,,sends a promotion request\Nto the other domain.
Dialogue: 0,1:52:58.48,1:53:00.84,Default,,0,0,0,,So, the two domains simultaneously\Nsend promotion requests
Dialogue: 0,1:53:01.32,1:53:03.76,Default,,0,0,0,,and in order to prevent that\Nlock and make progress,
Dialogue: 0,1:53:03.76,1:53:06.28,Default,,0,0,0,,when the domain sends\Na promotion request,
Dialogue: 0,1:53:06.32,1:53:09.00,Default,,0,0,0,,it has to keep servicing\Nother promotion requests
Dialogue: 0,1:53:09.00,1:53:10.56,Default,,0,0,0,,that it may receive.
Dialogue: 0,1:53:11.44,1:53:15.24,Default,,0,0,0,,So, the issue is that because\Npromotion may involve
Dialogue: 0,1:53:15.96,1:53:18.48,Default,,0,0,0,,a minor collection,
Dialogue: 0,1:53:19.16,1:53:23.08,Default,,0,0,0,,a mutable read is in fact a GC\Nsafe point where GC may happen.
Dialogue: 0,1:53:25.08,1:53:26.44,Default,,0,0,0,,But this
Dialogue: 0,1:53:27.56,1:53:29.36,Default,,0,0,0,,breaks the invariant that
Dialogue: 0,1:53:29.36,1:53:31.44,Default,,0,0,0,,we have in stock OCaml where
Dialogue: 0,1:53:31.44,1:53:33.16,Default,,0,0,0,,we don't have any\Nread barriers at all
Dialogue: 0,1:53:33.48,1:53:36.48,Default,,0,0,0,,and in particular, the C API\Nis often explicitly written
Dialogue: 0,1:53:36.48,1:53:38.76,Default,,0,0,0,,with the knowledge of\Nwhen the GC may happen.
Dialogue: 0,1:53:39.24,1:53:40.84,Default,,0,0,0,,And introducing
Dialogue: 0,1:53:41.64,1:53:44.92,Default,,0,0,0,,a read barrier, where the read\Nbarrier is a GC safe point
Dialogue: 0,1:53:45.40,1:53:50.08,Default,,0,0,0,,will require manually\Nrefactoring very tricky code.
Dialogue: 0,1:53:52.80,1:53:54.52,Default,,0,0,0,,And this is unfortunate.
Dialogue: 0,1:53:54.96,1:53:56.44,Default,,0,0,0,,So, in order to
Dialogue: 0,1:53:56.80,1:54:00.92,Default,,0,0,0,,get around this, we also implement\Nthe parallel minor collector
Dialogue: 0,1:54:00.92,1:54:03.44,Default,,0,0,0,,which does stop-the-world\Nparallel minor collection
Dialogue: 0,1:54:03.44,1:54:06.08,Default,,0,0,0,,similar to GHCs minor collection.
Dialogue: 0,1:54:06.40,1:54:08.16,Default,,0,0,0,,So, this shows
Dialogue: 0,1:54:08.92,1:54:11.44,Default,,0,0,0,,a timeline of\Nthe concurrent minor collector
Dialogue: 0,1:54:11.76,1:54:12.80,Default,,0,0,0,,where we have two domains
Dialogue: 0,1:54:12.80,1:54:14.60,Default,,0,0,0,,and the minor collections\Nhere can overlap
Dialogue: 0,1:54:14.60,1:54:17.20,Default,,0,0,0,,what are the activities being\Ndone on the other domains.
Dialogue: 0,1:54:17.68,1:54:19.96,Default,,0,0,0,,And in particular, we read a barrier
Dialogue: 0,1:54:20.48,1:54:22.80,Default,,0,0,0,,once per major cycle
Dialogue: 0,1:54:23.80,1:54:25.96,Default,,0,0,0,,whereas in the parallel\Nminor collector, we read
Dialogue: 0,1:54:26.60,1:54:27.60,Default,,0,0,0,,a barrier
Dialogue: 0,1:54:27.96,1:54:29.80,Default,,0,0,0,,two barriers for every\Nminor collection
Dialogue: 0,1:54:29.80,1:54:31.72,Default,,0,0,0,,in order to indicate\Nthe start and end.
Dialogue: 0,1:54:32.12,1:54:34.96,Default,,0,0,0,,And these minor collections\Nare very frequent
Dialogue: 0,1:54:35.80,1:54:36.80,Default,,0,0,0,,and
Dialogue: 0,1:54:37.40,1:54:39.04,Default,,0,0,0,,in order to better utilize
Dialogue: 0,1:54:40.52,1:54:41.72,Default,,0,0,0,,idle time
Dialogue: 0,1:54:42.12,1:54:43.72,Default,,0,0,0,,while we are waiting for
Dialogue: 0,1:54:44.08,1:54:45.60,Default,,0,0,0,,the minor collections to complete
Dialogue: 0,1:54:45.60,1:54:48.56,Default,,0,0,0,,and when a particular domain has\Ncompleted its minor collection
Dialogue: 0,1:54:48.56,1:54:50.88,Default,,0,0,0,,but it's waiting for other domains\Nto complete the minor collections,
Dialogue: 0,1:54:50.88,1:54:53.00,Default,,0,0,0,,we fill this slop\Nspace in the
Dialogue: 0,1:54:53.48,1:54:57.36,Default,,0,0,0,,in the barrier with major slices.
Dialogue: 0,1:54:59.44,1:55:02.44,Default,,0,0,0,,The advantage of this design is that\Nwe don't read barriers anymore.
Dialogue: 0,1:55:03.84,1:55:06.92,Default,,0,0,0,,But our global barriers\Nare quite frequent now.
Dialogue: 0,1:55:07.28,1:55:11.00,Default,,0,0,0,,So, we need to be able to quickly\Nbring all of the domains to a stop.
Dialogue: 0,1:55:11.52,1:55:15.08,Default,,0,0,0,,So, we insert poll points in our\Ncode for timely interrupt handling.
Dialogue: 0,1:55:15.44,1:55:19.12,Default,,0,0,0,,And this is based on\NFeeley's paper from '93.
Dialogue: 0,1:55:20.16,1:55:22.68,Default,,0,0,0,,So, the big question is\Nhow does this perform?
Dialogue: 0,1:55:23.12,1:55:24.80,Default,,0,0,0,,So, we perform evaluation on a
Dialogue: 0,1:55:24.88,1:55:27.68,Default,,0,0,0,,two socket 14 core Intel\NXeon Gold CPU
Dialogue: 0,1:55:27.68,1:55:30.32,Default,,0,0,0,,where we've isolated 24 cores\Nfor performance evaluation.
Dialogue: 0,1:55:31.08,1:55:36.08,Default,,0,0,0,,And we observe that the sequential\Nthroughput is comparable to OCaml.
Dialogue: 0,1:55:36.36,1:55:38.24,Default,,0,0,0,,The... Compared to stock Ocaml
Dialogue: 0,1:55:38.24,1:55:42.96,Default,,0,0,0,,Concurrent Minor was 4.9% slower\Nand Parallel Minor was 3.5% slower.
Dialogue: 0,1:55:42.96,1:55:45.08,Default,,0,0,0,,These overheads are quite reasonable
Dialogue: 0,1:55:45.08,1:55:48.32,Default,,0,0,0,,and the reason why Concurrent Minor\Nis slower then Parallel Minor is
Dialogue: 0,1:55:48.32,1:55:51.00,Default,,0,0,0,,that the additional instructions\Nfor read barriers.
Dialogue: 0,1:55:51.84,1:55:55.72,Default,,0,0,0,,But we also observed that both\NConcurrent Minor and Parallel Minor
Dialogue: 0,1:55:55.72,1:55:58.24,Default,,0,0,0,,used much lower peak memory
Dialogue: 0,1:55:58.24,1:55:59.96,Default,,0,0,0,,than stock OCaml.
Dialogue: 0,1:56:00.36,1:56:01.68,Default,,0,0,0,,This is because our
Dialogue: 0,1:56:02.04,1:56:06.40,Default,,0,0,0,,allocator is much more efficient\Nintroducing fragmentation.
Dialogue: 0,1:56:06.84,1:56:08.68,Default,,0,0,0,,So, this gives us promise that
Dialogue: 0,1:56:08.68,1:56:11.88,Default,,0,0,0,,we can relax the memory bounds\Nin order to get better
Dialogue: 0,1:56:12.40,1:56:13.68,Default,,0,0,0,,running times.
Dialogue: 0,1:56:15.00,1:56:18.44,Default,,0,0,0,,And we also observed that our\Nsequential GC pause times
Dialogue: 0,1:56:18.44,1:56:20.52,Default,,0,0,0,,are on par with OCaml.
Dialogue: 0,1:56:20.84,1:56:23.36,Default,,0,0,0,,These results and more details\Nare available on the paper.
Dialogue: 0,1:56:24.40,1:56:26.36,Default,,0,0,0,,Next, we look at\Nparallel scalability.
Dialogue: 0,1:56:26.72,1:56:28.68,Default,,0,0,0,,The graphs here show\Nthat the scalability...
Dialogue: 0,1:56:28.68,1:56:30.76,Default,,0,0,0,,The speed up of each\Nof the benchmarks
Dialogue: 0,1:56:31.28,1:56:34.40,Default,,0,0,0,,with respect to sequential baseline.
Dialogue: 0,1:56:35.72,1:56:39.76,Default,,0,0,0,,Overall, we see that the two\Nvariants perform similarly
Dialogue: 0,1:56:39.76,1:56:41.64,Default,,0,0,0,,except a few notable differences.
Dialogue: 0,1:56:42.52,1:56:43.80,Default,,0,0,0,,On a few benchmarks,
Dialogue: 0,1:56:43.80,1:56:46.28,Default,,0,0,0,,Concurrent Minor really\Nsuffers due to read faults
Dialogue: 0,1:56:46.28,1:56:48.60,Default,,0,0,0,,where just performing\Na read requires
Dialogue: 0,1:56:48.68,1:56:52.56,Default,,0,0,0,,sending an interrupt, requesting\Nthe other domain to promote,
Dialogue: 0,1:56:52.56,1:56:54.56,Default,,0,0,0,,that domain promotes while
Dialogue: 0,1:56:54.56,1:56:57.08,Default,,0,0,0,,the domain which read faulted is
Dialogue: 0,1:56:57.48,1:56:58.76,Default,,0,0,0,,idly waiting.
Dialogue: 0,1:56:59.16,1:57:02.64,Default,,0,0,0,,And we also see other cases\Nwhere the unbalanced allocation
Dialogue: 0,1:57:02.64,1:57:05.64,Default,,0,0,0,,leads to inopportune minor\NGCs in Parallel Minor
Dialogue: 0,1:57:06.12,1:57:09.00,Default,,0,0,0,,which causes scalability issues.
Dialogue: 0,1:57:10.20,1:57:13.48,Default,,0,0,0,,We also observed that the parallel\NGC latency was roughly similar
Dialogue: 0,1:57:13.48,1:57:15.40,Default,,0,0,0,,between Parallel Minor\Nand Concurrent Minor.
Dialogue: 0,1:57:16.08,1:57:17.56,Default,,0,0,0,,And in our minds
Dialogue: 0,1:57:17.56,1:57:19.68,Default,,0,0,0,,Parallel Minor wins\Nover Concurrent Minor
Dialogue: 0,1:57:20.04,1:57:21.88,Default,,0,0,0,,because firstly, it\Ndoesn't break the C API.
Dialogue: 0,1:57:21.88,1:57:24.68,Default,,0,0,0,,And it performs almost\Nsimilarly up to 24 cores.
Dialogue: 0,1:57:26.96,1:57:30.00,Default,,0,0,0,,And OCaml 5.00 which will\Nhave multicore support
Dialogue: 0,1:57:30.00,1:57:31.64,Default,,0,0,0,,will use Parallel Minor.
Dialogue: 0,1:57:31.96,1:57:33.40,Default,,0,0,0,,We may reuse the Concurrent\NMinor later for
Dialogue: 0,1:57:33.88,1:57:35.04,Default,,0,0,0,,a time when
Dialogue: 0,1:57:36.20,1:57:37.92,Default,,0,0,0,,commodity machines will have lot of
Dialogue: 0,1:57:38.36,1:57:40.04,Default,,0,0,0,,lot more cores than
Dialogue: 0,1:57:40.88,1:57:42.40,Default,,0,0,0,,they do now.
Dialogue: 0,1:57:43.44,1:57:44.96,Default,,0,0,0,,I'll stop here. Thank you.
Dialogue: 0,1:57:45.88,1:57:50.88,Default,,0,0,0,,(AUDIENCE CLAPS)
Dialogue: 0,1:57:54.00,1:57:55.32,Default,,0,0,0,,ALAN JEFFREY: So, thank you KC.
Dialogue: 0,1:57:55.32,1:57:58.24,Default,,0,0,0,,And if you want to join the authors
Dialogue: 0,1:57:58.24,1:58:00.36,Default,,0,0,0,,for a live Q&A,
Dialogue: 0,1:58:00.36,1:58:02.56,Default,,0,0,0,,click on the link in Clowdr.
Dialogue: 0,1:58:08.60,1:58:13.48,Default,,0,0,0,,Hello and welcome back to\Nthe second session for ICFP 2020.
Dialogue: 0,1:58:13.48,1:58:17.16,Default,,0,0,0,,And the last paper in this\Nsession is going to be
Dialogue: 0,1:58:17.16,1:58:18.92,Default,,0,0,0,,Liquid information flow control
Dialogue: 0,1:58:18.92,1:58:23.92,Default,,0,0,0,,and it's gonna be presented  by\NJean Yang and Nadia Polikarpova.
Dialogue: 0,1:58:29.32,1:58:31.68,Default,,0,0,0,,JEAN YANG: If you're\Nthe director of the FBI,
Dialogue: 0,1:58:31.68,1:58:35.08,Default,,0,0,0,,you should be able to keep your\Nsocial media accounts on lockdown,
Dialogue: 0,1:58:35.08,1:58:37.28,Default,,0,0,0,,but this turned out\Nnot to be the case
Dialogue: 0,1:58:37.28,1:58:40.44,Default,,0,0,0,,for former FBI Director James Comey.
Dialogue: 0,1:58:40.80,1:58:43.00,Default,,0,0,0,,Journalist Ashley\NFeinberg discovered
Dialogue: 0,1:58:43.00,1:58:45.88,Default,,0,0,0,,Comey's secret Instagram and Twitter
Dialogue: 0,1:58:45.88,1:58:50.52,Default,,0,0,0,,simply by sending a follow request\Nto Comey's son's private Instagram.
Dialogue: 0,1:58:50.52,1:58:51.76,Default,,0,0,0,,The culprit,
Dialogue: 0,1:58:51.76,1:58:55.08,Default,,0,0,0,,a leak in Instagram's\Nsuggestions algorithm.
Dialogue: 0,1:58:55.40,1:58:58.52,Default,,0,0,0,,This kind of thing affects many\Nmore of us than just the Comeys
Dialogue: 0,1:58:58.52,1:59:01.72,Default,,0,0,0,,and it happens more\Nand more everyday.
Dialogue: 0,1:59:02.40,1:59:03.84,Default,,0,0,0,,NADIA POLIKARPOVA: Today's software
Dialogue: 0,1:59:03.84,1:59:05.92,Default,,0,0,0,,handles a lot of sensitive information
Dialogue: 0,1:59:05.92,1:59:08.64,Default,,0,0,0,,subject to complex\Nsecurity policies.
Dialogue: 0,1:59:09.08,1:59:11.60,Default,,0,0,0,,Traditionally, programmers\Nenforce these policies
Dialogue: 0,1:59:11.60,1:59:15.48,Default,,0,0,0,,by strewing policy enforcing\Ncode or policy checks
Dialogue: 0,1:59:15.48,1:59:17.28,Default,,0,0,0,,throughout the application.
Dialogue: 0,1:59:18.00,1:59:21.04,Default,,0,0,0,,It is all too easy to\Nmiss a check by mistake
Dialogue: 0,1:59:21.04,1:59:23.72,Default,,0,0,0,,causing a potential\Ninformation leak.
Dialogue: 0,1:59:24.28,1:59:28.56,Default,,0,0,0,,A much better approach is to let\Nprogrammers specify policies
Dialogue: 0,1:59:28.56,1:59:31.76,Default,,0,0,0,,declaratively and separately\Nfrom the application code.
Dialogue: 0,1:59:32.08,1:59:35.44,Default,,0,0,0,,And then, let an information\Nflow control framework
Dialogue: 0,1:59:35.44,1:59:39.00,Default,,0,0,0,,ensure that the code\Nsatisfies these policies.
Dialogue: 0,1:59:39.48,1:59:43.44,Default,,0,0,0,,IFC frameworks come in two\Nflavors - static and dynamic
Dialogue: 0,1:59:43.44,1:59:46.52,Default,,0,0,0,,which have complementary\Nstrengths and weaknesses.
Dialogue: 0,1:59:46.92,1:59:49.84,Default,,0,0,0,,In this work, we will\Nfocus on static techniques
Dialogue: 0,1:59:49.84,1:59:54.48,Default,,0,0,0,,which ensure absence of leaks\Nonce and for all at compile time,
Dialogue: 0,1:59:54.56,2:00:00.64,Default,,0,0,0,,hence avoiding surprise failures\Nand performance overhead at runtime.
Dialogue: 0,2:00:00.64,2:00:05.64,Default,,0,0,0,,On the flip side, existing static\Ntechniques are unable to handle
Dialogue: 0,2:00:05.64,2:00:09.44,Default,,0,0,0,,rich policies that modern\Napplications need
Dialogue: 0,2:00:09.44,2:00:14.20,Default,,0,0,0,,or if they can, they require\Nprogrammers to provide proof hints
Dialogue: 0,2:00:14.20,2:00:16.80,Default,,0,0,0,,to verify absence of leaks.
Dialogue: 0,2:00:17.88,2:00:22.32,Default,,0,0,0,,In this work, we developed\Na new IFC framework called Lifty
Dialogue: 0,2:00:22.32,2:00:25.28,Default,,0,0,0,,short for Liquid\NInformation Flow Types
Dialogue: 0,2:00:25.28,2:00:29.32,Default,,0,0,0,,which combines the best of\Nstatic and dynamic techniques.
Dialogue: 0,2:00:29.88,2:00:34.56,Default,,0,0,0,,Lifty is a static framework\Nbut unlike existing static solutions,
Dialogue: 0,2:00:34.56,2:00:39.56,Default,,0,0,0,,it is able to verify rich security\Npolicies completely automatically.
Dialogue: 0,2:00:40.76,2:00:43.36,Default,,0,0,0,,To enable this\Nautomatic verification,
Dialogue: 0,2:00:43.36,2:00:47.16,Default,,0,0,0,,our first contribution\Nis an encoding of IFC
Dialogue: 0,2:00:47.16,2:00:50.84,Default,,0,0,0,,into a decidable type system\Nbased on liquid types,
Dialogue: 0,2:00:50.92,2:00:52.72,Default,,0,0,0,,hence the name.
Dialogue: 0,2:00:52.72,2:00:56.08,Default,,0,0,0,,Moreover, when the application code\Ndoes not satisfy the policies,
Dialogue: 0,2:00:56.08,2:00:59.28,Default,,0,0,0,,Lifty can automatically\Ngenerate leak patches
Dialogue: 0,2:00:59.28,2:01:01.84,Default,,0,0,0,,that make the code provably secure.
Dialogue: 0,2:01:02.36,2:01:05.48,Default,,0,0,0,,Our second contribution is\Na leak repair technique
Dialogue: 0,2:01:05.48,2:01:08.16,Default,,0,0,0,,based on type driven\Nprogram synthesis.
Dialogue: 0,2:01:08.16,2:01:09.84,Default,,0,0,0,,In the rest of this talk,
Dialogue: 0,2:01:09.84,2:01:13.60,Default,,0,0,0,,I will first introduce our encoding\Nof IFC into liquid types.
Dialogue: 0,2:01:14.40,2:01:17.64,Default,,0,0,0,,I will then give a demo of what\Nit's like to program in Lifty.
Dialogue: 0,2:01:17.64,2:01:20.56,Default,,0,0,0,,And finally, I will\Ngive an overview
Dialogue: 0,2:01:20.56,2:01:22.76,Default,,0,0,0,,of how Lifty's leak repair works.
Dialogue: 0,2:01:24.88,2:01:26.92,Default,,0,0,0,,In a liquid types system,
Dialogue: 0,2:01:26.92,2:01:29.56,Default,,0,0,0,,types are annotated with\Nlogical predicates
Dialogue: 0,2:01:29.56,2:01:31.24,Default,,0,0,0,,called refinements.
Dialogue: 0,2:01:31.68,2:01:33.40,Default,,0,0,0,,For example, this is how
Dialogue: 0,2:01:33.40,2:01:35.92,Default,,0,0,0,,you would specify\Nthe type of natural numbers.
Dialogue: 0,2:01:36.44,2:01:39.04,Default,,0,0,0,,By restricting refinements\Nto decidable logics,
Dialogue: 0,2:01:39.04,2:01:42.04,Default,,0,0,0,,liquid types provide fully\Nautomatic type checking
Dialogue: 0,2:01:42.04,2:01:44.12,Default,,0,0,0,,of non-trivial program properties.
Dialogue: 0,2:01:44.48,2:01:48.20,Default,,0,0,0,,But can we use refinement types\Nto encode security policies?
Dialogue: 0,2:01:48.72,2:01:51.52,Default,,0,0,0,,To answer this question,\Nwe draw inspiration
Dialogue: 0,2:01:51.52,2:01:54.96,Default,,0,0,0,,from another line of prior\Nwork, security monads.
Dialogue: 0,2:01:55.88,2:01:59.52,Default,,0,0,0,,In this approach, computations\Nthat manipulate sensitive data
Dialogue: 0,2:01:59.52,2:02:04.12,Default,,0,0,0,,live inside a special monad\Nwhich we will refer to as TIO.
Dialogue: 0,2:02:04.12,2:02:08.64,Default,,0,0,0,,For example, TIO Int is\Nthe type of sensitive computations
Dialogue: 0,2:02:08.64,2:02:10.72,Default,,0,0,0,,that return an integer.
Dialogue: 0,2:02:11.08,2:02:12.32,Default,,0,0,0,,The purpose of the security monad
Dialogue: 0,2:02:12.32,2:02:15.44,Default,,0,0,0,,is to keep track of\Nthe security level of the data
Dialogue: 0,2:02:15.44,2:02:17.32,Default,,0,0,0,,that the computation manipulates
Dialogue: 0,2:02:17.32,2:02:20.84,Default,,0,0,0,,and to disallow unsafe\Ninformation flows.
Dialogue: 0,2:02:21.32,2:02:26.32,Default,,0,0,0,,In Lifty, the security level is\Nrecorded in the TIO type itself.
Dialogue: 0,2:02:26.80,2:02:28.36,Default,,0,0,0,,Apart from the return type,
Dialogue: 0,2:02:28.36,2:02:31.24,Default,,0,0,0,,TIO is parameterized by\Ntwo refinement predicates -
Dialogue: 0,2:02:31.24,2:02:33.64,Default,,0,0,0,,the input and the output label -
Dialogue: 0,2:02:34.04,2:02:37.52,Default,,0,0,0,,which specify the security levels\Nof the input and output effects
Dialogue: 0,2:02:37.52,2:02:39.76,Default,,0,0,0,,of a TIO computation.
Dialogue: 0,2:02:40.36,2:02:44.12,Default,,0,0,0,,More precisely, the input label\Nspecifies the set of users
Dialogue: 0,2:02:44.12,2:02:47.68,Default,,0,0,0,,that are allowed to see\Nthe data read by this computation.
Dialogue: 0,2:02:48.04,2:02:50.68,Default,,0,0,0,,The output label specifies\Nthe set of users
Dialogue: 0,2:02:50.68,2:02:54.20,Default,,0,0,0,,who will see the data\Nwritten by this computation.
Dialogue: 0,2:02:54.68,2:02:57.64,Default,,0,0,0,,Both labels are predicates\Nfrom the refinement logic
Dialogue: 0,2:02:57.64,2:03:00.12,Default,,0,0,0,,and can refer to variables in scope
Dialogue: 0,2:03:00.12,2:03:02.52,Default,,0,0,0,,as well as a special\Nviewer variable.
Dialogue: 0,2:03:03.60,2:03:08.16,Default,,0,0,0,,Now, let's see how a Lifty\Nprogrammer builds TIO computations.
Dialogue: 0,2:03:08.60,2:03:11.48,Default,,0,0,0,,The building blocks\Nof a TIO computation
Dialogue: 0,2:03:11.48,2:03:15.80,Default,,0,0,0,,are atomic input and output\Nactions that the programmer writes
Dialogue: 0,2:03:15.80,2:03:19.84,Default,,0,0,0,,to model sources and sinks of\Nsensitive data in the system.
Dialogue: 0,2:03:20.36,2:03:23.88,Default,,0,0,0,,For example, if my program\Ncan access a shared key
Dialogue: 0,2:03:23.88,2:03:26.24,Default,,0,0,0,,that belongs to Alice and Bob,
Dialogue: 0,2:03:26.24,2:03:28.60,Default,,0,0,0,,I can give this action\Nthe following type.
Dialogue: 0,2:03:29.24,2:03:31.24,Default,,0,0,0,,Here, the input label specifies
Dialogue: 0,2:03:31.24,2:03:33.68,Default,,0,0,0,,that the key is only\Nvisible to Alice and Bob,
Dialogue: 0,2:03:33.68,2:03:37.40,Default,,0,0,0,,while the output label false\Nguarantees that this computation
Dialogue: 0,2:03:37.40,2:03:41.24,Default,,0,0,0,,will not perform any\Nuser-visible output.
Dialogue: 0,2:03:41.88,2:03:45.84,Default,,0,0,0,,On the other hand, I can\Ndefine an output action print
Dialogue: 0,2:03:45.84,2:03:49.24,Default,,0,0,0,,that outputs a string\Nto a given recipient.
Dialogue: 0,2:03:49.64,2:03:52.52,Default,,0,0,0,,The output label of\Nits type guarantees
Dialogue: 0,2:03:52.52,2:03:55.80,Default,,0,0,0,,that only the intended\Nrecipient will see the string
Dialogue: 0,2:03:55.80,2:03:59.28,Default,,0,0,0,,while the input label true indicates
Dialogue: 0,2:03:59.28,2:04:01.96,Default,,0,0,0,,that the return value\Nunit is public.
Dialogue: 0,2:04:02.60,2:04:04.68,Default,,0,0,0,,Good luck trying to hide a unit!
Dialogue: 0,2:04:05.48,2:04:08.60,Default,,0,0,0,,Note that function types in\NLifty can be dependent,
Dialogue: 0,2:04:08.60,2:04:13.32,Default,,0,0,0,,so the label of the result can depend\Non the value of the argument.
Dialogue: 0,2:04:13.32,2:04:17.24,Default,,0,0,0,,This allows Lifty programmers to\Nencode rich security policies
Dialogue: 0,2:04:17.24,2:04:19.68,Default,,0,0,0,,as types of TIO actions.
Dialogue: 0,2:04:20.84,2:04:26.12,Default,,0,0,0,,Atomic actions are combined into\Ncomputations using the TIO API
Dialogue: 0,2:04:26.12,2:04:27.96,Default,,0,0,0,,that Lifty provides.
Dialogue: 0,2:04:28.40,2:04:31.88,Default,,0,0,0,,The core of the API are\Nthe standard monadic primitives
Dialogue: 0,2:04:31.96,2:04:33.96,Default,,0,0,0,,return and bind.
Dialogue: 0,2:04:33.96,2:04:38.32,Default,,0,0,0,,Return simply wraps a pure value\Ninto a sensitive computation,
Dialogue: 0,2:04:38.64,2:04:40.80,Default,,0,0,0,,and so, its labels are trivial.
Dialogue: 0,2:04:41.20,2:04:42.88,Default,,0,0,0,,The type of bind on the other hand
Dialogue: 0,2:04:42.88,2:04:46.88,Default,,0,0,0,,is key to correctly tracking\Ninformation flow in Lifty.
Dialogue: 0,2:04:47.28,2:04:50.52,Default,,0,0,0,,Bind sequences two\Ncomputations X and Y
Dialogue: 0,2:04:50.52,2:04:53.80,Default,,0,0,0,,such that the result\Nof X flows into Y.
Dialogue: 0,2:04:54.56,2:04:58.12,Default,,0,0,0,,The type of bind is polymorphic\Nin the labels of these actions,
Dialogue: 0,2:04:58.12,2:05:00.96,Default,,0,0,0,,but not any four labels would do.
Dialogue: 0,2:05:00.96,2:05:06.56,Default,,0,0,0,,To avoid leaks, we need to ensure\Nthat Y only outputs to those users
Dialogue: 0,2:05:06.60,2:05:09.20,Default,,0,0,0,,who are allowed to\Nsee the result of X.
Dialogue: 0,2:05:09.64,2:05:13.52,Default,,0,0,0,,This is encoded by adding\Nthe input label i of X
Dialogue: 0,2:05:13.52,2:05:16.36,Default,,0,0,0,,as a conjunct to\Nthe output label of Y
Dialogue: 0,2:05:16.36,2:05:21.48,Default,,0,0,0,,essentially enforcing that Y's output\Nlabel is more restrictive than i.
Dialogue: 0,2:05:22.44,2:05:25.76,Default,,0,0,0,,Finally, the input label of\Nthe sequence of X and Y
Dialogue: 0,2:05:25.76,2:05:28.12,Default,,0,0,0,,is the conjunction of\Ntheir input labels
Dialogue: 0,2:05:28.12,2:05:31.96,Default,,0,0,0,,and the output label is\Nthe disjunction of their output labels.
Dialogue: 0,2:05:33.08,2:05:36.52,Default,,0,0,0,,The TIO API has a third\Nprimitive operation
Dialogue: 0,2:05:36.52,2:05:40.40,Default,,0,0,0,,for leak-free downgrading\Nwhich plays an important role
Dialogue: 0,2:05:40.40,2:05:42.52,Default,,0,0,0,,in applications with rich policies
Dialogue: 0,2:05:42.52,2:05:45.76,Default,,0,0,0,,but I will skip its description\Nin the interest of time.
Dialogue: 0,2:05:47.12,2:05:49.28,Default,,0,0,0,,The TIO library also provides
Dialogue: 0,2:05:49.28,2:05:52.04,Default,,0,0,0,,a range of convenient\Nmonadic combinators -
Dialogue: 0,2:05:52.04,2:05:57.04,Default,,0,0,0,,for example, mapM for mapping\Na sensitive computation over a list.
Dialogue: 0,2:05:57.28,2:05:59.92,Default,,0,0,0,,Note that while\Nthe primitive operations
Dialogue: 0,2:05:59.92,2:06:02.24,Default,,0,0,0,,are part of the trusted\Ncomputing base,
Dialogue: 0,2:06:02.24,2:06:04.56,Default,,0,0,0,,the derived operations are not.
Dialogue: 0,2:06:05.00,2:06:07.84,Default,,0,0,0,,They're implemented in terms\Nof the primitive operations
Dialogue: 0,2:06:07.84,2:06:10.80,Default,,0,0,0,,and are type checked\Nusing Lifty itself.
Dialogue: 0,2:06:11.20,2:06:12.84,Default,,0,0,0,,Now, let's see how I can use Lifty
Dialogue: 0,2:06:12.84,2:06:16.56,Default,,0,0,0,,to implement some simple functionality\Nof a conference manager.
Dialogue: 0,2:06:17.28,2:06:20.36,Default,,0,0,0,,Say I'm on the program\Ncommittee of IFCP 20
Dialogue: 0,2:06:20.36,2:06:22.84,Default,,0,0,0,,and I'm viewing the list\Nof all submissions,
Dialogue: 0,2:06:22.84,2:06:27.20,Default,,0,0,0,,but I'm also an author of one of\Nthe submissions highlighted in grey.
Dialogue: 0,2:06:27.88,2:06:30.96,Default,,0,0,0,,As an author, I have a conflict\Nwith this submission.
Dialogue: 0,2:06:31.24,2:06:35.52,Default,,0,0,0,,The conference manager has\Na policy that a conflicted reviewer
Dialogue: 0,2:06:35.52,2:06:39.76,Default,,0,0,0,,is not supposed to learn\Nthe score or the decision for a paper
Dialogue: 0,2:06:39.76,2:06:41.92,Default,,0,0,0,,until the notifications are out.
Dialogue: 0,2:06:42.72,2:06:46.20,Default,,0,0,0,,Consider the following\Nhypothetical but insidious leak
Dialogue: 0,2:06:46.20,2:06:48.36,Default,,0,0,0,,that violates this policy.
Dialogue: 0,2:06:48.84,2:06:54.24,Default,,0,0,0,,As a reviewer, I can sort the list\Nof all submissions by their score.
Dialogue: 0,2:06:54.24,2:06:56.40,Default,,0,0,0,,If the programmer is not careful,
Dialogue: 0,2:06:56.40,2:06:59.76,Default,,0,0,0,,the sorting function might\Nuse the true hidden value
Dialogue: 0,2:06:59.76,2:07:03.20,Default,,0,0,0,,of the score for my\Npaper for ordering.
Dialogue: 0,2:07:03.60,2:07:06.48,Default,,0,0,0,,In this case, even though\Nthe score is still masked,
Dialogue: 0,2:07:06.48,2:07:09.52,Default,,0,0,0,,by looking at the position\Nof my paper in the list,
Dialogue: 0,2:07:09.52,2:07:14.72,Default,,0,0,0,,I can infer that the score is\Nsomewhere between 1.8 and 2.0
Dialogue: 0,2:07:14.72,2:07:17.16,Default,,0,0,0,,and hence, the paper has\Nlikely been accepted.
Dialogue: 0,2:07:17.16,2:07:18.40,Default,,0,0,0,,Yes!
Dialogue: 0,2:07:19.00,2:07:22.84,Default,,0,0,0,,Let's see how Lifty would\Nhelp us prevent this leak.
Dialogue: 0,2:07:23.32,2:07:25.60,Default,,0,0,0,,To implement a conference\Nmanager in Lifty,
Dialogue: 0,2:07:25.60,2:07:28.60,Default,,0,0,0,,I'll start by encoding\Nthe interface to the data store
Dialogue: 0,2:07:28.60,2:07:30.88,Default,,0,0,0,,as a set of atomic TIO actions.
Dialogue: 0,2:07:31.32,2:07:33.52,Default,,0,0,0,,For example, I'll add\Nan action that retrieves
Dialogue: 0,2:07:33.52,2:07:36.36,Default,,0,0,0,,the list of all submission\NIDs from the data store
Dialogue: 0,2:07:36.36,2:07:40.04,Default,,0,0,0,,and action that retrieves\Na paper title by its ID
Dialogue: 0,2:07:40.04,2:07:43.08,Default,,0,0,0,,and so on for each column\Nof my submissions table.
Dialogue: 0,2:07:43.68,2:07:45.52,Default,,0,0,0,,Now, it's time to add policies.
Dialogue: 0,2:07:45.52,2:07:48.60,Default,,0,0,0,,Recall that paper scores\Nare restricted to users
Dialogue: 0,2:07:48.60,2:07:50.36,Default,,0,0,0,,who are not conflicted\Nwith the paper.
Dialogue: 0,2:07:50.36,2:07:52.40,Default,,0,0,0,,So, I would like to\Nchange the input label
Dialogue: 0,2:07:52.40,2:07:55.08,Default,,0,0,0,,of getPaperScore to\Nreflect this policy.
Dialogue: 0,2:07:55.60,2:07:57.68,Default,,0,0,0,,Although the refinement\Nlogic does not allow
Dialogue: 0,2:07:57.68,2:07:59.28,Default,,0,0,0,,mentioning program level functions
Dialogue: 0,2:07:59.28,2:08:02.16,Default,,0,0,0,,like getPaperConflicts inside labels.
Dialogue: 0,2:08:02.52,2:08:06.24,Default,,0,0,0,,I can define an uninterpreted\Nlogic-level function conflicts
Dialogue: 0,2:08:06.24,2:08:09.84,Default,,0,0,0,,that denotes the set of user\Nconflicted with a given paper.
Dialogue: 0,2:08:10.32,2:08:14.40,Default,,0,0,0,,I can now use this function to\Nspecify the desired policy on scores
Dialogue: 0,2:08:14.40,2:08:16.28,Default,,0,0,0,,that they are only visible to users
Dialogue: 0,2:08:16.28,2:08:18.28,Default,,0,0,0,,who are not in the set of conflicts.
Dialogue: 0,2:08:18.68,2:08:22.16,Default,,0,0,0,,To connect my logic level function\Nto the data I get from the store,
Dialogue: 0,2:08:22.16,2:08:25.92,Default,,0,0,0,,I will refine the result\Ntype of getPaperConflicts
Dialogue: 0,2:08:25.92,2:08:29.28,Default,,0,0,0,,stating that it retrieves\Nexactly the same users
Dialogue: 0,2:08:29.28,2:08:31.60,Default,,0,0,0,,as those denoted by conflicts.
Dialogue: 0,2:08:32.20,2:08:35.00,Default,,0,0,0,,Finally, let's implement\Nthe sorting functionality.
Dialogue: 0,2:08:35.36,2:08:39.16,Default,,0,0,0,,To this end, I will write\Na function sortPapersByScore
Dialogue: 0,2:08:39.16,2:08:41.56,Default,,0,0,0,,that takes as input\Na data store, ds
Dialogue: 0,2:08:41.56,2:08:43.52,Default,,0,0,0,,and the current user, client.
Dialogue: 0,2:08:44.04,2:08:46.48,Default,,0,0,0,,Lifty supports\Na Haskell-like do notation
Dialogue: 0,2:08:46.48,2:08:50.60,Default,,0,0,0,,that desugars into invocations\Nof bind in a standard way.
Dialogue: 0,2:08:51.08,2:08:53.56,Default,,0,0,0,,Here, I first retrieved\Nthe list of all submissions,
Dialogue: 0,2:08:53.56,2:08:56.00,Default,,0,0,0,,then sort them using\Na custom comparator
Dialogue: 0,2:08:56.00,2:08:57.52,Default,,0,0,0,,that I will implement shortly
Dialogue: 0,2:08:57.52,2:08:59.28,Default,,0,0,0,,and finally project the paper titles
Dialogue: 0,2:08:59.28,2:09:01.24,Default,,0,0,0,,and output them to the current user.
Dialogue: 0,2:09:01.64,2:09:03.28,Default,,0,0,0,,Our custom comparator function
Dialogue: 0,2:09:03.28,2:09:06.00,Default,,0,0,0,,retrieves the scores of\Nthe two papers from the store
Dialogue: 0,2:09:06.00,2:09:07.44,Default,,0,0,0,,and compares them.
Dialogue: 0,2:09:07.84,2:09:10.64,Default,,0,0,0,,I might not realize that\Nthe functionality I just implemented
Dialogue: 0,2:09:10.64,2:09:12.08,Default,,0,0,0,,leaks information.
Dialogue: 0,2:09:12.44,2:09:15.48,Default,,0,0,0,,After all, I'm only printing\Npaper titles which are public.
Dialogue: 0,2:09:15.92,2:09:18.28,Default,,0,0,0,,Thankfully, Lifty is\Nwatching my back.
Dialogue: 0,2:09:18.68,2:09:21.04,Default,,0,0,0,,If I ask to type check my program,
Dialogue: 0,2:09:21.04,2:09:23.36,Default,,0,0,0,,it reports two policy violations
Dialogue: 0,2:09:23.36,2:09:25.72,Default,,0,0,0,,for the two calls to getPaperScore.
Dialogue: 0,2:09:25.72,2:09:30.00,Default,,0,0,0,,Lifty is complaining that\Nthey're not visible to client.
Dialogue: 0,2:09:30.00,2:09:32.36,Default,,0,0,0,,Instead of trying to\Ndecipher the error message
Dialogue: 0,2:09:32.36,2:09:33.84,Default,,0,0,0,,and fix the leak myself
Dialogue: 0,2:09:33.84,2:09:36.20,Default,,0,0,0,,I can ask Lifty to do it for me.
Dialogue: 0,2:09:36.20,2:09:39.44,Default,,0,0,0,,In this case, Lifty\Nreturns a modified program
Dialogue: 0,2:09:39.44,2:09:43.76,Default,,0,0,0,,where either call to getPaperScore\Nis wrapper in a policy check.
Dialogue: 0,2:09:43.76,2:09:47.28,Default,,0,0,0,,The check retrieves\Nthe conflict list for this paper
Dialogue: 0,2:09:47.28,2:09:50.44,Default,,0,0,0,,and checks whether\Nthe client is on that list.
Dialogue: 0,2:09:50.44,2:09:52.44,Default,,0,0,0,,If client is in fact conflicted
Dialogue: 0,2:09:52.44,2:09:57.24,Default,,0,0,0,,our generated patch returns\Na default score of zero.
Dialogue: 0,2:09:57.24,2:09:58.72,Default,,0,0,0,,In the final part of the talk
Dialogue: 0,2:09:58.72,2:10:03.12,Default,,0,0,0,,let's see how Lifty's leak\Nrepair works under the hood.
Dialogue: 0,2:10:03.12,2:10:06.96,Default,,0,0,0,,Consider a stripped down version of\Nthe leak I just showed you.
Dialogue: 0,2:10:06.96,2:10:10.44,Default,,0,0,0,,In this version we simply\Nread the paper score
Dialogue: 0,2:10:10.44,2:10:12.76,Default,,0,0,0,,and directly show it to the user
Dialogue: 0,2:10:12.76,2:10:15.60,Default,,0,0,0,,who of course might be conflicted.
Dialogue: 0,2:10:15.60,2:10:18.04,Default,,0,0,0,,How does Lifty repair this leak?
Dialogue: 0,2:10:18.04,2:10:20.80,Default,,0,0,0,,The key insight is to\Nuse the information
Dialogue: 0,2:10:20.80,2:10:23.12,Default,,0,0,0,,from the failed type\Nchecking attempt
Dialogue: 0,2:10:23.12,2:10:29.20,Default,,0,0,0,,to localize the leak and infer\Na local specification for the patch.
Dialogue: 0,2:10:29.24,2:10:34.24,Default,,0,0,0,,First, let's desugar the do-notation\Ninto invocations of bind.
Dialogue: 0,2:10:34.24,2:10:35.88,Default,,0,0,0,,While type checking the program
Dialogue: 0,2:10:35.88,2:10:39.40,Default,,0,0,0,,Lifty infers the following\Ntypes for the two computations
Dialogue: 0,2:10:39.40,2:10:41.40,Default,,0,0,0,,sequenced by bind.
Dialogue: 0,2:10:41.40,2:10:44.52,Default,,0,0,0,,Now recall that our type\Nsignature for bind
Dialogue: 0,2:10:44.52,2:10:47.80,Default,,0,0,0,,enforces that the output label\Nof the second computation
Dialogue: 0,2:10:47.80,2:10:51.64,Default,,0,0,0,,be more restrictive than\Nthe input label of the first one
Dialogue: 0,2:10:51.64,2:10:53.48,Default,,0,0,0,,hence type checking in this case
Dialogue: 0,2:10:53.48,2:10:57.64,Default,,0,0,0,,reduces to the following\Nimplication between the labels.
Dialogue: 0,2:10:57.64,2:11:01.76,Default,,0,0,0,,Lifty uses an SMT solver to\Nvalidate this implication.
Dialogue: 0,2:11:01.76,2:11:03.76,Default,,0,0,0,,In this case the check fails
Dialogue: 0,2:11:03.76,2:11:06.96,Default,,0,0,0,,and the program is deemed ill-typed.
Dialogue: 0,2:11:06.96,2:11:10.04,Default,,0,0,0,,Lifty keeps track of\Nwhich input action
Dialogue: 0,2:11:10.04,2:11:13.40,Default,,0,0,0,,generated the right-hand side\Nof the failed implication.
Dialogue: 0,2:11:13.40,2:11:17.04,Default,,0,0,0,,So it knows exactly\Nwhere the leak occurred.
Dialogue: 0,2:11:17.04,2:11:20.56,Default,,0,0,0,,In this case, the problem is\Nthe call to getPaperScore
Dialogue: 0,2:11:20.56,2:11:24.64,Default,,0,0,0,,whose result is too\Nsensitive for its context.
Dialogue: 0,2:11:24.64,2:11:28.40,Default,,0,0,0,,To fix the leak Lifty replaces\Nthe offending input action
Dialogue: 0,2:11:28.40,2:11:29.88,Default,,0,0,0,,with a patch template
Dialogue: 0,2:11:29.88,2:11:33.80,Default,,0,0,0,,whose intention is to return\Nthe original value whenever it's safe
Dialogue: 0,2:11:33.80,2:11:39.28,Default,,0,0,0,,and otherwise return a less\Nsensitive default or redacted value.
Dialogue: 0,2:11:39.36,2:11:41.36,Default,,0,0,0,,Crucially the Lifty type checker
Dialogue: 0,2:11:41.36,2:11:44.92,Default,,0,0,0,,not only pinpoints the input\Naction that needs to be replaced
Dialogue: 0,2:11:44.92,2:11:49.60,Default,,0,0,0,,but also infers a local specification\Nthat the patch needs to satisfy
Dialogue: 0,2:11:49.60,2:11:52.16,Default,,0,0,0,,in order for\Nthe program to be secure.
Dialogue: 0,2:11:52.16,2:11:55.72,Default,,0,0,0,,In particular, the optimal\Ninput label for the patch
Dialogue: 0,2:11:55.72,2:12:01.60,Default,,0,0,0,,is derived directly from the left-hand\Nside of the failed implication.
Dialogue: 0,2:12:01.68,2:12:04.00,Default,,0,0,0,,With the local specification at hand
Dialogue: 0,2:12:04.00,2:12:07.48,Default,,0,0,0,,we can use our prior work on\Ntype-driven program synthesis
Dialogue: 0,2:12:07.48,2:12:10.08,Default,,0,0,0,,to fill the holes in the patch,
Dialogue: 0,2:12:10.08,2:12:13.08,Default,,0,0,0,,checking whether the client\Nis conflicted with the paper
Dialogue: 0,2:12:13.08,2:12:16.52,Default,,0,0,0,,and if so returning zero.
Dialogue: 0,2:12:16.60,2:12:19.00,Default,,0,0,0,,Thanks to the inferred\Nlocal specification
Dialogue: 0,2:12:19.00,2:12:23.56,Default,,0,0,0,,synthesis is performed completely\Nindependently for each leak.
Dialogue: 0,2:12:23.64,2:12:28.60,Default,,0,0,0,,So leak repair scales reasonably well\Nto programs with multiple leaks
Dialogue: 0,2:12:28.60,2:12:30.48,Default,,0,0,0,,as we have seen in the demo.
Dialogue: 0,2:12:30.48,2:12:31.48,Default,,0,0,0,,In conclusion,
Dialogue: 0,2:12:31.48,2:12:35.68,Default,,0,0,0,,we have presented a new static\NIFC framework called Lifty.
Dialogue: 0,2:12:35.68,2:12:39.92,Default,,0,0,0,,Lifty is able to statically\Nand automatically verify applications
Dialogue: 0,2:12:39.92,2:12:42.76,Default,,0,0,0,,against rich security policies
Dialogue: 0,2:12:42.76,2:12:44.68,Default,,0,0,0,,and suggest leak patches
Dialogue: 0,2:12:44.68,2:12:48.00,Default,,0,0,0,,when the application does\Nnot satisfy the policies.
Dialogue: 0,2:12:48.00,2:12:50.40,Default,,0,0,0,,You can play with Lifty\Nthrough our web interface
Dialogue: 0,2:12:50.40,2:12:55.40,Default,,0,0,0,,available at this link.
Dialogue: 0,2:13:01.36,2:13:04.44,Default,,0,0,0,,ALAN JEFFREY: Thank you Jean and Nadia.
Dialogue: 0,2:13:04.44,2:13:09.24,Default,,0,0,0,,So there's going to be a\Nlive Q&A for this talk
Dialogue: 0,2:13:09.32,2:13:12.52,Default,,0,0,0,,if you are in the New York timezone
Dialogue: 0,2:13:12.52,2:13:17.08,Default,,0,0,0,,and you can get to it as\Nusual by going to the link in Clowdr.
Dialogue: 0,2:13:17.08,2:13:19.32,Default,,0,0,0,,So now if you would like to join us
Dialogue: 0,2:13:19.32,2:13:24.20,Default,,0,0,0,,for the virtual milling outside\Nthe conference hall
Dialogue: 0,2:13:24.24,2:13:26.68,Default,,0,0,0,,chatting and drinking coffee
Dialogue: 0,2:13:26.68,2:13:31.68,Default,,0,0,0,,that would be great.
